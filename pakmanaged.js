var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:wrappy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Returns a wrapper function that returns a wrapped callback
    // The wrapper function should do some stuff, and return a
    // presumably different callback function.
    // This makes sure that own properties are retained, so that
    // decorations and such are not lost along the way.
    module.exports = wrappy
    function wrappy (fn, cb) {
      if (fn && cb) return wrappy(fn)(cb)
    
      if (typeof fn !== 'function')
        throw new TypeError('need wrapper function')
    
      Object.keys(fn).forEach(function (k) {
        wrapper[k] = fn[k]
      })
    
      return wrapper
    
      function wrapper() {
        var args = new Array(arguments.length)
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
        var ret = fn.apply(this, args)
        var cb = args[args.length-1]
        if (typeof ret === 'function' && ret !== cb) {
          Object.keys(cb).forEach(function (k) {
            ret[k] = cb[k]
          })
        }
        return ret
      }
    }
    
  provide("wrappy", module.exports);
}(global));

// pakmanager:balanced-match
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = balanced;
    function balanced(a, b, str) {
      var bal = 0;
      var m = {};
      var ended = false;
    
      for (var i = 0; i < str.length; i++) {
        if (a == str.substr(i, a.length)) {
          if (!('start' in m)) m.start = i;
          bal++;
        }
        else if (b == str.substr(i, b.length) && 'start' in m) {
          ended = true;
          bal--;
          if (!bal) {
            m.end = i;
            m.pre = str.substr(0, m.start);
            m.body = (m.end - m.start > 1)
              ? str.substring(m.start + a.length, m.end)
              : '';
            m.post = str.slice(m.end + b.length);
            return m;
          }
        }
      }
    
      // if we opened more than we closed, find the one we closed
      if (bal && ended) {
        var start = m.start + a.length;
        m = balanced(a, b, str.substr(start));
        if (m) {
          m.start += start;
          m.end += start;
          m.pre = str.slice(0, start) + m.pre;
        }
        return m;
      }
    }
    
  provide("balanced-match", module.exports);
}(global));

// pakmanager:concat-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            var x = fn(xs[i], i);
            if (isArray(x)) res.push.apply(res, x);
            else res.push(x);
        }
        return res;
    };
    
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
  provide("concat-map", module.exports);
}(global));

// pakmanager:once
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    module.exports = wrappy(once)
    
    once.proto = once(function () {
      Object.defineProperty(Function.prototype, 'once', {
        value: function () {
          return once(this)
        },
        configurable: true
      })
    })
    
    function once (fn) {
      var f = function () {
        if (f.called) return f.value
        f.called = true
        return f.value = fn.apply(this, arguments)
      }
      f.called = false
      return f
    }
    
  provide("once", module.exports);
}(global));

// pakmanager:brace-expansion
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var concatMap = require('concat-map');
    var balanced = require('balanced-match');
    
    module.exports = expandTop;
    
    var escSlash = '\0SLASH'+Math.random()+'\0';
    var escOpen = '\0OPEN'+Math.random()+'\0';
    var escClose = '\0CLOSE'+Math.random()+'\0';
    var escComma = '\0COMMA'+Math.random()+'\0';
    var escPeriod = '\0PERIOD'+Math.random()+'\0';
    
    function numeric(str) {
      return parseInt(str, 10) == str
        ? parseInt(str, 10)
        : str.charCodeAt(0);
    }
    
    function escapeBraces(str) {
      return str.split('\\\\').join(escSlash)
                .split('\\{').join(escOpen)
                .split('\\}').join(escClose)
                .split('\\,').join(escComma)
                .split('\\.').join(escPeriod);
    }
    
    function unescapeBraces(str) {
      return str.split(escSlash).join('\\')
                .split(escOpen).join('{')
                .split(escClose).join('}')
                .split(escComma).join(',')
                .split(escPeriod).join('.');
    }
    
    
    // Basically just str.split(","), but handling cases
    // where we have nested braced sections, which should be
    // treated as individual members, like {a,{b,c},d}
    function parseCommaParts(str) {
      if (!str)
        return [''];
    
      var parts = [];
      var m = balanced('{', '}', str);
    
      if (!m)
        return str.split(',');
    
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(',');
    
      p[p.length-1] += '{' + body + '}';
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length-1] += postParts.shift();
        p.push.apply(p, postParts);
      }
    
      parts.push.apply(parts, p);
    
      return parts;
    }
    
    function expandTop(str) {
      if (!str)
        return [];
    
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    
    function identity(e) {
      return e;
    }
    
    function embrace(str) {
      return '{' + str + '}';
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    
    function expand(str, isTop) {
      var expansions = [];
    
      var m = balanced('{', '}', str);
      if (!m || /\$$/.test(m.pre)) return [str];
    
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = /^(.*,)+(.+)?$/.test(m.body);
      if (!isSequence && !isOptions) {
        // {a},b}
        if (m.post.match(/,.*}/)) {
          str = m.pre + '{' + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
    
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          // x{{a,b}}y ==> x{a}y x{b}y
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length
              ? expand(m.post, false)
              : [''];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
    
      // at this point, n is the parts, and we know it's not a comma set
      // with a single entry.
    
      // no need to expand pre, since it is guaranteed to be free of brace-sets
      var pre = m.pre;
      var post = m.post.length
        ? expand(m.post, false)
        : [''];
    
      var N;
    
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length)
        var incr = n.length == 3
          ? Math.abs(numeric(n[2]))
          : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
    
        N = [];
    
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === '\\')
              c = '';
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join('0');
                if (i < 0)
                  c = '-' + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) { return expand(el, false) });
      }
    
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    
      return expansions;
    }
    
    
  provide("brace-expansion", module.exports);
}(global));

// pakmanager:inflight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    var reqs = Object.create(null)
    var once = require('once')
    
    module.exports = wrappy(inflight)
    
    function inflight (key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb)
        return null
      } else {
        reqs[key] = [cb]
        return makeres(key)
      }
    }
    
    function makeres (key) {
      return once(function RES () {
        var cbs = reqs[key]
        var len = cbs.length
        var args = slice(arguments)
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args)
        }
        if (cbs.length > len) {
          // added more in the interim.
          // de-zalgo, just in case, but don't call again.
          cbs.splice(0, len)
          process.nextTick(function () {
            RES.apply(null, args)
          })
        } else {
          delete reqs[key]
        }
      })
    }
    
    function slice (args) {
      var length = args.length
      var array = []
    
      for (var i = 0; i < length; i++) array[i] = args[i]
      return array
    }
    
  provide("inflight", module.exports);
}(global));

// pakmanager:inherits
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('util').inherits
    
  provide("inherits", module.exports);
}(global));

// pakmanager:minimatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = minimatch
    minimatch.Minimatch = Minimatch
    
    var path = { sep: '/' }
    try {
      path = require('path')
    } catch (er) {}
    
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
    var expand = require('brace-expansion')
    
    // any single thing other than /
    // don't need to escape / when using new RegExp()
    var qmark = '[^/]'
    
    // * => any number of characters
    var star = qmark + '*?'
    
    // ** when dots are allowed.  Anything goes, except .. and .
    // not (^ or / followed by one or two dots followed by $ or /),
    // followed by anything, any number of times.
    var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
    
    // not a ^ or / followed by a dot,
    // followed by anything, any number of times.
    var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
    
    // characters that need to be escaped in RegExp.
    var reSpecials = charSet('().*{}+?[]^$\\!')
    
    // "abc" -> { a:true, b:true, c:true }
    function charSet (s) {
      return s.split('').reduce(function (set, c) {
        set[c] = true
        return set
      }, {})
    }
    
    // normalizes slashes.
    var slashSplit = /\/+/
    
    minimatch.filter = filter
    function filter (pattern, options) {
      options = options || {}
      return function (p, i, list) {
        return minimatch(p, pattern, options)
      }
    }
    
    function ext (a, b) {
      a = a || {}
      b = b || {}
      var t = {}
      Object.keys(b).forEach(function (k) {
        t[k] = b[k]
      })
      Object.keys(a).forEach(function (k) {
        t[k] = a[k]
      })
      return t
    }
    
    minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return minimatch
    
      var orig = minimatch
    
      var m = function minimatch (p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options))
      }
    
      m.Minimatch = function Minimatch (pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options))
      }
    
      return m
    }
    
    Minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return Minimatch
      return minimatch.defaults(def).Minimatch
    }
    
    function minimatch (p, pattern, options) {
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }
    
      if (!options) options = {}
    
      // shortcut: comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        return false
      }
    
      // "" only matches ""
      if (pattern.trim() === '') return p === ''
    
      return new Minimatch(pattern, options).match(p)
    }
    
    function Minimatch (pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options)
      }
    
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }
    
      if (!options) options = {}
      pattern = pattern.trim()
    
      // windows support: need to use /, not \
      if (path.sep !== '/') {
        pattern = pattern.split(path.sep).join('/')
      }
    
      this.options = options
      this.set = []
      this.pattern = pattern
      this.regexp = null
      this.negate = false
      this.comment = false
      this.empty = false
    
      // make the set of regexps etc.
      this.make()
    }
    
    Minimatch.prototype.debug = function () {}
    
    Minimatch.prototype.make = make
    function make () {
      // don't do it more than once.
      if (this._made) return
    
      var pattern = this.pattern
      var options = this.options
    
      // empty patterns and comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        this.comment = true
        return
      }
      if (!pattern) {
        this.empty = true
        return
      }
    
      // step 1: figure out negation, etc.
      this.parseNegate()
    
      // step 2: expand braces
      var set = this.globSet = this.braceExpand()
    
      if (options.debug) this.debug = console.error
    
      this.debug(this.pattern, set)
    
      // step 3: now we have a set, so turn each one into a series of path-portion
      // matching patterns.
      // These will be regexps, except in the case of "**", which is
      // set to the GLOBSTAR object for globstar behavior,
      // and will not contain any / characters
      set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      })
    
      this.debug(this.pattern, set)
    
      // glob --> regexps
      set = set.map(function (s, si, set) {
        return s.map(this.parse, this)
      }, this)
    
      this.debug(this.pattern, set)
    
      // filter out everything that didn't compile properly.
      set = set.filter(function (s) {
        return s.indexOf(false) === -1
      })
    
      this.debug(this.pattern, set)
    
      this.set = set
    }
    
    Minimatch.prototype.parseNegate = parseNegate
    function parseNegate () {
      var pattern = this.pattern
      var negate = false
      var options = this.options
      var negateOffset = 0
    
      if (options.nonegate) return
    
      for (var i = 0, l = pattern.length
        ; i < l && pattern.charAt(i) === '!'
        ; i++) {
        negate = !negate
        negateOffset++
      }
    
      if (negateOffset) this.pattern = pattern.substr(negateOffset)
      this.negate = negate
    }
    
    // Brace expansion:
    // a{b,c}d -> abd acd
    // a{b,}c -> abc ac
    // a{0..3}d -> a0d a1d a2d a3d
    // a{b,c{d,e}f}g -> abg acdfg acefg
    // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
    //
    // Invalid sets are not expanded.
    // a{2..}b -> a{2..}b
    // a{b}c -> a{b}c
    minimatch.braceExpand = function (pattern, options) {
      return braceExpand(pattern, options)
    }
    
    Minimatch.prototype.braceExpand = braceExpand
    
    function braceExpand (pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options
        } else {
          options = {}
        }
      }
    
      pattern = typeof pattern === 'undefined'
        ? this.pattern : pattern
    
      if (typeof pattern === 'undefined') {
        throw new Error('undefined pattern')
      }
    
      if (options.nobrace ||
        !pattern.match(/\{.*\}/)) {
        // shortcut. no need to expand.
        return [pattern]
      }
    
      return expand(pattern)
    }
    
    // parse a component of the expanded set.
    // At this point, no pattern may contain "/" in it
    // so we're going to return a 2d array, where each entry is the full
    // pattern, split on '/', and then turned into a regular expression.
    // A regexp is made at the end which joins each array with an
    // escaped /, and another full one which joins each regexp with |.
    //
    // Following the lead of Bash 4.1, note that "**" only has special meaning
    // when it is the *only* thing in a path portion.  Otherwise, any series
    // of * is equivalent to a single *.  Globstar behavior is enabled by
    // default, and can be disabled by setting options.noglobstar.
    Minimatch.prototype.parse = parse
    var SUBPARSE = {}
    function parse (pattern, isSub) {
      var options = this.options
    
      // shortcuts
      if (!options.noglobstar && pattern === '**') return GLOBSTAR
      if (pattern === '') return ''
    
      var re = ''
      var hasMagic = !!options.nocase
      var escaping = false
      // ? => one single character
      var patternListStack = []
      var plType
      var stateChar
      var inClass = false
      var reClassStart = -1
      var classStart = -1
      // . and .. never match anything that doesn't start with .,
      // even when options.dot is set.
      var patternStart = pattern.charAt(0) === '.' ? '' // anything
      // not (start or / followed by . or .. followed by / or end)
      : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
      : '(?!\\.)'
      var self = this
    
      function clearStateChar () {
        if (stateChar) {
          // we had some state-tracking character
          // that wasn't consumed by this pass.
          switch (stateChar) {
            case '*':
              re += star
              hasMagic = true
            break
            case '?':
              re += qmark
              hasMagic = true
            break
            default:
              re += '\\' + stateChar
            break
          }
          self.debug('clearStateChar %j %j', stateChar, re)
          stateChar = false
        }
      }
    
      for (var i = 0, len = pattern.length, c
        ; (i < len) && (c = pattern.charAt(i))
        ; i++) {
        this.debug('%s\t%s %s %j', pattern, i, re, c)
    
        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
          re += '\\' + c
          escaping = false
          continue
        }
    
        switch (c) {
          case '/':
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false
    
          case '\\':
            clearStateChar()
            escaping = true
          continue
    
          // the various stateChar values
          // for the "extglob" stuff.
          case '?':
          case '*':
          case '+':
          case '@':
          case '!':
            this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)
    
            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              this.debug('  in class')
              if (c === '!' && i === classStart + 1) c = '^'
              re += c
              continue
            }
    
            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            self.debug('call clearStateChar %j', stateChar)
            clearStateChar()
            stateChar = c
            // if extglob is disabled, then +(asdf|foo) isn't a thing.
            // just clear the statechar *now*, rather than even diving into
            // the patternList stuff.
            if (options.noext) clearStateChar()
          continue
    
          case '(':
            if (inClass) {
              re += '('
              continue
            }
    
            if (!stateChar) {
              re += '\\('
              continue
            }
    
            plType = stateChar
            patternListStack.push({ type: plType, start: i - 1, reStart: re.length })
            // negation is (?:(?!js)[^/]*)
            re += stateChar === '!' ? '(?:(?!' : '(?:'
            this.debug('plType %j %j', stateChar, re)
            stateChar = false
          continue
    
          case ')':
            if (inClass || !patternListStack.length) {
              re += '\\)'
              continue
            }
    
            clearStateChar()
            hasMagic = true
            re += ')'
            plType = patternListStack.pop().type
            // negation is (?:(?!js)[^/]*)
            // The others are (?:<pattern>)<type>
            switch (plType) {
              case '!':
                re += '[^/]*?)'
                break
              case '?':
              case '+':
              case '*':
                re += plType
                break
              case '@': break // the default anyway
            }
          continue
    
          case '|':
            if (inClass || !patternListStack.length || escaping) {
              re += '\\|'
              escaping = false
              continue
            }
    
            clearStateChar()
            re += '|'
          continue
    
          // these are mostly the same in regexp and glob
          case '[':
            // swallow any state-tracking char before the [
            clearStateChar()
    
            if (inClass) {
              re += '\\' + c
              continue
            }
    
            inClass = true
            classStart = i
            reClassStart = re.length
            re += c
          continue
    
          case ']':
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += '\\' + c
              escaping = false
              continue
            }
    
            // handle the case where we left a class open.
            // "[z-a]" is valid, equivalent to "\[z-a\]"
            if (inClass) {
              // split where the last [ was, make sure we don't have
              // an invalid re. if so, re-walk the contents of the
              // would-be class to re-translate any characters that
              // were passed through as-is
              // TODO: It would probably be faster to determine this
              // without a try/catch and a new RegExp, but it's tricky
              // to do safely.  For now, this is safe and works.
              var cs = pattern.substring(classStart + 1, i)
              try {
                RegExp('[' + cs + ']')
              } catch (er) {
                // not a valid class!
                var sp = this.parse(cs, SUBPARSE)
                re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
                hasMagic = hasMagic || sp[1]
                inClass = false
                continue
              }
            }
    
            // finish up the class.
            hasMagic = true
            inClass = false
            re += c
          continue
    
          default:
            // swallow any state char that wasn't consumed
            clearStateChar()
    
            if (escaping) {
              // no need
              escaping = false
            } else if (reSpecials[c]
              && !(c === '^' && inClass)) {
              re += '\\'
            }
    
            re += c
    
        } // switch
      } // for
    
      // handle the case where we left a class open.
      // "[abc" is valid, equivalent to "\[abc"
      if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        cs = pattern.substr(classStart + 1)
        sp = this.parse(cs, SUBPARSE)
        re = re.substr(0, reClassStart) + '\\[' + sp[0]
        hasMagic = hasMagic || sp[1]
      }
    
      // handle the case where we had a +( thing at the *end*
      // of the pattern.
      // each pattern list stack adds 3 chars, and we need to go through
      // and escape any | chars that were passed through as-is for the regexp.
      // Go through and escape them, taking care not to double-escape any
      // | chars that were already escaped.
      for (var pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3)
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
          if (!$2) {
            // the | isn't already escaped, so escape it.
            $2 = '\\'
          }
    
          // need to escape all those slashes *again*, without escaping the
          // one that we need for escaping the | character.  As it works out,
          // escaping an even number of slashes can be done by simply repeating
          // it exactly after itself.  That's why this trick works.
          //
          // I am sorry that you have to see this.
          return $1 + $1 + $2 + '|'
        })
    
        this.debug('tail=%j\n   %s', tail, tail)
        var t = pl.type === '*' ? star
          : pl.type === '?' ? qmark
          : '\\' + pl.type
    
        hasMagic = true
        re = re.slice(0, pl.reStart) + t + '\\(' + tail
      }
    
      // handle trailing things that only matter at the very end.
      clearStateChar()
      if (escaping) {
        // trailing \\
        re += '\\\\'
      }
    
      // only need to apply the nodot start if the re starts with
      // something that could conceivably capture a dot
      var addPatternStart = false
      switch (re.charAt(0)) {
        case '.':
        case '[':
        case '(': addPatternStart = true
      }
    
      // if the re is not "" at this point, then we need to make sure
      // it doesn't match against an empty path part.
      // Otherwise a/* will match a/, which it should not.
      if (re !== '' && hasMagic) re = '(?=.)' + re
    
      if (addPatternStart) re = patternStart + re
    
      // parsing just a piece of a larger pattern.
      if (isSub === SUBPARSE) {
        return [re, hasMagic]
      }
    
      // skip the regexp for non-magical patterns
      // unescape anything in it, though, so that it'll be
      // an exact match against a file etc.
      if (!hasMagic) {
        return globUnescape(pattern)
      }
    
      var flags = options.nocase ? 'i' : ''
      var regExp = new RegExp('^' + re + '$', flags)
    
      regExp._glob = pattern
      regExp._src = re
    
      return regExp
    }
    
    minimatch.makeRe = function (pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe()
    }
    
    Minimatch.prototype.makeRe = makeRe
    function makeRe () {
      if (this.regexp || this.regexp === false) return this.regexp
    
      // at this point, this.set is a 2d array of partial
      // pattern strings, or "**".
      //
      // It's better to use .match().  This function shouldn't
      // be used, really, but it's pretty convenient sometimes,
      // when you just want to work with a regex.
      var set = this.set
    
      if (!set.length) {
        this.regexp = false
        return this.regexp
      }
      var options = this.options
    
      var twoStar = options.noglobstar ? star
        : options.dot ? twoStarDot
        : twoStarNoDot
      var flags = options.nocase ? 'i' : ''
    
      var re = set.map(function (pattern) {
        return pattern.map(function (p) {
          return (p === GLOBSTAR) ? twoStar
          : (typeof p === 'string') ? regExpEscape(p)
          : p._src
        }).join('\\\/')
      }).join('|')
    
      // must match entire pattern
      // ending in a * or ** will make it less strict.
      re = '^(?:' + re + ')$'
    
      // can match anything, as long as it's not this.
      if (this.negate) re = '^(?!' + re + ').*$'
    
      try {
        this.regexp = new RegExp(re, flags)
      } catch (ex) {
        this.regexp = false
      }
      return this.regexp
    }
    
    minimatch.match = function (list, pattern, options) {
      options = options || {}
      var mm = new Minimatch(pattern, options)
      list = list.filter(function (f) {
        return mm.match(f)
      })
      if (mm.options.nonull && !list.length) {
        list.push(pattern)
      }
      return list
    }
    
    Minimatch.prototype.match = match
    function match (f, partial) {
      this.debug('match', f, this.pattern)
      // short-circuit in the case of busted things.
      // comments, etc.
      if (this.comment) return false
      if (this.empty) return f === ''
    
      if (f === '/' && partial) return true
    
      var options = this.options
    
      // windows: need to use /, not \
      if (path.sep !== '/') {
        f = f.split(path.sep).join('/')
      }
    
      // treat the test path as a set of pathparts.
      f = f.split(slashSplit)
      this.debug(this.pattern, 'split', f)
    
      // just ONE of the pattern sets in this.set needs to match
      // in order for it to be valid.  If negating, then just one
      // match means that we have failed.
      // Either way, return on the first hit.
    
      var set = this.set
      this.debug(this.pattern, 'set', set)
    
      // Find the basename of the path by looking for the last non-empty segment
      var filename
      var i
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i]
        if (filename) break
      }
    
      for (i = 0; i < set.length; i++) {
        var pattern = set[i]
        var file = f
        if (options.matchBase && pattern.length === 1) {
          file = [filename]
        }
        var hit = this.matchOne(file, pattern, partial)
        if (hit) {
          if (options.flipNegate) return true
          return !this.negate
        }
      }
    
      // didn't get any hits.  this is success if it's a negative
      // pattern, failure otherwise.
      if (options.flipNegate) return false
      return this.negate
    }
    
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    Minimatch.prototype.matchOne = function (file, pattern, partial) {
      var options = this.options
    
      this.debug('matchOne',
        { 'this': this, file: file, pattern: pattern })
    
      this.debug('matchOne', file.length, pattern.length)
    
      for (var fi = 0,
          pi = 0,
          fl = file.length,
          pl = pattern.length
          ; (fi < fl) && (pi < pl)
          ; fi++, pi++) {
        this.debug('matchOne loop')
        var p = pattern[pi]
        var f = file[fi]
    
        this.debug(pattern, p, f)
    
        // should be impossible.
        // some invalid regexp stuff in the set.
        if (p === false) return false
    
        if (p === GLOBSTAR) {
          this.debug('GLOBSTAR', [pattern, p, f])
    
          // "**"
          // a/**/b/**/c would match the following:
          // a/b/x/y/z/c
          // a/x/y/z/b/c
          // a/b/x/b/x/c
          // a/b/c
          // To do this, take the rest of the pattern after
          // the **, and see if it would match the file remainder.
          // If so, return success.
          // If not, the ** "swallows" a segment, and try again.
          // This is recursively awful.
          //
          // a/**/b/**/c matching a/b/x/y/z/c
          // - a matches a
          // - doublestar
          //   - matchOne(b/x/y/z/c, b/**/c)
          //     - b matches b
          //     - doublestar
          //       - matchOne(x/y/z/c, c) -> no
          //       - matchOne(y/z/c, c) -> no
          //       - matchOne(z/c, c) -> no
          //       - matchOne(c, c) yes, hit
          var fr = fi
          var pr = pi + 1
          if (pr === pl) {
            this.debug('** at the end')
            // a ** at the end will just swallow the rest.
            // We have found a match.
            // however, it will not swallow /.x, unless
            // options.dot is set.
            // . and .. are *never* matched by **, for explosively
            // exponential reasons.
            for (; fi < fl; fi++) {
              if (file[fi] === '.' || file[fi] === '..' ||
                (!options.dot && file[fi].charAt(0) === '.')) return false
            }
            return true
          }
    
          // ok, let's see if we can swallow whatever we can.
          while (fr < fl) {
            var swallowee = file[fr]
    
            this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)
    
            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug('globstar found match!', fr, fl, swallowee)
              // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === '.' || swallowee === '..' ||
                (!options.dot && swallowee.charAt(0) === '.')) {
                this.debug('dot detected!', file, fr, pattern, pr)
                break
              }
    
              // ** swallows a segment, and continue.
              this.debug('globstar swallow a segment, and continue')
              fr++
            }
          }
    
          // no match was found.
          // However, in partial mode, we can't say this is necessarily over.
          // If there's more *pattern* left, then
          if (partial) {
            // ran out of file
            this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
            if (fr === fl) return true
          }
          return false
        }
    
        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit
        if (typeof p === 'string') {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase()
          } else {
            hit = f === p
          }
          this.debug('string match', p, f, hit)
        } else {
          hit = f.match(p)
          this.debug('pattern match', p, f, hit)
        }
    
        if (!hit) return false
      }
    
      // Note: ending in / means that we'll get a final ""
      // at the end of the pattern.  This can only match a
      // corresponding "" at the end of the file.
      // If the file ends in /, then it can only match a
      // a pattern that ends in /, unless the pattern just
      // doesn't have any more for it. But, a/b/ should *not*
      // match "a/b/*", even though "" matches against the
      // [^/]*? pattern, except in partial mode, where it might
      // simply not be reached yet.
      // However, a/b/ should still satisfy a/*
    
      // now either we fell off the end of the pattern, or we're done.
      if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true
      } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial
      } else if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
        return emptyFileEnd
      }
    
      // should be unreachable.
      throw new Error('wtf?')
    }
    
    // replace stuff like \* with *
    function globUnescape (s) {
      return s.replace(/\\(.)/g, '$1')
    }
    
    function regExpEscape (s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
    }
    
  provide("minimatch", module.exports);
}(global));

// pakmanager:path-is-absolute
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function posix(path) {
    	return path.charAt(0) === '/';
    };
    
    function win32(path) {
    	// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
    	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    	var result = splitDeviceRe.exec(path);
    	var device = result[1] || '';
    	var isUnc = !!device && device.charAt(1) !== ':';
    
    	// UNC paths are always absolute
    	return !!result[2] || isUnc;
    };
    
    module.exports = process.platform === 'win32' ? win32 : posix;
    module.exports.posix = posix;
    module.exports.win32 = win32;
    
  provide("path-is-absolute", module.exports);
}(global));

// pakmanager:ansi-regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function () {
    	return /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/g;
    };
    
  provide("ansi-regex", module.exports);
}(global));

// pakmanager:get-stdin
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = function (cb) {
    	var stdin = process.stdin;
    	var ret = '';
    
    	if (stdin.isTTY) {
    		setImmediate(cb, '');
    		return;
    	}
    
    	stdin.setEncoding('utf8');
    
    	stdin.on('readable', function () {
    		var chunk;
    
    		while (chunk = stdin.read()) {
    			ret += chunk;
    		}
    	});
    
    	stdin.on('end', function () {
    		cb(ret);
    	});
    };
    
    module.exports.buffer = function (cb) {
    	var stdin = process.stdin;
    	var ret = [];
    	var len = 0;
    
    	if (stdin.isTTY) {
    		setImmediate(cb, new Buffer(''));
    		return;
    	}
    
    	stdin.on('readable', function () {
    		var chunk;
    
    		while (chunk = stdin.read()) {
    			ret.push(chunk);
    			len += chunk.length;
    		}
    	});
    
    	stdin.on('end', function () {
    		cb(Buffer.concat(ret, len));
    	});
    };
    
  provide("get-stdin", module.exports);
}(global));

// pakmanager:glob/common.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.alphasort = alphasort
    exports.alphasorti = alphasorti
    exports.setopts = setopts
    exports.ownProp = ownProp
    exports.makeAbs = makeAbs
    exports.finish = finish
    exports.mark = mark
    exports.isIgnored = isIgnored
    exports.childrenIgnored = childrenIgnored
    
    function ownProp (obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field)
    }
    
    var path = require("path")
    var minimatch = require("minimatch")
    var isAbsolute = require("path-is-absolute")
    var Minimatch = minimatch.Minimatch
    
    function alphasorti (a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase())
    }
    
    function alphasort (a, b) {
      return a.localeCompare(b)
    }
    
    function setupIgnores (self, options) {
      self.ignore = options.ignore || []
    
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore]
    
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap)
      }
    }
    
    function ignoreMap (pattern) {
      var gmatcher = null
      if (pattern.slice(-3) === '/**') {
        var gpattern = pattern.replace(/(\/\*\*)+$/, '')
        gmatcher = new Minimatch(gpattern)
      }
    
      return {
        matcher: new Minimatch(pattern),
        gmatcher: gmatcher
      }
    }
    
    function setopts (self, pattern, options) {
      if (!options)
        options = {}
    
      // base-matching: just use globstar for that.
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar")
        }
        pattern = "**/" + pattern
      }
    
      self.silent = !!options.silent
      self.pattern = pattern
      self.strict = options.strict !== false
      self.realpath = !!options.realpath
      self.realpathCache = options.realpathCache || Object.create(null)
      self.follow = !!options.follow
      self.dot = !!options.dot
      self.mark = !!options.mark
      self.nodir = !!options.nodir
      if (self.nodir)
        self.mark = true
      self.sync = !!options.sync
      self.nounique = !!options.nounique
      self.nonull = !!options.nonull
      self.nosort = !!options.nosort
      self.nocase = !!options.nocase
      self.stat = !!options.stat
      self.noprocess = !!options.noprocess
    
      self.maxLength = options.maxLength || Infinity
      self.cache = options.cache || Object.create(null)
      self.statCache = options.statCache || Object.create(null)
      self.symlinks = options.symlinks || Object.create(null)
    
      setupIgnores(self, options)
    
      self.changedCwd = false
      var cwd = process.cwd()
      if (!ownProp(options, "cwd"))
        self.cwd = cwd
      else {
        self.cwd = options.cwd
        self.changedCwd = path.resolve(options.cwd) !== cwd
      }
    
      self.root = options.root || path.resolve(self.cwd, "/")
      self.root = path.resolve(self.root)
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/")
    
      self.nomount = !!options.nomount
    
      // disable comments and negation unless the user explicitly
      // passes in false as the option.
      options.nonegate = options.nonegate === false ? false : true
      options.nocomment = options.nocomment === false ? false : true
      deprecationWarning(options)
    
      self.minimatch = new Minimatch(pattern, options)
      self.options = self.minimatch.options
    }
    
    // TODO(isaacs): remove entirely in v6
    // exported to reset in tests
    exports.deprecationWarned
    function deprecationWarning(options) {
      if (!options.nonegate || !options.nocomment) {
        if (process.noDeprecation !== true && !exports.deprecationWarned) {
          var msg = 'glob WARNING: comments and negation will be disabled in v6'
          if (process.throwDeprecation)
            throw new Error(msg)
          else if (process.traceDeprecation)
            console.trace(msg)
          else
            console.error(msg)
    
          exports.deprecationWarned = true
        }
      }
    }
    
    function finish (self) {
      var nou = self.nounique
      var all = nou ? [] : Object.create(null)
    
      for (var i = 0, l = self.matches.length; i < l; i ++) {
        var matches = self.matches[i]
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            // do like the shell, and spit out the literal glob
            var literal = self.minimatch.globSet[i]
            if (nou)
              all.push(literal)
            else
              all[literal] = true
          }
        } else {
          // had matches
          var m = Object.keys(matches)
          if (nou)
            all.push.apply(all, m)
          else
            m.forEach(function (m) {
              all[m] = true
            })
        }
      }
    
      if (!nou)
        all = Object.keys(all)
    
      if (!self.nosort)
        all = all.sort(self.nocase ? alphasorti : alphasort)
    
      // at *some* point we statted all of these
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i])
        }
        if (self.nodir) {
          all = all.filter(function (e) {
            return !(/\/$/.test(e))
          })
        }
      }
    
      if (self.ignore.length)
        all = all.filter(function(m) {
          return !isIgnored(self, m)
        })
    
      self.found = all
    }
    
    function mark (self, p) {
      var abs = makeAbs(self, p)
      var c = self.cache[abs]
      var m = p
      if (c) {
        var isDir = c === 'DIR' || Array.isArray(c)
        var slash = p.slice(-1) === '/'
    
        if (isDir && !slash)
          m += '/'
        else if (!isDir && slash)
          m = m.slice(0, -1)
    
        if (m !== p) {
          var mabs = makeAbs(self, m)
          self.statCache[mabs] = self.statCache[abs]
          self.cache[mabs] = self.cache[abs]
        }
      }
    
      return m
    }
    
    // lotta situps...
    function makeAbs (self, f) {
      var abs = f
      if (f.charAt(0) === '/') {
        abs = path.join(self.root, f)
      } else if (isAbsolute(f) || f === '') {
        abs = f
      } else if (self.changedCwd) {
        abs = path.resolve(self.cwd, f)
      } else {
        abs = path.resolve(f)
      }
      return abs
    }
    
    
    // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
    // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
    function isIgnored (self, path) {
      if (!self.ignore.length)
        return false
    
      return self.ignore.some(function(item) {
        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
      })
    }
    
    function childrenIgnored (self, path) {
      if (!self.ignore.length)
        return false
    
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path))
      })
    }
    
  provide("glob/common.js", module.exports);
}(global));

// pakmanager:glob/glob.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    module.exports = glob
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var inherits = require('inherits')
    var EE = require('events').EventEmitter
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var globSync =  require('glob/sync.js')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var inflight = require('inflight')
    var util = require('util')
    var childrenIgnored = common.childrenIgnored
    
    var once = require('once')
    
    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {}
      if (!options) options = {}
    
      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }
    
      return new Glob(pattern, options, cb)
    }
    
    glob.sync = globSync
    var GlobSync = glob.GlobSync = globSync.GlobSync
    
    // old api surface
    glob.glob = glob
    
    glob.hasMagic = function (pattern, options_) {
      var options = util._extend({}, options_)
      options.noprocess = true
    
      var g = new Glob(pattern, options)
      var set = g.minimatch.set
      if (set.length > 1)
        return true
    
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }
    
      return false
    }
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
    
      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }
    
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)
    
      setopts(this, pattern, options)
      this._didRealPath = false
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (typeof cb === 'function') {
        cb = once(cb)
        this.on('error', cb)
        this.on('end', function (matches) {
          cb(null, matches)
        })
      }
    
      var self = this
      var n = this.minimatch.set.length
      this._processing = 0
      this.matches = new Array(n)
    
      this._emitQueue = []
      this._processQueue = []
      this.paused = false
    
      if (this.noprocess)
        return this
    
      if (n === 0)
        return done()
    
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done)
      }
    
      function done () {
        --self._processing
        if (self._processing <= 0)
          self._finish()
      }
    }
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
      if (this.aborted)
        return
    
      if (this.realpath && !this._didRealpath)
        return this._realpath()
    
      common.finish(this)
      this.emit('end', this.found)
    }
    
    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return
    
      this._didRealpath = true
    
      var n = this.matches.length
      if (n === 0)
        return this._finish()
    
      var self = this
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next)
    
      function next () {
        if (--n === 0)
          self._finish()
      }
    }
    
    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index]
      if (!matchset)
        return cb()
    
      var found = Object.keys(matchset)
      var self = this
      var n = found.length
    
      if (n === 0)
        return cb()
    
      var set = this.matches[index] = Object.create(null)
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p)
        fs.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true
          else if (er.syscall === 'stat')
            set[p] = true
          else
            self.emit('error', er) // srsly wtf right here
    
          if (--n === 0) {
            self.matches[index] = set
            cb()
          }
        })
      })
    }
    
    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit('abort')
    }
    
    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true
        this.emit('pause')
      }
    }
    
    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume')
        this.paused = false
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0)
          this._emitQueue.length = 0
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i]
            this._emitMatch(e[0], e[1])
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0)
          this._processQueue.length = 0
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i]
            this._processing--
            this._process(p[0], p[1], p[2], p[3])
          }
        }
      }
    }
    
    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob)
      assert(typeof cb === 'function')
    
      if (this.aborted)
        return
    
      this._processing++
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb])
        return
      }
    
      //console.error('PROCESS %d', this._processing, pattern)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
    }
    
    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this._emitMatch(index, e)
        }
        // This was the last one, and no stats were needed
        return cb()
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }
        this._process([e].concat(remain), index, inGlobStar, cb)
      }
      cb()
    }
    
    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return
    
      if (this.matches[index][e])
        return
    
      if (this.paused) {
        this._emitQueue.push([index, e])
        return
      }
    
      var abs = this._makeAbs(e)
    
      if (this.nodir) {
        var c = this.cache[abs]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      if (this.mark)
        e = this._mark(e)
    
      this.matches[index][e] = true
    
      var st = this.statCache[abs]
      if (st)
        this.emit('stat', e, st)
    
      this.emit('match', e)
    }
    
    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return
    
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)
    
      var lstatkey = 'lstat\0' + abs
      var self = this
      var lstatcb = inflight(lstatkey, lstatcb_)
    
      if (lstatcb)
        fs.lstat(abs, lstatcb)
    
      function lstatcb_ (er, lstat) {
        if (er)
          return cb()
    
        var isSym = lstat.isSymbolicLink()
        self.symlinks[abs] = isSym
    
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE'
          cb()
        } else
          self._readdir(abs, false, cb)
      }
    }
    
    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return
    
      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
      if (!cb)
        return
    
      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return cb()
    
        if (Array.isArray(c))
          return cb(null, c)
      }
    
      var self = this
      fs.readdir(abs, readdirCb(this, abs, cb))
    }
    
    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb)
        else
          self._readdirEntries(abs, entries, cb)
      }
    }
    
    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return
    
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
      return cb(null, entries)
    }
    
    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return
    
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict) {
            this.emit('error', er)
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort()
          }
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    
      return cb()
    }
    
    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    
    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb)
    
      var isSym = this.symlinks[abs]
      var len = entries.length
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true, cb)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true, cb)
      }
    
      cb()
    }
    
    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb)
      })
    }
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    
      //console.error('ps2', prefix, exists)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this._emitMatch(index, prefix)
      cb()
    }
    
    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return cb()
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)
    
        if (needDir && c === 'FILE')
          return cb()
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE'
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }
    
      var self = this
      var statcb = inflight('stat\0' + abs, lstatcb_)
      if (statcb)
        fs.lstat(abs, statcb)
    
      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb)
            else
              self._stat2(f, abs, er, stat, cb)
          })
        } else {
          self._stat2(f, abs, er, lstat, cb)
        }
      }
    }
    
    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false
        return cb()
      }
    
      var needDir = f.slice(-1) === '/'
      this.statCache[abs] = stat
    
      if (abs.slice(-1) === '/' && !stat.isDirectory())
        return cb(null, false, stat)
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return cb()
    
      return cb(null, c, stat)
    }
    
  provide("glob/glob.js", module.exports);
}(global));

// pakmanager:glob/sync.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = globSync
    globSync.GlobSync = GlobSync
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var Glob =  require('glob/glob.js').Glob
    var util = require('util')
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var childrenIgnored = common.childrenIgnored
    
    function globSync (pattern, options) {
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')
    
      return new GlobSync(pattern, options).found
    }
    
    function GlobSync (pattern, options) {
      if (!pattern)
        throw new Error('must provide pattern')
    
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')
    
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options)
    
      setopts(this, pattern, options)
    
      if (this.noprocess)
        return this
    
      var n = this.minimatch.set.length
      this.matches = new Array(n)
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false)
      }
      this._finish()
    }
    
    GlobSync.prototype._finish = function () {
      assert(this instanceof GlobSync)
      if (this.realpath) {
        var self = this
        this.matches.forEach(function (matchset, index) {
          var set = self.matches[index] = Object.create(null)
          for (var p in matchset) {
            try {
              p = self._makeAbs(p)
              var real = fs.realpathSync(p, this.realpathCache)
              set[real] = true
            } catch (er) {
              if (er.syscall === 'stat')
                set[self._makeAbs(p)] = true
              else
                throw er
            }
          }
        })
      }
      common.finish(this)
    }
    
    
    GlobSync.prototype._process = function (pattern, index, inGlobStar) {
      assert(this instanceof GlobSync)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // See if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip processing
      if (childrenIgnored(this, read))
        return
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
    }
    
    
    GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar)
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix.slice(-1) !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this.matches[index][e] = true
        }
        // This was the last one, and no stats were needed
        return
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix)
          newPattern = [prefix, e]
        else
          newPattern = [e]
        this._process(newPattern.concat(remain), index, inGlobStar)
      }
    }
    
    
    GlobSync.prototype._emitMatch = function (index, e) {
      var abs = this._makeAbs(e)
      if (this.mark)
        e = this._mark(e)
    
      if (this.matches[index][e])
        return
    
      if (this.nodir) {
        var c = this.cache[this._makeAbs(e)]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      this.matches[index][e] = true
      if (this.stat)
        this._stat(e)
    }
    
    
    GlobSync.prototype._readdirInGlobStar = function (abs) {
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false)
    
      var entries
      var lstat
      var stat
      try {
        lstat = fs.lstatSync(abs)
      } catch (er) {
        // lstat failed, doesn't exist
        return null
      }
    
      var isSym = lstat.isSymbolicLink()
      this.symlinks[abs] = isSym
    
      // If it's not a symlink or a dir, then it's definitely a regular file.
      // don't bother doing a readdir in that case.
      if (!isSym && !lstat.isDirectory())
        this.cache[abs] = 'FILE'
      else
        entries = this._readdir(abs, false)
    
      return entries
    }
    
    GlobSync.prototype._readdir = function (abs, inGlobStar) {
      var entries
    
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return null
    
        if (Array.isArray(c))
          return c
      }
    
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs))
      } catch (er) {
        this._readdirError(abs, er)
        return null
      }
    }
    
    GlobSync.prototype._readdirEntries = function (abs, entries) {
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
    
      // mark and cache dir-ness
      return entries
    }
    
    GlobSync.prototype._readdirError = function (f, er) {
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict)
            throw er
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    }
    
    GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
    
      var entries = this._readdir(abs, inGlobStar)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false)
    
      var len = entries.length
      var isSym = this.symlinks[abs]
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true)
      }
    }
    
    GlobSync.prototype._processSimple = function (prefix, index) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var exists = this._stat(prefix)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this.matches[index][prefix] = true
    }
    
    // Returns either 'DIR', 'FILE', or false
    GlobSync.prototype._stat = function (f) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return false
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return c
    
        if (needDir && c === 'FILE')
          return false
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (!stat) {
        var lstat
        try {
          lstat = fs.lstatSync(abs)
        } catch (er) {
          return false
        }
    
        if (lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs)
          } catch (er) {
            stat = lstat
          }
        } else {
          stat = lstat
        }
      }
    
      this.statCache[abs] = stat
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return false
    
      return c
    }
    
    GlobSync.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    GlobSync.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
  provide("glob/sync.js", module.exports);
}(global));

// pakmanager:glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    module.exports = glob
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var inherits = require('inherits')
    var EE = require('events').EventEmitter
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var globSync =  require('glob/sync.js')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var inflight = require('inflight')
    var util = require('util')
    var childrenIgnored = common.childrenIgnored
    
    var once = require('once')
    
    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {}
      if (!options) options = {}
    
      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }
    
      return new Glob(pattern, options, cb)
    }
    
    glob.sync = globSync
    var GlobSync = glob.GlobSync = globSync.GlobSync
    
    // old api surface
    glob.glob = glob
    
    glob.hasMagic = function (pattern, options_) {
      var options = util._extend({}, options_)
      options.noprocess = true
    
      var g = new Glob(pattern, options)
      var set = g.minimatch.set
      if (set.length > 1)
        return true
    
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }
    
      return false
    }
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
    
      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }
    
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)
    
      setopts(this, pattern, options)
      this._didRealPath = false
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (typeof cb === 'function') {
        cb = once(cb)
        this.on('error', cb)
        this.on('end', function (matches) {
          cb(null, matches)
        })
      }
    
      var self = this
      var n = this.minimatch.set.length
      this._processing = 0
      this.matches = new Array(n)
    
      this._emitQueue = []
      this._processQueue = []
      this.paused = false
    
      if (this.noprocess)
        return this
    
      if (n === 0)
        return done()
    
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done)
      }
    
      function done () {
        --self._processing
        if (self._processing <= 0)
          self._finish()
      }
    }
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
      if (this.aborted)
        return
    
      if (this.realpath && !this._didRealpath)
        return this._realpath()
    
      common.finish(this)
      this.emit('end', this.found)
    }
    
    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return
    
      this._didRealpath = true
    
      var n = this.matches.length
      if (n === 0)
        return this._finish()
    
      var self = this
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next)
    
      function next () {
        if (--n === 0)
          self._finish()
      }
    }
    
    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index]
      if (!matchset)
        return cb()
    
      var found = Object.keys(matchset)
      var self = this
      var n = found.length
    
      if (n === 0)
        return cb()
    
      var set = this.matches[index] = Object.create(null)
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p)
        fs.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true
          else if (er.syscall === 'stat')
            set[p] = true
          else
            self.emit('error', er) // srsly wtf right here
    
          if (--n === 0) {
            self.matches[index] = set
            cb()
          }
        })
      })
    }
    
    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit('abort')
    }
    
    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true
        this.emit('pause')
      }
    }
    
    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume')
        this.paused = false
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0)
          this._emitQueue.length = 0
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i]
            this._emitMatch(e[0], e[1])
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0)
          this._processQueue.length = 0
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i]
            this._processing--
            this._process(p[0], p[1], p[2], p[3])
          }
        }
      }
    }
    
    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob)
      assert(typeof cb === 'function')
    
      if (this.aborted)
        return
    
      this._processing++
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb])
        return
      }
    
      //console.error('PROCESS %d', this._processing, pattern)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
    }
    
    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this._emitMatch(index, e)
        }
        // This was the last one, and no stats were needed
        return cb()
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }
        this._process([e].concat(remain), index, inGlobStar, cb)
      }
      cb()
    }
    
    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return
    
      if (this.matches[index][e])
        return
    
      if (this.paused) {
        this._emitQueue.push([index, e])
        return
      }
    
      var abs = this._makeAbs(e)
    
      if (this.nodir) {
        var c = this.cache[abs]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      if (this.mark)
        e = this._mark(e)
    
      this.matches[index][e] = true
    
      var st = this.statCache[abs]
      if (st)
        this.emit('stat', e, st)
    
      this.emit('match', e)
    }
    
    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return
    
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)
    
      var lstatkey = 'lstat\0' + abs
      var self = this
      var lstatcb = inflight(lstatkey, lstatcb_)
    
      if (lstatcb)
        fs.lstat(abs, lstatcb)
    
      function lstatcb_ (er, lstat) {
        if (er)
          return cb()
    
        var isSym = lstat.isSymbolicLink()
        self.symlinks[abs] = isSym
    
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE'
          cb()
        } else
          self._readdir(abs, false, cb)
      }
    }
    
    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return
    
      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
      if (!cb)
        return
    
      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return cb()
    
        if (Array.isArray(c))
          return cb(null, c)
      }
    
      var self = this
      fs.readdir(abs, readdirCb(this, abs, cb))
    }
    
    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb)
        else
          self._readdirEntries(abs, entries, cb)
      }
    }
    
    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return
    
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
      return cb(null, entries)
    }
    
    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return
    
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTDIR': // totally normal. means it *does* exist.
          this.cache[this._makeAbs(f)] = 'FILE'
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict) {
            this.emit('error', er)
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort()
          }
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    
      return cb()
    }
    
    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    
    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb)
    
      var isSym = this.symlinks[abs]
      var len = entries.length
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true, cb)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true, cb)
      }
    
      cb()
    }
    
    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb)
      })
    }
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    
      //console.error('ps2', prefix, exists)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this._emitMatch(index, prefix)
      cb()
    }
    
    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return cb()
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)
    
        if (needDir && c === 'FILE')
          return cb()
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE'
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }
    
      var self = this
      var statcb = inflight('stat\0' + abs, lstatcb_)
      if (statcb)
        fs.lstat(abs, statcb)
    
      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb)
            else
              self._stat2(f, abs, er, stat, cb)
          })
        } else {
          self._stat2(f, abs, er, lstat, cb)
        }
      }
    }
    
    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false
        return cb()
      }
    
      var needDir = f.slice(-1) === '/'
      this.statCache[abs] = stat
    
      if (abs.slice(-1) === '/' && !stat.isDirectory())
        return cb(null, false, stat)
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return cb()
    
      return cb(null, c, stat)
    }
    
  provide("glob", module.exports);
}(global));

// pakmanager:resolve/lib/core
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('./core.json').reduce(function (acc, x) {
        acc[x] = true;
        return acc;
    }, {});
    
  provide("resolve/lib/core", module.exports);
}(global));

// pakmanager:resolve/lib/caller.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function () {
        // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
        var origPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = function (_, stack) { return stack };
        var stack = (new Error()).stack;
        Error.prepareStackTrace = origPrepareStackTrace;
        return stack[2].getFileName();
    };
    
  provide("resolve/lib/caller.js", module.exports);
}(global));

// pakmanager:resolve/lib/node-modules-paths.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    
    module.exports = function (start, opts) {
        var modules = opts.moduleDirectory
            ? [].concat(opts.moduleDirectory)
            : ['node_modules']
        ;
        var prefix = '/';
        if (/^([A-Za-z]:)/.test(start)) {
            prefix = '';
        } else if (/^\\\\/.test(start)) {
            prefix = '\\\\';
        }
        var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\/+/;
    
        // ensure that `start` is an absolute path at this point,
        // resolving againt the process' current working directory
        start = path.resolve(start);
    
        var parts = start.split(splitRe);
    
        var dirs = [];
        for (var i = parts.length - 1; i >= 0; i--) {
            if (modules.indexOf(parts[i]) !== -1) continue;
            dirs = dirs.concat(modules.map(function(module_dir) {
                return prefix + path.join(
                    path.join.apply(path, parts.slice(0, i + 1)),
                    module_dir
                );
            }));
        }
        if (process.platform === 'win32'){
            dirs[dirs.length-1] = dirs[dirs.length-1].replace(":", ":\\");
        }
        return dirs.concat(opts.paths);
    }
    
  provide("resolve/lib/node-modules-paths.js", module.exports);
}(global));

// pakmanager:resolve/lib/async
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var core =  require('resolve/lib/core');
    var fs = require('fs');
    var path = require('path');
    var caller =  require('resolve/lib/caller.js');
    var nodeModulesPaths =  require('resolve/lib/node-modules-paths.js');
    var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\//;
    
    module.exports = function resolve (x, opts, cb) {
        if (typeof opts === 'function') {
            cb = opts;
            opts = {};
        }
        if (!opts) opts = {};
        if (typeof x !== 'string') {
            return process.nextTick(function () {
                cb(new Error('path must be a string'));
            });
        }
        
        var isFile = opts.isFile || function (file, cb) {
            fs.stat(file, function (err, stat) {
                if (err && err.code === 'ENOENT') cb(null, false)
                else if (err) cb(err)
                else cb(null, stat.isFile() || stat.isFIFO())
            });
        };
        var readFile = opts.readFile || fs.readFile;
        
        var extensions = opts.extensions || [ '.js' ];
        var y = opts.basedir || path.dirname(caller());
        
        opts.paths = opts.paths || [];
        
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[\\\/])/.test(x)) {
            var res = path.resolve(y, x);
            if (x === '..') res += '/';
            if (/\/$/.test(x) && res === y) {
                loadAsDirectory(res, opts.package, onfile);
            }
            else loadAsFile(res, opts.package, onfile);
        }
        else loadNodeModules(x, y, function (err, n, pkg) {
            if (err) cb(err)
            else if (n) cb(null, n, pkg)
            else if (core[x]) return cb(null, x);
            else cb(new Error("Cannot find module '" + x + "' from '" + y + "'"))
        });
        
        function onfile (err, m, pkg) {
            if (err) cb(err)
            else if (m) cb(null, m, pkg)
            else loadAsDirectory(res, function (err, d, pkg) {
                if (err) cb(err)
                else if (d) cb(null, d, pkg)
                else cb(new Error("Cannot find module '" + x + "' from '" + y + "'"))
            })
        }
        
        function loadAsFile (x, pkg, cb) {
            if (typeof pkg === 'function') {
                cb = pkg;
                pkg = undefined;
            }
            
            var exts = [''].concat(extensions);
            load(exts, x, pkg)
    		
    		function load (exts, x, pkg) {
                if (exts.length === 0) return cb(null, undefined, pkg);
                var file = x + exts[0];
                
                if (pkg) onpkg(null, pkg)
                else loadpkg(path.dirname(file), onpkg);
                
                function onpkg (err, pkg_, dir) {
                    pkg = pkg_;
                    if (err) return cb(err)
                    if (dir && pkg && opts.pathFilter) {
                        var rfile = path.relative(dir, file);
                        var rel = rfile.slice(0, rfile.length - exts[0].length);
                        var r = opts.pathFilter(pkg, x, rel);
                        if (r) return load(
                            [''].concat(extensions.slice()),
                            path.resolve(dir, r),
                            pkg
                        );
                    }
                    isFile(file, onex);
                }
                function onex (err, ex) {
                    if (err) cb(err)
                    else if (!ex) load(exts.slice(1), x, pkg)
                    else cb(null, file, pkg)
                }
            }
        }
        
        function loadpkg (dir, cb) {
            if (dir === '' || dir === '/') return cb(null);
            if (process.platform === 'win32' && /^\w:[\\\/]*$/.test(dir)) {
                return cb(null);
            }
            if (/[\\\/]node_modules[\\\/]*$/.test(dir)) return cb(null);
            
            var pkgfile = path.join(dir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(
                    path.dirname(dir), cb
                );
                
                readFile(pkgfile, function (err, body) {
                    if (err) cb(err);
                    try { var pkg = JSON.parse(body) }
                    catch (err) {}
                    
                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        }
        
        function loadAsDirectory (x, fpkg, cb) {
            if (typeof fpkg === 'function') {
                cb = fpkg;
                fpkg = opts.package;
            }
            
            var pkgfile = path.join(x, '/package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, '/index'), fpkg, cb);
                
                readFile(pkgfile, function (err, body) {
                    if (err) return cb(err);
                    try {
                        var pkg = JSON.parse(body);
                    }
                    catch (err) {}
                    
                    if (opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    
                    if (pkg.main) {
                        if (pkg.main === '.' || pkg.main === './'){
                            pkg.main = 'index'
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, '/index'), pkg, cb);
    
                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, '/index'), pkg, cb);
                            });
                        });
                        return;
                    }
                    
                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        }
        
        function loadNodeModules (x, start, cb) {
            (function process (dirs) {
                if (dirs.length === 0) return cb(null, undefined);
                var dir = dirs[0];
                
                var file = path.join(dir, '/', x);
                loadAsFile(file, undefined, onfile);
                
                function onfile (err, m, pkg) {
                    if (err) return cb(err);
                    if (m) return cb(null, m, pkg);
                    loadAsDirectory(path.join(dir, '/', x), undefined, ondir);
                }
                
                function ondir (err, n, pkg) {
                    if (err) return cb(err);
                    if (n) return cb(null, n, pkg);
                    process(dirs.slice(1));
                }
            })(nodeModulesPaths(start, opts));
        }
    };
    
  provide("resolve/lib/async", module.exports);
}(global));

// pakmanager:resolve/lib/sync
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var core =  require('resolve/lib/core');
    var fs = require('fs');
    var path = require('path');
    var caller =  require('resolve/lib/caller.js');
    var nodeModulesPaths =  require('resolve/lib/node-modules-paths.js');
    
    module.exports = function (x, opts) {
        if (!opts) opts = {};
        var isFile = opts.isFile || function (file) {
            try { var stat = fs.statSync(file) }
            catch (err) { if (err && err.code === 'ENOENT') return false }
            return stat.isFile() || stat.isFIFO();
        };
        var readFileSync = opts.readFileSync || fs.readFileSync;
        
        var extensions = opts.extensions || [ '.js' ];
        var y = opts.basedir || path.dirname(caller());
    
        opts.paths = opts.paths || [];
    
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[\\\/])/.test(x)) {
            var res = path.resolve(y, x);
            if (x === '..') res += '/';
            var m = loadAsFileSync(res) || loadAsDirectorySync(res);
            if (m) return m;
        } else {
            var n = loadNodeModulesSync(x, y);
            if (n) return n;
        }
        
        if (core[x]) return x;
        
        throw new Error("Cannot find module '" + x + "' from '" + y + "'");
        
        function loadAsFileSync (x) {
            if (isFile(x)) {
                return x;
            }
            
            for (var i = 0; i < extensions.length; i++) {
                var file = x + extensions[i];
                if (isFile(file)) {
                    return file;
                }
            }
        }
        
        function loadAsDirectorySync (x) {
            var pkgfile = path.join(x, '/package.json');
            if (isFile(pkgfile)) {
                var body = readFileSync(pkgfile, 'utf8');
                try {
                    var pkg = JSON.parse(body);
                    if (opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, x);
                    }
                    
                    if (pkg.main) {
                        var m = loadAsFileSync(path.resolve(x, pkg.main));
                        if (m) return m;
                        var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                        if (n) return n;
                    }
                }
                catch (err) {}
            }
            
            return loadAsFileSync(path.join( x, '/index'));
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPaths(start, opts);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(path.join( dir, '/', x));
                if (m) return m;
                var n = loadAsDirectorySync(path.join( dir, '/', x ));
                if (n) return n;
            }
        }
    };
    
  provide("resolve/lib/sync", module.exports);
}(global));

// pakmanager:resolve
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var core =  require('resolve/lib/core');
    exports = module.exports =  require('resolve/lib/async');
    exports.core = core;
    exports.isCore = function (x) { return core[x] };
    exports.sync =  require('resolve/lib/sync');
    
  provide("resolve", module.exports);
}(global));

// pakmanager:ms
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
      options = options || {};
      if ('string' == typeof val) return parse(val);
      return options.long
        ? long(val)
        : short(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
      str = '' + str;
      if (str.length > 10000) return;
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
      }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function short(ms) {
      if (ms >= d) return Math.round(ms / d) + 'd';
      if (ms >= h) return Math.round(ms / h) + 'h';
      if (ms >= m) return Math.round(ms / m) + 'm';
      if (ms >= s) return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function long(ms) {
      return plural(ms, d, 'day')
        || plural(ms, h, 'hour')
        || plural(ms, m, 'minute')
        || plural(ms, s, 'second')
        || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
  provide("ms", module.exports);
}(global));

// pakmanager:ansi-styles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var styles = module.exports = {
    	modifiers: {
    		reset: [0, 0],
    		bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
    		dim: [2, 22],
    		italic: [3, 23],
    		underline: [4, 24],
    		inverse: [7, 27],
    		hidden: [8, 28],
    		strikethrough: [9, 29]
    	},
    	colors: {
    		black: [30, 39],
    		red: [31, 39],
    		green: [32, 39],
    		yellow: [33, 39],
    		blue: [34, 39],
    		magenta: [35, 39],
    		cyan: [36, 39],
    		white: [37, 39],
    		gray: [90, 39]
    	},
    	bgColors: {
    		bgBlack: [40, 49],
    		bgRed: [41, 49],
    		bgGreen: [42, 49],
    		bgYellow: [43, 49],
    		bgBlue: [44, 49],
    		bgMagenta: [45, 49],
    		bgCyan: [46, 49],
    		bgWhite: [47, 49]
    	}
    };
    
    // fix humans
    styles.colors.grey = styles.colors.gray;
    
    Object.keys(styles).forEach(function (groupName) {
    	var group = styles[groupName];
    
    	Object.keys(group).forEach(function (styleName) {
    		var style = group[styleName];
    
    		styles[styleName] = group[styleName] = {
    			open: '\u001b[' + style[0] + 'm',
    			close: '\u001b[' + style[1] + 'm'
    		};
    	});
    
    	Object.defineProperty(styles, groupName, {
    		value: group,
    		enumerable: false
    	});
    });
    
  provide("ansi-styles", module.exports);
}(global));

// pakmanager:escape-string-regexp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(matchOperatorsRe,  '\\$&');
    };
    
  provide("escape-string-regexp", module.exports);
}(global));

// pakmanager:has-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex');
    var re = new RegExp(ansiRegex().source); // remove the `g` flag
    module.exports = re.test.bind(re);
    
  provide("has-ansi", module.exports);
}(global));

// pakmanager:strip-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex')();
    
    module.exports = function (str) {
    	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
    };
    
  provide("strip-ansi", module.exports);
}(global));

// pakmanager:supports-color
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var argv = process.argv;
    
    module.exports = (function () {
    	if ('FORCE_COLOR' in process.env) {
    		return true;
    	}
    
    	if (argv.indexOf('--no-color') !== -1 ||
    		argv.indexOf('--no-colors') !== -1 ||
    		argv.indexOf('--color=false') !== -1) {
    		return false;
    	}
    
    	if (argv.indexOf('--color') !== -1 ||
    		argv.indexOf('--colors') !== -1 ||
    		argv.indexOf('--color=true') !== -1 ||
    		argv.indexOf('--color=always') !== -1) {
    		return true;
    	}
    
    	if (process.stdout && !process.stdout.isTTY) {
    		return false;
    	}
    
    	if (process.platform === 'win32') {
    		return true;
    	}
    
    	if ('COLORTERM' in process.env) {
    		return true;
    	}
    
    	if (process.env.TERM === 'dumb') {
    		return false;
    	}
    
    	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    		return true;
    	}
    
    	return false;
    })();
    
  provide("supports-color", module.exports);
}(global));

// pakmanager:graceful-readlink
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
      , lstat = fs.lstatSync;
    
    exports.readlinkSync = function (p) {
      if (lstat(p).isSymbolicLink()) {
        return fs.readlinkSync(p);
      } else {
        return p;
      }
    };
    
    
    
  provide("graceful-readlink", module.exports);
}(global));

// pakmanager:extend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var undefined;
    
    var isArray = function isArray(arr) {
    	if (typeof Array.isArray === 'function') {
    		return Array.isArray(arr);
    	}
    
    	return toStr.call(arr) === '[object Array]';
    };
    
    var isPlainObject = function isPlainObject(obj) {
    	'use strict';
    	if (!obj || toStr.call(obj) !== '[object Object]') {
    		return false;
    	}
    
    	var has_own_constructor = hasOwn.call(obj, 'constructor');
    	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    	// Not own constructor property must be Object
    	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
    		return false;
    	}
    
    	// Own properties are enumerated firstly, so to speed up,
    	// if last one is own, then all properties are own.
    	var key;
    	for (key in obj) {}
    
    	return key === undefined || hasOwn.call(obj, key);
    };
    
    module.exports = function extend() {
    	'use strict';
    	var options, name, src, copy, copyIsArray, clone,
    		target = arguments[0],
    		i = 1,
    		length = arguments.length,
    		deep = false;
    
    	// Handle a deep copy situation
    	if (typeof target === 'boolean') {
    		deep = target;
    		target = arguments[1] || {};
    		// skip the boolean and the target
    		i = 2;
    	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
    		target = {};
    	}
    
    	for (; i < length; ++i) {
    		options = arguments[i];
    		// Only deal with non-null/undefined values
    		if (options != null) {
    			// Extend the base object
    			for (name in options) {
    				src = target[name];
    				copy = options[name];
    
    				// Prevent never-ending loop
    				if (target === copy) {
    					continue;
    				}
    
    				// Recurse if we're merging plain objects or arrays
    				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
    					if (copyIsArray) {
    						copyIsArray = false;
    						clone = src && isArray(src) ? src : [];
    					} else {
    						clone = src && isPlainObject(src) ? src : {};
    					}
    
    					// Never move original objects, clone them
    					target[name] = extend(deep, clone, copy);
    
    				// Don't bring in undefined values
    				} else if (copy !== undefined) {
    					target[name] = copy;
    				}
    			}
    		}
    	}
    
    	// Return the modified object
    	return target;
    };
    
    
  provide("extend", module.exports);
}(global));

// pakmanager:findup-sync
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * findup-sync
     * https://github.com/cowboy/node-findup-sync
     *
     * Copyright (c) 2013 "Cowboy" Ben Alman
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    // Nodejs libs.
    var path = require('path');
    
    // External libs.
    var glob = require('glob');
    
    // Search for a filename in the given directory or all parent directories.
    module.exports = function(patterns, options) {
      // Normalize patterns to an array.
      if (!Array.isArray(patterns)) { patterns = [patterns]; }
      // Create globOptions so that it can be modified without mutating the
      // original object.
      var globOptions = Object.create(options || {});
      globOptions.maxDepth = 1;
      globOptions.cwd = path.resolve(globOptions.cwd || '.');
    
      var files, lastpath;
      do {
        // Search for files matching patterns.
        files = patterns.map(function(pattern) {
          return glob.sync(pattern, globOptions);
        }).reduce(function(a, b) {
          return a.concat(b);
        }).filter(function(entry, index, arr) {
          return index === arr.indexOf(entry);
        });
        // Return file if found.
        if (files.length > 0) {
          return path.resolve(path.join(globOptions.cwd, files[0]));
        }
        // Go up a directory.
        lastpath = globOptions.cwd;
        globOptions.cwd = path.resolve(globOptions.cwd, '..');
      // If parentpath is the same as basedir, we can't go any higher.
      } while (globOptions.cwd !== lastpath);
    
      // No files were found!
      return null;
    };
    
  provide("findup-sync", module.exports);
}(global));

// pakmanager:flagged-respawn/lib/reorder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (flags, argv) {
      if (!argv) {
        argv = process.argv;
      }
      var args = [argv[1]];
      argv.slice(2).forEach(function (arg) {
        var flag = arg.split('=')[0];
        if (flags.indexOf(flag) !== -1) {
          args.unshift(flag);
        } else {
          args.push(arg);
        }
      });
      args.unshift(argv[0]);
      return args;
    };
    
  provide("flagged-respawn/lib/reorder", module.exports);
}(global));

// pakmanager:flagged-respawn/lib/respawn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const spawn = require('child_process').spawn;
    
    module.exports = function (argv) {
      var child = spawn(argv[0], argv.slice(1), { stdio: 'inherit' });
      child.on('exit', function (code, signal) {
        process.on('exit', function () {
          if (signal) {
            process.kill(process.pid, signal);
          } else {
            process.exit(code);
          }
        });
      });
      return child;
    };
    
  provide("flagged-respawn/lib/respawn", module.exports);
}(global));

// pakmanager:flagged-respawn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const reorder =  require('flagged-respawn/lib/reorder');
    const respawn =  require('flagged-respawn/lib/respawn');
    
    module.exports = function (flags, argv, execute) {
      if (!flags) {
        throw new Error('You must specify flags to respawn with.');
      }
      if (!argv) {
        throw new Error('You must specify an argv array.');
      }
      var proc = process;
      var reordered = reorder(flags, argv);
      var ready = JSON.stringify(argv) === JSON.stringify(reordered);
      if (!ready) {
        proc = respawn(reordered);
      }
      execute(ready, proc);
    };
    
  provide("flagged-respawn", module.exports);
}(global));

// pakmanager:rechoir/lib/extension
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const path = require('path');
    
    const EXTRE = /^[.]?[^.]+([.].*)$/;
    
    module.exports = function (input) {
      var extension = EXTRE.exec(path.basename(input));
      if (!extension) {
        return;
      }
      return extension[1];
    };
    
  provide("rechoir/lib/extension", module.exports);
}(global));

// pakmanager:rechoir/lib/normalize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  function normalizer (config) {
      if (typeof config === 'string') {
        return {
          module: config
        }
      }
      return config;
    };
    
    module.exports = function (config) {
      if (Array.isArray(config)) {
        return config.map(normalizer);
      }
      return normalizer(config);
    };
    
  provide("rechoir/lib/normalize", module.exports);
}(global));

// pakmanager:rechoir/lib/register
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const path = require('path');
    const resolve = require('resolve');
    
    module.exports = function (cwd, moduleName, register) {
      try {
        var modulePath = resolve.sync(moduleName, {basedir: cwd});
        var result = require(modulePath);
        if (typeof register === 'function') {
          register(result);
        }
      } catch (e) {
        result = e;
      }
      return result;
    };
    
  provide("rechoir/lib/register", module.exports);
}(global));

// pakmanager:rechoir
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const path = require('path');
    
    const extension =  require('rechoir/lib/extension');
    const normalize =  require('rechoir/lib/normalize');
    const register =  require('rechoir/lib/register');
    
    exports.prepare = function (extensions, filepath, cwd, nothrow) {
      var option, attempt;
      var attempts = [];
      var err;
      var onlyErrors = false;
      var ext = extension(filepath);
      if (Object.keys(require.extensions).indexOf(ext) !== -1) {
        return true;
      }
      var config = normalize(extensions[ext]);
      if (!config) {
        throw new Error('No module loader found for "'+ext+'".');
      }
      if (!cwd) {
        cwd = path.dirname(path.resolve(filepath));
      }
      if (!Array.isArray(config)) {
        config = [config];
      }
      for (var i in config) {
        option = config[i];
        attempt = register(cwd, option.module, option.register);
        error = (attempt instanceof Error) ? attempt : null;
        if (error) {
          attempt = null;
        }
        attempts.push({
          moduleName: option.module,
          module: attempt,
          error: error
        });
        if (!error) {
          onlyErrors = false;
          break;
        } else {
          onlyErrors = true;
        }
      }
      if (onlyErrors) {
        err = new Error('Unable to use specified module loaders for "'+ext+'".');
        err.failures = attempts;
        if (nothrow) {
          return err;
        } else {
          throw err;
        }
      }
      return attempts;
    };
    
  provide("rechoir", module.exports);
}(global));

// pakmanager:minimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (args, opts) {
        if (!opts) opts = {};
        
        var flags = { bools : {}, strings : {}, unknownFn: null };
    
        if (typeof opts['unknown'] === 'function') {
            flags.unknownFn = opts['unknown'];
        }
    
        if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
          flags.allBools = true;
        } else {
          [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
              flags.bools[key] = true;
          });
        }
        
        var aliases = {};
        Object.keys(opts.alias || {}).forEach(function (key) {
            aliases[key] = [].concat(opts.alias[key]);
            aliases[key].forEach(function (x) {
                aliases[x] = [key].concat(aliases[key].filter(function (y) {
                    return x !== y;
                }));
            });
        });
    
        [].concat(opts.string).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            if (aliases[key]) {
                flags.strings[aliases[key]] = true;
            }
         });
    
        var defaults = opts['default'] || {};
        
        var argv = { _ : [] };
        Object.keys(flags.bools).forEach(function (key) {
            setArg(key, defaults[key] === undefined ? false : defaults[key]);
        });
        
        var notFlags = [];
    
        if (args.indexOf('--') !== -1) {
            notFlags = args.slice(args.indexOf('--')+1);
            args = args.slice(0, args.indexOf('--'));
        }
    
        function argDefined(key, arg) {
            return (flags.allBools && /^--[^=]+$/.test(arg)) ||
                flags.strings[key] || flags.bools[key] || aliases[key];
        }
    
        function setArg (key, val, arg) {
            if (arg && flags.unknownFn && !argDefined(key, arg)) {
                if (flags.unknownFn(arg) === false) return;
            }
    
            var value = !flags.strings[key] && isNumber(val)
                ? Number(val) : val
            ;
            setKey(argv, key.split('.'), value);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), value);
            });
        }
    
        function setKey (obj, keys, value) {
            var o = obj;
            keys.slice(0,-1).forEach(function (key) {
                if (o[key] === undefined) o[key] = {};
                o = o[key];
            });
    
            var key = keys[keys.length - 1];
            if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
                o[key] = value;
            }
            else if (Array.isArray(o[key])) {
                o[key].push(value);
            }
            else {
                o[key] = [ o[key], value ];
            }
        }
        
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            
            if (/^--.+=/.test(arg)) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
                setArg(m[1], m[2], arg);
            }
            else if (/^--no-.+/.test(arg)) {
                var key = arg.match(/^--no-(.+)/)[1];
                setArg(key, false, arg);
            }
            else if (/^--.+/.test(arg)) {
                var key = arg.match(/^--(.+)/)[1];
                var next = args[i + 1];
                if (next !== undefined && !/^-/.test(next)
                && !flags.bools[key]
                && !flags.allBools
                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                    setArg(key, next, arg);
                    i++;
                }
                else if (/^(true|false)$/.test(next)) {
                    setArg(key, next === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
            else if (/^-[^-]+/.test(arg)) {
                var letters = arg.slice(1,-1).split('');
                
                var broken = false;
                for (var j = 0; j < letters.length; j++) {
                    var next = arg.slice(j+2);
                    
                    if (next === '-') {
                        setArg(letters[j], next, arg)
                        continue;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j])
                    && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                        setArg(letters[j], next, arg);
                        broken = true;
                        break;
                    }
                    
                    if (letters[j+1] && letters[j+1].match(/\W/)) {
                        setArg(letters[j], arg.slice(j+2), arg);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                    }
                }
                
                var key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                    && !flags.bools[key]
                    && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                        setArg(key, args[i+1], arg);
                        i++;
                    }
                    else if (args[i+1] && /true|false/.test(args[i+1])) {
                        setArg(key, args[i+1] === 'true', arg);
                        i++;
                    }
                    else {
                        setArg(key, flags.strings[key] ? '' : true, arg);
                    }
                }
            }
            else {
                if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                    argv._.push(
                        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                    );
                }
                if (opts.stopEarly) {
                    argv._.push.apply(argv._, args.slice(i + 1));
                    break;
                }
            }
        }
        
        Object.keys(defaults).forEach(function (key) {
            if (!hasKey(argv, key.split('.'))) {
                setKey(argv, key.split('.'), defaults[key]);
                
                (aliases[key] || []).forEach(function (x) {
                    setKey(argv, x.split('.'), defaults[key]);
                });
            }
        });
        
        if (opts['--']) {
            argv['--'] = new Array();
            notFlags.forEach(function(key) {
                argv['--'].push(key);
            });
        }
        else {
            notFlags.forEach(function(key) {
                argv._.push(key);
            });
        }
    
        return argv;
    };
    
    function hasKey (obj, keys) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            o = (o[key] || {});
        });
    
        var key = keys[keys.length - 1];
        return key in o;
    }
    
    function isNumber (x) {
        if (typeof x === 'number') return true;
        if (/^0x[0-9a-f]+$/i.test(x)) return true;
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    
    
  provide("minimist", module.exports);
}(global));

// pakmanager:debug
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var tty = require('tty');
    var util = require('util');
    
    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports =   require('debug');
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    
    /**
     * Colors.
     */
    
    exports.colors = [6, 2, 3, 4, 5, 1];
    
    /**
     * The file descriptor to write the `debug()` calls to.
     * Set the `DEBUG_FD` env variable to override with another value. i.e.:
     *
     *   $ DEBUG_FD=3 node script.js 3>debug.log
     */
    
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    var stream = 1 === fd ? process.stdout :
                 2 === fd ? process.stderr :
                 createWritableStdioStream(fd);
    
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */
    
    function useColors() {
      var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
      if (0 === debugColors.length) {
        return tty.isatty(fd);
      } else {
        return '0' !== debugColors
            && 'no' !== debugColors
            && 'false' !== debugColors
            && 'disabled' !== debugColors;
      }
    }
    
    /**
     * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
     */
    
    var inspect = (4 === util.inspect.length ?
      // node <= 0.8.x
      function (v, colors) {
        return util.inspect(v, void 0, void 0, colors);
      } :
      // node > 0.8.x
      function (v, colors) {
        return util.inspect(v, { colors: colors });
      }
    );
    
    exports.formatters.o = function(v) {
      return inspect(v, this.useColors)
        .replace(/\s*\n\s*/g, ' ');
    };
    
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */
    
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      var name = this.namespace;
    
      if (useColors) {
        var c = this.color;
    
        args[0] = '  \u001b[3' + c + ';1m' + name + ' '
          + '\u001b[0m'
          + args[0] + '\u001b[3' + c + 'm'
          + ' +' + exports.humanize(this.diff) + '\u001b[0m';
      } else {
        args[0] = new Date().toUTCString()
          + ' ' + name + ' ' + args[0];
      }
      return args;
    }
    
    /**
     * Invokes `console.error()` with the specified arguments.
     */
    
    function log() {
      return stream.write(util.format.apply(this, arguments) + '\n');
    }
    
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    
    function save(namespaces) {
      if (null == namespaces) {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    
    function load() {
      return process.env.DEBUG;
    }
    
    /**
     * Copied from `node/src/node.js`.
     *
     * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
     * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
     */
    
    function createWritableStdioStream (fd) {
      var stream;
      var tty_wrap = process.binding('tty_wrap');
    
      // Note stream._type is used for test-module-load-list.js
    
      switch (tty_wrap.guessHandleType(fd)) {
        case 'TTY':
          stream = new tty.WriteStream(fd);
          stream._type = 'tty';
    
          // Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        case 'FILE':
          var fs = require('fs');
          stream = new fs.SyncWriteStream(fd, { autoClose: false });
          stream._type = 'fs';
          break;
    
        case 'PIPE':
        case 'TCP':
          var net = require('net');
          stream = new net.Socket({
            fd: fd,
            readable: false,
            writable: true
          });
    
          // FIXME Should probably have an option in net.Socket to create a
          // stream from an existing fd which is writable only. But for now
          // we'll just add this hack and set the `readable` member to false.
          // Test: ./node test/fixtures/echo.js < /etc/passwd
          stream.readable = false;
          stream.read = null;
          stream._type = 'pipe';
    
          // FIXME Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        default:
          // Probably an error on in uv_guess_handle()
          throw new Error('Implement me. Unknown stream file type!');
      }
    
      // For supporting legacy API we put the FD here.
      stream.fd = fd;
    
      stream._isStdio = true;
    
      return stream;
    }
    
    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */
    
    exports.enable(load());
    
  provide("debug", module.exports);
}(global));

// pakmanager:double-ended-queue
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright (c) 2013 Petka Antonov
     * 
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:</p>
     * 
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     * 
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    "use strict";
    function Deque(capacity) {
        this._capacity = getCapacity(capacity);
        this._length = 0;
        this._front = 0;
        if (isArray(capacity)) {
            var len = capacity.length;
            for (var i = 0; i < len; ++i) {
                this[i] = capacity[i];
            }
            this._length = len;
        }
    }
    
    Deque.prototype.toArray = function Deque$toArray() {
        var len = this._length;
        var ret = new Array(len);
        var front = this._front;
        var capacity = this._capacity;
        for (var j = 0; j < len; ++j) {
            ret[j] = this[(front + j) & (capacity - 1)];
        }
        return ret;
    };
    
    Deque.prototype.push = function Deque$push(item) {
        var argsLength = arguments.length;
        var length = this._length;
        if (argsLength > 1) {
            var capacity = this._capacity;
            if (length + argsLength > capacity) {
                for (var i = 0; i < argsLength; ++i) {
                    this._checkCapacity(length + 1);
                    var j = (this._front + length) & (this._capacity - 1);
                    this[j] = arguments[i];
                    length++;
                    this._length = length;
                }
                return length;
            }
            else {
                var j = this._front;
                for (var i = 0; i < argsLength; ++i) {
                    this[(j + length) & (capacity - 1)] = arguments[i];
                    j++;
                }
                this._length = length + argsLength;
                return length + argsLength;
            }
    
        }
    
        if (argsLength === 0) return length;
    
        this._checkCapacity(length + 1);
        var i = (this._front + length) & (this._capacity - 1);
        this[i] = item;
        this._length = length + 1;
        return length + 1;
    };
    
    Deque.prototype.pop = function Deque$pop() {
        var length = this._length;
        if (length === 0) {
            return void 0;
        }
        var i = (this._front + length - 1) & (this._capacity - 1);
        var ret = this[i];
        this[i] = void 0;
        this._length = length - 1;
        return ret;
    };
    
    Deque.prototype.shift = function Deque$shift() {
        var length = this._length;
        if (length === 0) {
            return void 0;
        }
        var front = this._front;
        var ret = this[front];
        this[front] = void 0;
        this._front = (front + 1) & (this._capacity - 1);
        this._length = length - 1;
        return ret;
    };
    
    Deque.prototype.unshift = function Deque$unshift(item) {
        var length = this._length;
        var argsLength = arguments.length;
    
    
        if (argsLength > 1) {
            var capacity = this._capacity;
            if (length + argsLength > capacity) {
                for (var i = argsLength - 1; i >= 0; i--) {
                    this._checkCapacity(length + 1);
                    var capacity = this._capacity;
                    var j = (((( this._front - 1 ) &
                        ( capacity - 1) ) ^ capacity ) - capacity );
                    this[j] = arguments[i];
                    length++;
                    this._length = length;
                    this._front = j;
                }
                return length;
            }
            else {
                var front = this._front;
                for (var i = argsLength - 1; i >= 0; i--) {
                    var j = (((( front - 1 ) &
                        ( capacity - 1) ) ^ capacity ) - capacity );
                    this[j] = arguments[i];
                    front = j;
                }
                this._front = front;
                this._length = length + argsLength;
                return length + argsLength;
            }
        }
    
        if (argsLength === 0) return length;
    
        this._checkCapacity(length + 1);
        var capacity = this._capacity;
        var i = (((( this._front - 1 ) &
            ( capacity - 1) ) ^ capacity ) - capacity );
        this[i] = item;
        this._length = length + 1;
        this._front = i;
        return length + 1;
    };
    
    Deque.prototype.peekBack = function Deque$peekBack() {
        var length = this._length;
        if (length === 0) {
            return void 0;
        }
        var index = (this._front + length - 1) & (this._capacity - 1);
        return this[index];
    };
    
    Deque.prototype.peekFront = function Deque$peekFront() {
        if (this._length === 0) {
            return void 0;
        }
        return this[this._front];
    };
    
    Deque.prototype.get = function Deque$get(index) {
        var i = index;
        if ((i !== (i | 0))) {
            return void 0;
        }
        var len = this._length;
        if (i < 0) {
            i = i + len;
        }
        if (i < 0 || i >= len) {
            return void 0;
        }
        return this[(this._front + i) & (this._capacity - 1)];
    };
    
    Deque.prototype.isEmpty = function Deque$isEmpty() {
        return this._length === 0;
    };
    
    Deque.prototype.clear = function Deque$clear() {
        var len = this._length;
        var front = this._front;
        var capacity = this._capacity;
        for (var j = 0; j < len; ++j) {
            this[(front + j) & (capacity - 1)] = void 0;
        }
        this._length = 0;
        this._front = 0;
    };
    
    Deque.prototype.toString = function Deque$toString() {
        return this.toArray().toString();
    };
    
    Deque.prototype.valueOf = Deque.prototype.toString;
    Deque.prototype.removeFront = Deque.prototype.shift;
    Deque.prototype.removeBack = Deque.prototype.pop;
    Deque.prototype.insertFront = Deque.prototype.unshift;
    Deque.prototype.insertBack = Deque.prototype.push;
    Deque.prototype.enqueue = Deque.prototype.push;
    Deque.prototype.dequeue = Deque.prototype.shift;
    Deque.prototype.toJSON = Deque.prototype.toArray;
    
    Object.defineProperty(Deque.prototype, "length", {
        get: function() {
            return this._length;
        },
        set: function() {
            throw new RangeError("");
        }
    });
    
    Deque.prototype._checkCapacity = function Deque$_checkCapacity(size) {
        if (this._capacity < size) {
            this._resizeTo(getCapacity(this._capacity * 1.5 + 16));
        }
    };
    
    Deque.prototype._resizeTo = function Deque$_resizeTo(capacity) {
        var oldCapacity = this._capacity;
        this._capacity = capacity;
        var front = this._front;
        var length = this._length;
        if (front + length > oldCapacity) {
            var moveItemsCount = (front + length) & (oldCapacity - 1);
            arrayMove(this, 0, this, oldCapacity, moveItemsCount);
        }
    };
    
    
    var isArray = Array.isArray;
    
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
        for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
        }
    }
    
    function pow2AtLeast(n) {
        n = n >>> 0;
        n = n - 1;
        n = n | (n >> 1);
        n = n | (n >> 2);
        n = n | (n >> 4);
        n = n | (n >> 8);
        n = n | (n >> 16);
        return n + 1;
    }
    
    function getCapacity(capacity) {
        if (typeof capacity !== "number") {
            if (isArray(capacity)) {
                capacity = capacity.length;
            }
            else {
                return 16;
            }
        }
        return pow2AtLeast(
            Math.min(
                Math.max(16, capacity), 1073741824)
        );
    }
    
    module.exports = Deque;
    
  provide("double-ended-queue", module.exports);
}(global));

// pakmanager:hashmap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * HashMap - HashMap Class for JavaScript
     * @author Ariel Flesler <aflesler@gmail.com>
     * @version 2.0.3
     * Homepage: https://github.com/flesler/hashmap
     */
    
    (function(factory) {
    	if (typeof define === 'function' && define.amd) {
    		// AMD. Register as an anonymous module.
    		define([], factory);
    	} else if (typeof module === 'object') {
    		// Node js environment
    		var HashMap = module.exports = factory();
    		// Keep it backwards compatible
    		HashMap.HashMap = HashMap;
    	} else {
    		// Browser globals (this is window)
    		this.HashMap = factory();
    	}
    }(function() {
    
    	function HashMap(other) {
    		this.clear();
    		switch (arguments.length) {
    			case 0: break;
    			case 1: this.copy(other); break;
    			default: multi(this, arguments); break;
    		}
    	}
    
    	var proto = HashMap.prototype = {
    		constructor:HashMap,
    
    		get:function(key) {
    			var data = this._data[this.hash(key)];
    			return data && data[1];
    		},
    
    		set:function(key, value) {
    			// Store original key as well (for iteration)
    			this._data[this.hash(key)] = [key, value];
    		},
    
    		multi:function() {
    			multi(this, arguments);
    		},
    
    		copy:function(other) {
    			for (var key in other._data) {
    				this._data[key] = other._data[key];
    			}
    		},
    
    		has:function(key) {
    			return this.hash(key) in this._data;
    		},
    
    		search:function(value) {
    			for (var key in this._data) {
    				if (this._data[key][1] === value) {
    					return this._data[key][0];
    				}
    			}
    
    			return null;
    		},
    
    		remove:function(key) {
    			delete this._data[this.hash(key)];
    		},
    
    		type:function(key) {
    			var str = Object.prototype.toString.call(key);
    			var type = str.slice(8, -1).toLowerCase();
    			// Some browsers yield DOMWindow for null and undefined, works fine on Node
    			if (type === 'domwindow' && !key) {
    				return key + '';
    			}
    			return type;
    		},
    
    		keys:function() {
    			var keys = [];
    			this.forEach(function(value, key) { keys.push(key); });
    			return keys;
    		},
    
    		values:function() {
    			var values = [];
    			this.forEach(function(value) { values.push(value); });
    			return values;
    		},
    
    		count:function() {
    			return this.keys().length;
    		},
    
    		clear:function() {
    			// TODO: Would Object.create(null) make any difference
    			this._data = {};
    		},
    
    		clone:function() {
    			return new HashMap(this);
    		},
    
    		hash:function(key) {
    			switch (this.type(key)) {
    				case 'undefined':
    				case 'null':
    				case 'boolean':
    				case 'number':
    				case 'regexp':
    					return key + '';
    
    				case 'date':
    					return '' + key.getTime();
    
    				case 'string':
    					return '' + key;
    
    				case 'array':
    					var hashes = [];
    					for (var i = 0; i < key.length; i++) {
    						hashes[i] = this.hash(key[i]);
    					}
    					return '' + hashes.join('');
    
    				default:
    					// TODO: Don't use expandos when Object.defineProperty is not available?
    					if (!key._hmuid_) {
    						key._hmuid_ = ++HashMap.uid;
    						hide(key, '_hmuid_');
    					}
    
    					return '' + key._hmuid_;
    			}
    		},
    
    		forEach:function(func, ctx) {
    			for (var key in this._data) {
    				var data = this._data[key];
    				func.call(ctx || this, data[1], data[0]);
    			}
    		}
    	};
    
    	HashMap.uid = 0;
    
    	//- Automatically add chaining to some methods
    
    	for (var method in proto) {
    		// Skip constructor, valueOf, toString and any other built-in method
    		if (method === 'constructor' || !proto.hasOwnProperty(method)) {
    			continue;
    		}
    		var fn = proto[method];
    		if (fn.toString().indexOf('return ') === -1) {
    			proto[method] = chain(fn);
    		}
    	}
    
    	//- Utils
    
    	function multi(map, args) {
    		for (var i = 0; i < args.length; i += 2) {
    			map.set(args[i], args[i+1]);
    		}
    	}
    
    	function chain(fn) {
    		return function() {
    			fn.apply(this, arguments);
    			return this;
    		};
    	}
    
    	function hide(obj, prop) {
    		// Make non iterable if supported
    		if (Object.defineProperty) {
    			Object.defineProperty(obj, prop, {enumerable:false});
    		}
    	}
    
    	return HashMap;
    }));
    
  provide("hashmap", module.exports);
}(global));

// pakmanager:core-util-is
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    
    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    
    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    
    function isBuffer(arg) {
      return Buffer.isBuffer(arg);
    }
    exports.isBuffer = isBuffer;
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  provide("core-util-is", module.exports);
}(global));

// pakmanager:isarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
    
  provide("isarray", module.exports);
}(global));

// pakmanager:string_decoder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var Buffer = require('buffer').Buffer;
    
    var isBufferEncoding = Buffer.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         }
    
    
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    
    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
    
      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    };
    
    
    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;
    
        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
    
        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }
    
        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);
    
        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    
        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
    
        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
    
      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);
    
      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
    
      charStr += buffer.toString(this.encoding, 0, end);
    
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
    
      // or just emit the charStr
      return charStr;
    };
    
    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;
    
      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
    
        // See http://en.wikipedia.org/wiki/UTF-8#Description
    
        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
    
        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
    
        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
    
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
    
      return res;
    };
    
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
    
  provide("string_decoder", module.exports);
}(global));

// pakmanager:user-home
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var env = process.env;
    var home = env.HOME;
    var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
    
    if (process.platform === 'win32') {
    	module.exports = env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
    } else if (process.platform === 'darwin') {
    	module.exports = home || (user ? '/Users/' + user : null) || null;
    } else if (process.platform === 'linux') {
    	module.exports = home ||
    		(user ? (process.getuid() === 0 ? '/root' : '/home/' + user) : null) || null;
    } else {
    	module.exports = home || null;
    }
    
  provide("user-home", module.exports);
}(global));

// pakmanager:bluebird/js/main/es5.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isES5 = (function(){
        "use strict";
        return this === undefined;
    })();
    
    if (isES5) {
        module.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5: isES5,
            propertyIsWritable: function(obj, prop) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!descriptor || descriptor.writable || descriptor.set);
            }
        };
    } else {
        var has = {}.hasOwnProperty;
        var str = {}.toString;
        var proto = {}.constructor.prototype;
    
        var ObjectKeys = function (o) {
            var ret = [];
            for (var key in o) {
                if (has.call(o, key)) {
                    ret.push(key);
                }
            }
            return ret;
        };
    
        var ObjectGetDescriptor = function(o, key) {
            return {value: o[key]};
        };
    
        var ObjectDefineProperty = function (o, key, desc) {
            o[key] = desc.value;
            return o;
        };
    
        var ObjectFreeze = function (obj) {
            return obj;
        };
    
        var ObjectGetPrototypeOf = function (obj) {
            try {
                return Object(obj).constructor.prototype;
            }
            catch (e) {
                return proto;
            }
        };
    
        var ArrayIsArray = function (obj) {
            try {
                return str.call(obj) === "[object Array]";
            }
            catch(e) {
                return false;
            }
        };
    
        module.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5: isES5,
            propertyIsWritable: function() {
                return true;
            }
        };
    }
    
  provide("bluebird/js/main/es5.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var canEvaluate = typeof navigator == "undefined";
    var haveGetters = (function(){
        try {
            var o = {};
            es5.defineProperty(o, "f", {
                get: function () {
                    return 3;
                }
            });
            return o.f === 3;
        }
        catch (e) {
            return false;
        }
    
    })();
    
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    
    var inherits = function(Child, Parent) {
        var hasProp = {}.hasOwnProperty;
    
        function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) &&
                    propertyName.charAt(propertyName.length-1) !== "$"
               ) {
                    this[propertyName + "$"] = Parent.prototype[propertyName];
                }
            }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
    };
    
    
    function isPrimitive(val) {
        return val == null || val === true || val === false ||
            typeof val === "string" || typeof val === "number";
    
    }
    
    function isObject(value) {
        return !isPrimitive(value);
    }
    
    function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
    
        return new Error(safeToString(maybeError));
    }
    
    function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
            ret[i] = target[i];
        }
        ret[i] = appendee;
        return ret;
    }
    
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
            if (desc != null) {
                return desc.get == null && desc.set == null
                        ? desc.value
                        : defaultValue;
            }
        } else {
            return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
    }
    
    function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
            value: value,
            configurable: true,
            enumerable: false,
            writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
    }
    
    
    var wrapsPrimitiveReceiver = (function() {
        return this !== "string";
    }).call("string");
    
    function thrower(r) {
        throw r;
    }
    
    var inheritedDataKeys = (function() {
        if (es5.isES5) {
            var oProto = Object.prototype;
            var getKeys = Object.getOwnPropertyNames;
            return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && obj !== oProto) {
                    var keys;
                    try {
                        keys = getKeys(obj);
                    } catch (e) {
                        return ret;
                    }
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (visitedKeys[key]) continue;
                        visitedKeys[key] = true;
                        var desc = Object.getOwnPropertyDescriptor(obj, key);
                        if (desc != null && desc.get == null && desc.set == null) {
                            ret.push(key);
                        }
                    }
                    obj = es5.getPrototypeOf(obj);
                }
                return ret;
            };
        } else {
            return function(obj) {
                var ret = [];
                /*jshint forin:false */
                for (var key in obj) {
                    ret.push(key);
                }
                return ret;
            };
        }
    
    })();
    
    function isClass(fn) {
        try {
            if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
                if (es5.isES5) return keys.length > 1;
                return keys.length > 0 &&
                       !(keys.length === 1 && keys[0] === "constructor");
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function f() {}
        f.prototype = obj;
        var l = 8;
        while (l--) new f();
        return obj;
        eval(obj);
    }
    
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
        return rident.test(str);
    }
    
    function filledRange(count, prefix, suffix) {
        var ret = new Array(count);
        for(var i = 0; i < count; ++i) {
            ret[i] = prefix + i + suffix;
        }
        return ret;
    }
    
    function safeToString(obj) {
        try {
            return obj + "";
        } catch (e) {
            return "[no string representation]";
        }
    }
    
    function markAsOriginatingFromRejection(e) {
        try {
            notEnumerableProp(e, "isOperational", true);
        }
        catch(ignore) {}
    }
    
    function originatesFromRejection(e) {
        if (e == null) return false;
        return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
            e["isOperational"] === true);
    }
    
    function canAttachTrace(obj) {
        return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
    }
    
    var ensureErrorObject = (function() {
        if (!("stack" in new Error())) {
            return function(value) {
                if (canAttachTrace(value)) return value;
                try {throw new Error(safeToString(value));}
                catch(err) {return err;}
            };
        } else {
            return function(value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
            };
        }
    })();
    
    function classString(obj) {
        return {}.toString.call(obj);
    }
    
    function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            }
        }
    }
    
    var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        haveGetters: haveGetters,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome &&
                     typeof chrome.loadTimes === "function",
        isNode: typeof process !== "undefined" &&
            classString(process).toLowerCase() === "[object process]"
    };
    ret.isRecentNode = ret.isNode && (function() {
        var version = process.versions.node.split(".").map(Number);
        return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
    })();
    try {throw new Error(); } catch (e) {ret.lastLineError = e;}
    module.exports = ret;
    
  provide("bluebird/js/main/util", module.exports);
}(global));

// pakmanager:bluebird/js/main/util.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var canEvaluate = typeof navigator == "undefined";
    var haveGetters = (function(){
        try {
            var o = {};
            es5.defineProperty(o, "f", {
                get: function () {
                    return 3;
                }
            });
            return o.f === 3;
        }
        catch (e) {
            return false;
        }
    
    })();
    
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    
    var inherits = function(Child, Parent) {
        var hasProp = {}.hasOwnProperty;
    
        function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) &&
                    propertyName.charAt(propertyName.length-1) !== "$"
               ) {
                    this[propertyName + "$"] = Parent.prototype[propertyName];
                }
            }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
    };
    
    
    function isPrimitive(val) {
        return val == null || val === true || val === false ||
            typeof val === "string" || typeof val === "number";
    
    }
    
    function isObject(value) {
        return !isPrimitive(value);
    }
    
    function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
    
        return new Error(safeToString(maybeError));
    }
    
    function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
            ret[i] = target[i];
        }
        ret[i] = appendee;
        return ret;
    }
    
    function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj, key);
            if (desc != null) {
                return desc.get == null && desc.set == null
                        ? desc.value
                        : defaultValue;
            }
        } else {
            return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
    }
    
    function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
            value: value,
            configurable: true,
            enumerable: false,
            writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
    }
    
    
    var wrapsPrimitiveReceiver = (function() {
        return this !== "string";
    }).call("string");
    
    function thrower(r) {
        throw r;
    }
    
    var inheritedDataKeys = (function() {
        if (es5.isES5) {
            var oProto = Object.prototype;
            var getKeys = Object.getOwnPropertyNames;
            return function(obj) {
                var ret = [];
                var visitedKeys = Object.create(null);
                while (obj != null && obj !== oProto) {
                    var keys;
                    try {
                        keys = getKeys(obj);
                    } catch (e) {
                        return ret;
                    }
                    for (var i = 0; i < keys.length; ++i) {
                        var key = keys[i];
                        if (visitedKeys[key]) continue;
                        visitedKeys[key] = true;
                        var desc = Object.getOwnPropertyDescriptor(obj, key);
                        if (desc != null && desc.get == null && desc.set == null) {
                            ret.push(key);
                        }
                    }
                    obj = es5.getPrototypeOf(obj);
                }
                return ret;
            };
        } else {
            return function(obj) {
                var ret = [];
                /*jshint forin:false */
                for (var key in obj) {
                    ret.push(key);
                }
                return ret;
            };
        }
    
    })();
    
    function isClass(fn) {
        try {
            if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
                if (es5.isES5) return keys.length > 1;
                return keys.length > 0 &&
                       !(keys.length === 1 && keys[0] === "constructor");
            }
            return false;
        } catch (e) {
            return false;
        }
    }
    
    function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function f() {}
        f.prototype = obj;
        var l = 8;
        while (l--) new f();
        return obj;
        eval(obj);
    }
    
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
        return rident.test(str);
    }
    
    function filledRange(count, prefix, suffix) {
        var ret = new Array(count);
        for(var i = 0; i < count; ++i) {
            ret[i] = prefix + i + suffix;
        }
        return ret;
    }
    
    function safeToString(obj) {
        try {
            return obj + "";
        } catch (e) {
            return "[no string representation]";
        }
    }
    
    function markAsOriginatingFromRejection(e) {
        try {
            notEnumerableProp(e, "isOperational", true);
        }
        catch(ignore) {}
    }
    
    function originatesFromRejection(e) {
        if (e == null) return false;
        return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
            e["isOperational"] === true);
    }
    
    function canAttachTrace(obj) {
        return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
    }
    
    var ensureErrorObject = (function() {
        if (!("stack" in new Error())) {
            return function(value) {
                if (canAttachTrace(value)) return value;
                try {throw new Error(safeToString(value));}
                catch(err) {return err;}
            };
        } else {
            return function(value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
            };
        }
    })();
    
    function classString(obj) {
        return {}.toString.call(obj);
    }
    
    function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            }
        }
    }
    
    var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        haveGetters: haveGetters,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome &&
                     typeof chrome.loadTimes === "function",
        isNode: typeof process !== "undefined" &&
            classString(process).toLowerCase() === "[object process]"
    };
    ret.isRecentNode = ret.isNode && (function() {
        var version = process.versions.node.split(".").map(Number);
        return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
    })();
    try {throw new Error(); } catch (e) {ret.lastLineError = e;}
    module.exports = ret;
    
  provide("bluebird/js/main/util.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/schedule.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var schedule;
    var util =  require('bluebird/js/main/util');
    var noAsyncScheduler = function() {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    };
    if (util.isNode && typeof MutationObserver === "undefined") {
        var GlobalSetImmediate = global.setImmediate;
        var ProcessNextTick = process.nextTick;
        schedule = util.isRecentNode
                    ? function(fn) { GlobalSetImmediate.call(global, fn); }
                    : function(fn) { ProcessNextTick.call(process, fn); };
    } else if (typeof MutationObserver !== "undefined") {
        schedule = function(fn) {
            var div = document.createElement("div");
            var observer = new MutationObserver(fn);
            observer.observe(div, {attributes: true});
            return function() { div.classList.toggle("foo"); };
        };
        schedule.isStatic = true;
    } else if (typeof setImmediate !== "undefined") {
        schedule = function (fn) {
            setImmediate(fn);
        };
    } else if (typeof setTimeout !== "undefined") {
        schedule = function (fn) {
            setTimeout(fn, 0);
        };
    } else {
        schedule = noAsyncScheduler;
    }
    module.exports = schedule;
    
  provide("bluebird/js/main/schedule.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/queue.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
        for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
        }
    }
    
    function Queue(capacity) {
        this._capacity = capacity;
        this._length = 0;
        this._front = 0;
    }
    
    Queue.prototype._willBeOverCapacity = function (size) {
        return this._capacity < size;
    };
    
    Queue.prototype._pushOne = function (arg) {
        var length = this.length();
        this._checkCapacity(length + 1);
        var i = (this._front + length) & (this._capacity - 1);
        this[i] = arg;
        this._length = length + 1;
    };
    
    Queue.prototype._unshiftOne = function(value) {
        var capacity = this._capacity;
        this._checkCapacity(this.length() + 1);
        var front = this._front;
        var i = (((( front - 1 ) &
                        ( capacity - 1) ) ^ capacity ) - capacity );
        this[i] = value;
        this._front = i;
        this._length = this.length() + 1;
    };
    
    Queue.prototype.unshift = function(fn, receiver, arg) {
        this._unshiftOne(arg);
        this._unshiftOne(receiver);
        this._unshiftOne(fn);
    };
    
    Queue.prototype.push = function (fn, receiver, arg) {
        var length = this.length() + 3;
        if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver);
            this._pushOne(arg);
            return;
        }
        var j = this._front + length - 3;
        this._checkCapacity(length);
        var wrapMask = this._capacity - 1;
        this[(j + 0) & wrapMask] = fn;
        this[(j + 1) & wrapMask] = receiver;
        this[(j + 2) & wrapMask] = arg;
        this._length = length;
    };
    
    Queue.prototype.shift = function () {
        var front = this._front,
            ret = this[front];
    
        this[front] = undefined;
        this._front = (front + 1) & (this._capacity - 1);
        this._length--;
        return ret;
    };
    
    Queue.prototype.length = function () {
        return this._length;
    };
    
    Queue.prototype._checkCapacity = function (size) {
        if (this._capacity < size) {
            this._resizeTo(this._capacity << 1);
        }
    };
    
    Queue.prototype._resizeTo = function (capacity) {
        var oldCapacity = this._capacity;
        this._capacity = capacity;
        var front = this._front;
        var length = this._length;
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    
    module.exports = Queue;
    
  provide("bluebird/js/main/queue.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/errors.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var Objectfreeze = es5.freeze;
    var util =  require('bluebird/js/main/util.js');
    var inherits = util.inherits;
    var notEnumerableProp = util.notEnumerableProp;
    
    function subError(nameProperty, defaultMessage) {
        function SubError(message) {
            if (!(this instanceof SubError)) return new SubError(message);
            notEnumerableProp(this, "message",
                typeof message === "string" ? message : defaultMessage);
            notEnumerableProp(this, "name", nameProperty);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            } else {
                Error.call(this);
            }
        }
        inherits(SubError, Error);
        return SubError;
    }
    
    var _TypeError, _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
        _TypeError = TypeError;
        _RangeError = RangeError;
    } catch(e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
    }
    
    var methods = ("join pop push shift unshift slice filter forEach some " +
        "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
    
    for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
    }
    
    es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");
        for (var i = 0; i < this.length; ++i) {
            var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret += str + "\n";
        }
        level--;
        return ret;
    };
    
    function OperationalError(message) {
        if (!(this instanceof OperationalError))
            return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
    
        if (message instanceof Error) {
            notEnumerableProp(this, "message", message.message);
            notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    
    }
    inherits(OperationalError, Error);
    
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
        errorTypes = Objectfreeze({
            CancellationError: CancellationError,
            TimeoutError: TimeoutError,
            OperationalError: OperationalError,
            RejectionError: OperationalError,
            AggregateError: AggregateError
        });
        notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
    }
    
    module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
    };
    
  provide("bluebird/js/main/errors.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/async.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var firstLineError;
    try {throw new Error(); } catch (e) {firstLineError = e;}
    var schedule =  require('bluebird/js/main/schedule.js');
    var Queue =  require('bluebird/js/main/queue.js');
    var util =  require('bluebird/js/main/util.js');
    
    function Async() {
        this._isTickUsed = false;
        this._lateQueue = new Queue(16);
        this._normalQueue = new Queue(16);
        this._trampolineEnabled = true;
        var self = this;
        this.drainQueues = function () {
            self._drainQueues();
        };
        this._schedule =
            schedule.isStatic ? schedule(this.drainQueues) : schedule;
    }
    
    Async.prototype.disableTrampolineIfNecessary = function() {
        if (util.hasDevTools) {
            this._trampolineEnabled = false;
        }
    };
    
    Async.prototype.enableTrampoline = function() {
        if (!this._trampolineEnabled) {
            this._trampolineEnabled = true;
            this._schedule = function(fn) {
                setTimeout(fn, 0);
            };
        }
    };
    
    Async.prototype.haveItemsQueued = function () {
        return this._normalQueue.length() > 0;
    };
    
    Async.prototype.throwLater = function(fn, arg) {
        if (arguments.length === 1) {
            arg = fn;
            fn = function () { throw arg; };
        }
        var domain = this._getDomain();
        if (domain !== undefined) fn = domain.bind(fn);
        if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
                fn(arg);
            }, 0);
        } else try {
            this._schedule(function() {
                fn(arg);
            });
        } catch (e) {
            throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
        }
    };
    
    Async.prototype._getDomain = function() {};
    
    if (!false) {
    if (util.isNode) {
        var EventsModule = require("events");
    
        var domainGetter = function() {
            var domain = process.domain;
            if (domain === null) return undefined;
            return domain;
        };
    
        if (EventsModule.usingDomains) {
            Async.prototype._getDomain = domainGetter;
        } else {
            var descriptor =
                Object.getOwnPropertyDescriptor(EventsModule, "usingDomains");
    
            if (descriptor) {
                if (!descriptor.configurable) {
                    process.on("domainsActivated", function() {
                        Async.prototype._getDomain = domainGetter;
                    });
                } else {
                    var usingDomains = false;
                    Object.defineProperty(EventsModule, "usingDomains", {
                        configurable: false,
                        enumerable: true,
                        get: function() {
                            return usingDomains;
                        },
                        set: function(value) {
                            if (usingDomains || !value) return;
                            usingDomains = true;
                            Async.prototype._getDomain = domainGetter;
                            util.toFastProperties(process);
                            process.emit("domainsActivated");
                        }
                    });
                }
            }
        }
    }
    }
    
    function AsyncInvokeLater(fn, receiver, arg) {
        var domain = this._getDomain();
        if (domain !== undefined) fn = domain.bind(fn);
        this._lateQueue.push(fn, receiver, arg);
        this._queueTick();
    }
    
    function AsyncInvoke(fn, receiver, arg) {
        var domain = this._getDomain();
        if (domain !== undefined) fn = domain.bind(fn);
        this._normalQueue.push(fn, receiver, arg);
        this._queueTick();
    }
    
    function AsyncSettlePromises(promise) {
        var domain = this._getDomain();
        if (domain !== undefined) {
            var fn = domain.bind(promise._settlePromises);
            this._normalQueue.push(fn, promise, undefined);
        } else {
            this._normalQueue._pushOne(promise);
        }
        this._queueTick();
    }
    
    if (!util.hasDevTools) {
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
        Async.prototype.invokeLater = function (fn, receiver, arg) {
            if (this._trampolineEnabled) {
                AsyncInvokeLater.call(this, fn, receiver, arg);
            } else {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            }
        };
    
        Async.prototype.invoke = function (fn, receiver, arg) {
            if (this._trampolineEnabled) {
                AsyncInvoke.call(this, fn, receiver, arg);
            } else {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 0);
            }
        };
    
        Async.prototype.settlePromises = function(promise) {
            if (this._trampolineEnabled) {
                AsyncSettlePromises.call(this, promise);
            } else {
                setTimeout(function() {
                    promise._settlePromises();
                }, 0);
            }
        };
    }
    
    Async.prototype.invokeFirst = function (fn, receiver, arg) {
        var domain = this._getDomain();
        if (domain !== undefined) fn = domain.bind(fn);
        this._normalQueue.unshift(fn, receiver, arg);
        this._queueTick();
    };
    
    Async.prototype._drainQueue = function(queue) {
        while (queue.length() > 0) {
            var fn = queue.shift();
            if (typeof fn !== "function") {
                fn._settlePromises();
                continue;
            }
            var receiver = queue.shift();
            var arg = queue.shift();
            fn.call(receiver, arg);
        }
    };
    
    Async.prototype._drainQueues = function () {
        this._drainQueue(this._normalQueue);
        this._reset();
        this._drainQueue(this._lateQueue);
    };
    
    Async.prototype._queueTick = function () {
        if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
        }
    };
    
    Async.prototype._reset = function () {
        this._isTickUsed = false;
    };
    
    module.exports = new Async();
    module.exports.firstLineError = firstLineError;
    
  provide("bluebird/js/main/async.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise_resolver.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var util =  require('bluebird/js/main/util.js');
    var maybeWrapAsError = util.maybeWrapAsError;
    var errors =  require('bluebird/js/main/errors.js');
    var TimeoutError = errors.TimeoutError;
    var OperationalError = errors.OperationalError;
    var haveGetters = util.haveGetters;
    var es5 =  require('bluebird/js/main/es5.js');
    
    function isUntypedError(obj) {
        return obj instanceof Error &&
            es5.getPrototypeOf(obj) === Error.prototype;
    }
    
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj) {
        var ret;
        if (isUntypedError(obj)) {
            ret = new OperationalError(obj);
            ret.name = obj.name;
            ret.message = obj.message;
            ret.stack = obj.stack;
            var keys = es5.keys(obj);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!rErrorKey.test(key)) {
                    ret[key] = obj[key];
                }
            }
            return ret;
        }
        util.markAsOriginatingFromRejection(obj);
        return obj;
    }
    
    function nodebackForPromise(promise) {
        return function(err, value) {
            if (promise === null) return;
    
            if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
                promise._attachExtraTrace(wrapped);
                promise._reject(wrapped);
            } else if (arguments.length > 2) {
                var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
                promise._fulfill(args);
            } else {
                promise._fulfill(value);
            }
    
            promise = null;
        };
    }
    
    
    var PromiseResolver;
    if (!haveGetters) {
        PromiseResolver = function (promise) {
            this.promise = promise;
            this.asCallback = nodebackForPromise(promise);
            this.callback = this.asCallback;
        };
    }
    else {
        PromiseResolver = function (promise) {
            this.promise = promise;
        };
    }
    if (haveGetters) {
        var prop = {
            get: function() {
                return nodebackForPromise(this.promise);
            }
        };
        es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
        es5.defineProperty(PromiseResolver.prototype, "callback", prop);
    }
    
    PromiseResolver._nodebackForPromise = nodebackForPromise;
    
    PromiseResolver.prototype.toString = function () {
        return "[object PromiseResolver]";
    };
    
    PromiseResolver.prototype.resolve =
    PromiseResolver.prototype.fulfill = function (value) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._resolveCallback(value);
    };
    
    PromiseResolver.prototype.reject = function (reason) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._rejectCallback(reason);
    };
    
    PromiseResolver.prototype.progress = function (value) {
        if (!(this instanceof PromiseResolver)) {
            throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
        }
        this.promise._progress(value);
    };
    
    PromiseResolver.prototype.cancel = function (err) {
        this.promise.cancel(err);
    };
    
    PromiseResolver.prototype.timeout = function () {
        this.reject(new TimeoutError("timeout"));
    };
    
    PromiseResolver.prototype.isResolved = function () {
        return this.promise.isResolved();
    };
    
    PromiseResolver.prototype.toJSON = function () {
        return this.promise.toJSON();
    };
    
    module.exports = PromiseResolver;
    
  provide("bluebird/js/main/promise_resolver.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var es5 =  require('bluebird/js/main/es5.js');
    var Objectfreeze = es5.freeze;
    var util =  require('bluebird/js/main/util.js');
    var inherits = util.inherits;
    var notEnumerableProp = util.notEnumerableProp;
    
    function subError(nameProperty, defaultMessage) {
        function SubError(message) {
            if (!(this instanceof SubError)) return new SubError(message);
            notEnumerableProp(this, "message",
                typeof message === "string" ? message : defaultMessage);
            notEnumerableProp(this, "name", nameProperty);
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            } else {
                Error.call(this);
            }
        }
        inherits(SubError, Error);
        return SubError;
    }
    
    var _TypeError, _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
        _TypeError = TypeError;
        _RangeError = RangeError;
    } catch(e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
    }
    
    var methods = ("join pop push shift unshift slice filter forEach some " +
        "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
    
    for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
    }
    
    es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");
        for (var i = 0; i < this.length; ++i) {
            var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret += str + "\n";
        }
        level--;
        return ret;
    };
    
    function OperationalError(message) {
        if (!(this instanceof OperationalError))
            return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
    
        if (message instanceof Error) {
            notEnumerableProp(this, "message", message.message);
            notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    
    }
    inherits(OperationalError, Error);
    
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
        errorTypes = Objectfreeze({
            CancellationError: CancellationError,
            TimeoutError: TimeoutError,
            OperationalError: OperationalError,
            RejectionError: OperationalError,
            AggregateError: AggregateError
        });
        notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
    }
    
    module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
    };
    
  provide("bluebird/js/main/errors", module.exports);
}(global));

// pakmanager:bluebird/js/main/thenables.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var errorObj = util.errorObj;
    var isObject = util.isObject;
    
    function tryConvertToPromise(obj, context) {
        if (isObject(obj)) {
            if (obj instanceof Promise) {
                return obj;
            }
            else if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfillUnchecked,
                    ret._rejectUncheckedCheckError,
                    ret._progressUnchecked,
                    ret,
                    null
                );
                return ret;
            }
            var then = util.tryCatch(getThen)(obj);
            if (then === errorObj) {
                if (context) context._pushContext();
                var ret = Promise.reject(then.e);
                if (context) context._popContext();
                return ret;
            } else if (typeof then === "function") {
                return doThenable(obj, then, context);
            }
        }
        return obj;
    }
    
    function getThen(obj) {
        return obj.then;
    }
    
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
        return hasProp.call(obj, "_promise0");
    }
    
    function doThenable(x, then, context) {
        var promise = new Promise(INTERNAL);
        var ret = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x,
                                            resolveFromThenable,
                                            rejectFromThenable,
                                            progressFromThenable);
        synchronous = false;
        if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
        }
    
        function resolveFromThenable(value) {
            if (!promise) return;
            if (x === value) {
                promise._rejectCallback(
                    Promise._makeSelfResolutionError(), false, true);
            } else {
                promise._resolveCallback(value);
            }
            promise = null;
        }
    
        function rejectFromThenable(reason) {
            if (!promise) return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
        }
    
        function progressFromThenable(value) {
            if (!promise) return;
            if (typeof promise._progress === "function") {
                promise._progress(value);
            }
        }
        return ret;
    }
    
    return tryConvertToPromise;
    };
    
  provide("bluebird/js/main/thenables.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise_array.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise,
        apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var isArray = util.isArray;
    
    function toResolutionValue(val) {
        switch(val) {
        case -2: return [];
        case -3: return {};
        }
    }
    
    function PromiseArray(values) {
        var promise = this._promise = new Promise(INTERNAL);
        var parent;
        if (values instanceof Promise) {
            parent = values;
            promise._propagateFrom(parent, 1 | 4);
        }
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(undefined, -2);
    }
    PromiseArray.prototype.length = function () {
        return this._length;
    };
    
    PromiseArray.prototype.promise = function () {
        return this._promise;
    };
    
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise) {
            values = values._target();
            this._values = values;
            if (values._isFulfilled()) {
                values = values._value();
                if (!isArray(values)) {
                    var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                    this.__hardReject__(err);
                    return;
                }
            } else if (values._isPending()) {
                values._then(
                    init,
                    this._reject,
                    undefined,
                    this,
                    resolveValueIfEmpty
               );
                return;
            } else {
                this._reject(values._reason());
                return;
            }
        } else if (!isArray(values)) {
            this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
            return;
        }
    
        if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
            }
            else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
        }
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var promise = this._promise;
        for (var i = 0; i < len; ++i) {
            var isResolved = this._isResolved();
            var maybePromise = tryConvertToPromise(values[i], promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (isResolved) {
                    maybePromise._unsetRejectionIsUnhandled();
                } else if (maybePromise._isPending()) {
                    maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                    this._promiseFulfilled(maybePromise._value(), i);
                } else {
                    this._promiseRejected(maybePromise._reason(), i);
                }
            } else if (!isResolved) {
                this._promiseFulfilled(maybePromise, i);
            }
        }
    };
    
    PromiseArray.prototype._isResolved = function () {
        return this._values === null;
    };
    
    PromiseArray.prototype._resolve = function (value) {
        this._values = null;
        this._promise._fulfill(value);
    };
    
    PromiseArray.prototype.__hardReject__ =
    PromiseArray.prototype._reject = function (reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false, true);
    };
    
    PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
        this._promise._progress({
            index: index,
            value: progressValue
        });
    };
    
    
    PromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
        }
    };
    
    PromiseArray.prototype._promiseRejected = function (reason, index) {
        this._totalResolved++;
        this._reject(reason);
    };
    
    PromiseArray.prototype.shouldCopyValues = function () {
        return true;
    };
    
    PromiseArray.prototype.getActualLength = function (len) {
        return len;
    };
    
    return PromiseArray;
    };
    
  provide("bluebird/js/main/promise_array.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/captured_trace.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function() {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var bluebirdFramePattern =
        /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var warn;
    
    function CapturedTrace(parent) {
        this._parent = parent;
        var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    
    CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};
    
        for (var i = 0, node = this; node !== undefined; ++i) {
            nodes.push(node);
            node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === undefined) {
                stackToIndex[stack] = i;
            }
        }
        for (var i = 0; i < length; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== undefined && index !== i) {
                if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = undefined;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
    
                if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length =
                        cycleEdgeNode._parent._length + 1;
                } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                }
                return;
            }
        }
    };
    
    CapturedTrace.prototype.parent = function() {
        return this._parent;
    };
    
    CapturedTrace.prototype.hasParent = function() {
        return this._parent !== undefined;
    };
    
    CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = CapturedTrace.parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
    
        var trace = this;
        while (trace !== undefined) {
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
    };
    
    function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
    }
    
    function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 ||
                ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
                stacks.splice(i, 1);
                i--;
            }
        }
    }
    
    function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;
    
            for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                }
            }
    
            for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                } else {
                    break;
                }
            }
            current = prev;
        }
    }
    
    function cleanStack(stack) {
        var ret = [];
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = stackFramePattern.test(line) ||
                "    (No stack trace)" === line;
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                }
                ret.push(line);
            }
        }
        return ret;
    }
    
    function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
            }
        }
        if (i > 0) {
            stack = stack.slice(i);
        }
        return stack;
    }
    
    CapturedTrace.parseStackAndMessage = function(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0
                    ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
            message: message,
            stack: cleanStack(stack)
        };
    };
    
    CapturedTrace.formatAndLogError = function(error, title) {
        if (typeof console !== "undefined") {
            var message;
            if (typeof error === "object" || typeof error === "function") {
                var stack = error.stack;
                message = title + formatStack(stack, error);
            } else {
                message = title + String(error);
            }
            if (typeof warn === "function") {
                warn(message);
            } else if (typeof console.log === "function" ||
                typeof console.log === "object") {
                console.log(message);
            }
        }
    };
    
    CapturedTrace.unhandledRejection = function (reason) {
        CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
    };
    
    CapturedTrace.isSupported = function () {
        return typeof captureStackTrace === "function";
    };
    
    CapturedTrace.fireRejectionEvent =
    function(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
            if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                    localHandler(promise);
                } else {
                    localHandler(reason, promise);
                }
            }
        } catch (e) {
            async.throwLater(e);
        }
    
        var globalEventFired = false;
        try {
            globalEventFired = fireGlobalEvent(name, reason, promise);
        } catch (e) {
            globalEventFired = true;
            async.throwLater(e);
        }
    
        var domEventFired = false;
        if (fireDomEvent) {
            try {
                domEventFired = fireDomEvent(name.toLowerCase(), {
                    reason: reason,
                    promise: promise
                });
            } catch (e) {
                domEventFired = true;
                async.throwLater(e);
            }
        }
    
        if (!globalEventFired && !localEventFired && !domEventFired &&
            name === "unhandledRejection") {
            CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
        }
    };
    
    function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
            str = "[function " +
                (obj.name || "anonymous") +
                "]";
        } else {
            str = obj.toString();
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
                try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                }
                catch(e) {
    
                }
            }
            if (str.length === 0) {
                str = "(empty array)";
            }
        }
        return ("(<" + snip(str) + ">, no stack trace)");
    }
    
    function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
            return str;
        }
        return str.substr(0, maxChars - 3) + "...";
    }
    
    var shouldIgnore = function() { return false; };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
            return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
    }
    CapturedTrace.setBounds = function(firstLineError, lastLineError) {
        if (!CapturedTrace.isSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
            }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
            }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
            firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
        }
    
        shouldIgnore = function(line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);
            if (info) {
                if (info.fileName === firstFileName &&
                    (firstIndex <= info.line && info.line <= lastIndex)) {
                    return true;
                }
            }
            return false;
        };
    };
    
    var captureStackTrace = (function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
            if (typeof stack === "string") return stack;
    
            if (error.name !== undefined &&
                error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
    
        if (typeof Error.stackTraceLimit === "number" &&
            typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;
    
            shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
            };
            return function(receiver, ignoreUntil) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                captureStackTrace(receiver, ignoreUntil);
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
            };
        }
        var err = new Error();
    
        if (typeof err.stack === "string" &&
            err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
                o.stack = new Error().stack;
            };
        }
    
        var hasStackAfterThrow;
        try { throw new Error(); }
        catch(e) {
            hasStackAfterThrow = ("stack" in e);
        }
        if (!("stack" in err) && hasStackAfterThrow) {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
                Error.stackTraceLimit = Error.stackTraceLimit + 6;
                try { throw new Error(); }
                catch(e) { o.stack = e.stack; }
                Error.stackTraceLimit = Error.stackTraceLimit - 6;
            };
        }
    
        formatStack = function(stack, error) {
            if (typeof stack === "string") return stack;
    
            if ((typeof error === "object" ||
                typeof error === "function") &&
                error.name !== undefined &&
                error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
    
        return null;
    
    })([]);
    
    var fireDomEvent;
    var fireGlobalEvent = (function() {
        if (util.isNode) {
            return function(name, reason, promise) {
                if (name === "rejectionHandled") {
                    return process.emit(name, promise);
                } else {
                    return process.emit(name, reason, promise);
                }
            };
        } else {
            var customEventWorks = false;
            var anyEventWorks = true;
            try {
                var ev = new self.CustomEvent("test");
                customEventWorks = ev instanceof CustomEvent;
            } catch (e) {}
            if (!customEventWorks) {
                try {
                    var event = document.createEvent("CustomEvent");
                    event.initCustomEvent("testingtheevent", false, true, {});
                    self.dispatchEvent(event);
                } catch (e) {
                    anyEventWorks = false;
                }
            }
            if (anyEventWorks) {
                fireDomEvent = function(type, detail) {
                    var event;
                    if (customEventWorks) {
                        event = new self.CustomEvent(type, {
                            detail: detail,
                            bubbles: false,
                            cancelable: true
                        });
                    } else if (self.dispatchEvent) {
                        event = document.createEvent("CustomEvent");
                        event.initCustomEvent(type, false, true, detail);
                    }
    
                    return event ? !self.dispatchEvent(event) : false;
                };
            }
    
            var toWindowMethodNameMap = {};
            toWindowMethodNameMap["unhandledRejection"] = ("on" +
                "unhandledRejection").toLowerCase();
            toWindowMethodNameMap["rejectionHandled"] = ("on" +
                "rejectionHandled").toLowerCase();
    
            return function(name, reason, promise) {
                var methodName = toWindowMethodNameMap[name];
                var method = self[methodName];
                if (!method) return false;
                if (name === "rejectionHandled") {
                    method.call(self, promise);
                } else {
                    method.call(self, reason, promise);
                }
                return true;
            };
        }
    })();
    
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        warn = function (message) {
            console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
            warn = function(message) {
                process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
            };
        } else if (!util.isNode && typeof (new Error().stack) === "string") {
            warn = function(message) {
                console.warn("%c" + message, "color: red");
            };
        }
    }
    
    return CapturedTrace;
    };
    
  provide("bluebird/js/main/captured_trace.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/debuggability.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, CapturedTrace) {
    var async =  require('bluebird/js/main/async.js');
    var Warning =  require('bluebird/js/main/errors.js').Warning;
    var util =  require('bluebird/js/main/util.js');
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var debugging = false || (util.isNode &&
                        (!!process.env["BLUEBIRD_DEBUG"] ||
                         process.env["NODE_ENV"] === "development"));
    
    if (debugging) {
        async.disableTrampolineIfNecessary();
    }
    
    Promise.prototype._ensurePossibleRejectionHandled = function () {
        this._setRejectionIsUnhandled();
        async.invokeLater(this._notifyUnhandledRejection, this, undefined);
    };
    
    Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
        CapturedTrace.fireRejectionEvent("rejectionHandled",
                                      unhandledRejectionHandled, undefined, this);
    };
    
    Promise.prototype._notifyUnhandledRejection = function () {
        if (this._isRejectionUnhandled()) {
            var reason = this._getCarriedStackTrace() || this._settledValue;
            this._setUnhandledRejectionIsNotified();
            CapturedTrace.fireRejectionEvent("unhandledRejection",
                                          possiblyUnhandledRejection, reason, this);
        }
    };
    
    Promise.prototype._setUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField | 524288;
    };
    
    Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField & (~524288);
    };
    
    Promise.prototype._isUnhandledRejectionNotified = function () {
        return (this._bitField & 524288) > 0;
    };
    
    Promise.prototype._setRejectionIsUnhandled = function () {
        this._bitField = this._bitField | 2097152;
    };
    
    Promise.prototype._unsetRejectionIsUnhandled = function () {
        this._bitField = this._bitField & (~2097152);
        if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
        }
    };
    
    Promise.prototype._isRejectionUnhandled = function () {
        return (this._bitField & 2097152) > 0;
    };
    
    Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
        this._bitField = this._bitField | 1048576;
        this._fulfillmentHandler0 = capturedTrace;
    };
    
    Promise.prototype._isCarryingStackTrace = function () {
        return (this._bitField & 1048576) > 0;
    };
    
    Promise.prototype._getCarriedStackTrace = function () {
        return this._isCarryingStackTrace()
            ? this._fulfillmentHandler0
            : undefined;
    };
    
    Promise.prototype._captureStackTrace = function () {
        if (debugging) {
            this._trace = new CapturedTrace(this._peekContext());
        }
        return this;
    };
    
    Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
        if (debugging && canAttachTrace(error)) {
            var trace = this._trace;
            if (trace !== undefined) {
                if (ignoreSelf) trace = trace._parent;
            }
            if (trace !== undefined) {
                trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
                var parsed = CapturedTrace.parseStackAndMessage(error);
                util.notEnumerableProp(error, "stack",
                    parsed.message + "\n" + parsed.stack.join("\n"));
                util.notEnumerableProp(error, "__stackCleaned__", true);
            }
        }
    };
    
    Promise.prototype._warn = function(message) {
        var warning = new Warning(message);
        var ctx = this._peekContext();
        if (ctx) {
            ctx.attachExtraTrace(warning);
        } else {
            var parsed = CapturedTrace.parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        CapturedTrace.formatAndLogError(warning, "");
    };
    
    Promise.onPossiblyUnhandledRejection = function (fn) {
        possiblyUnhandledRejection = typeof fn === "function" ? fn : undefined;
    };
    
    Promise.onUnhandledRejectionHandled = function (fn) {
        unhandledRejectionHandled = typeof fn === "function" ? fn : undefined;
    };
    
    Promise.longStackTraces = function () {
        if (async.haveItemsQueued() &&
            debugging === false
       ) {
            throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
        }
        debugging = CapturedTrace.isSupported();
        if (debugging) {
            async.disableTrampolineIfNecessary();
        }
    };
    
    Promise.hasLongStackTraces = function () {
        return debugging && CapturedTrace.isSupported();
    };
    
    if (!CapturedTrace.isSupported()) {
        Promise.longStackTraces = function(){};
        debugging = false;
    }
    
    return function() {
        return debugging;
    };
    };
    
  provide("bluebird/js/main/debuggability.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/context.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, CapturedTrace, isDebugging) {
    var contextStack = [];
    function Context() {
        this._trace = new CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function () {
        if (!isDebugging()) return;
        if (this._trace !== undefined) {
            contextStack.push(this._trace);
        }
    };
    
    Context.prototype._popContext = function () {
        if (!isDebugging()) return;
        if (this._trace !== undefined) {
            contextStack.pop();
        }
    };
    
    function createContext() {
        if (isDebugging()) return new Context();
    }
    
    function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
            return contextStack[lastIndex];
        }
        return undefined;
    }
    
    Promise.prototype._peekContext = peekContext;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    
    return createContext;
    };
    
  provide("bluebird/js/main/context.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/catch_filter.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(NEXT_FILTER) {
    var util =  require('bluebird/js/main/util.js');
    var errors =  require('bluebird/js/main/errors.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var keys =  require('bluebird/js/main/es5.js').keys;
    var TypeError = errors.TypeError;
    
    function CatchFilter(instances, callback, promise) {
        this._instances = instances;
        this._callback = callback;
        this._promise = promise;
    }
    
    function safePredicate(predicate, e) {
        var safeObject = {};
        var retfilter = tryCatch(predicate).call(safeObject, e);
    
        if (retfilter === errorObj) return retfilter;
    
        var safeKeys = keys(safeObject);
        if (safeKeys.length) {
            errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
            return errorObj;
        }
        return retfilter;
    }
    
    CatchFilter.prototype.doFilter = function (e) {
        var cb = this._callback;
        var promise = this._promise;
        var boundTo = promise._boundTo;
        for (var i = 0, len = this._instances.length; i < len; ++i) {
            var item = this._instances[i];
            var itemIsErrorType = item === Error ||
                (item != null && item.prototype instanceof Error);
    
            if (itemIsErrorType && e instanceof item) {
                var ret = tryCatch(cb).call(boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            } else if (typeof item === "function" && !itemIsErrorType) {
                var shouldHandle = safePredicate(item, e);
                if (shouldHandle === errorObj) {
                    e = errorObj.e;
                    break;
                } else if (shouldHandle) {
                    var ret = tryCatch(cb).call(boundTo, e);
                    if (ret === errorObj) {
                        NEXT_FILTER.e = ret.e;
                        return NEXT_FILTER;
                    }
                    return ret;
                }
            }
        }
        NEXT_FILTER.e = e;
        return NEXT_FILTER;
    };
    
    return CatchFilter;
    };
    
  provide("bluebird/js/main/catch_filter.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/progress.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, PromiseArray) {
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    
    Promise.prototype.progressed = function (handler) {
        return this._then(undefined, undefined, handler, undefined, undefined);
    };
    
    Promise.prototype._progress = function (progressValue) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._target()._progressUnchecked(progressValue);
    
    };
    
    Promise.prototype._progressHandlerAt = function (index) {
        return index === 0
            ? this._progressHandler0
            : this[(index << 2) + index - 5 + 2];
    };
    
    Promise.prototype._doProgressWith = function (progression) {
        var progressValue = progression.value;
        var handler = progression.handler;
        var promise = progression.promise;
        var receiver = progression.receiver;
    
        var ret = tryCatch(handler).call(receiver, progressValue);
        if (ret === errorObj) {
            if (ret.e != null &&
                ret.e.name !== "StopProgressPropagation") {
                var trace = util.canAttachTrace(ret.e)
                    ? ret.e : new Error(util.toString(ret.e));
                promise._attachExtraTrace(trace);
                promise._progress(ret.e);
            }
        } else if (ret instanceof Promise) {
            ret._then(promise._progress, null, null, promise, undefined);
        } else {
            promise._progress(ret);
        }
    };
    
    
    Promise.prototype._progressUnchecked = function (progressValue) {
        var len = this._length();
        var progress = this._progress;
        for (var i = 0; i < len; i++) {
            var handler = this._progressHandlerAt(i);
            var promise = this._promiseAt(i);
            if (!(promise instanceof Promise)) {
                var receiver = this._receiverAt(i);
                if (typeof handler === "function") {
                    handler.call(receiver, progressValue, promise);
                } else if (receiver instanceof PromiseArray &&
                           !receiver._isResolved()) {
                    receiver._promiseProgressed(progressValue, promise);
                }
                continue;
            }
    
            if (typeof handler === "function") {
                async.invoke(this._doProgressWith, this, {
                    handler: handler,
                    promise: promise,
                    receiver: this._receiverAt(i),
                    value: progressValue
                });
            } else {
                async.invoke(progress, promise, progressValue);
            }
        }
    };
    };
    
  provide("bluebird/js/main/progress.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/method.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    
    Promise.method = function (fn) {
        if (typeof fn !== "function") {
            throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        return function () {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._pushContext();
            var value = tryCatch(fn).apply(this, arguments);
            ret._popContext();
            ret._resolveFromSyncValue(value);
            return ret;
        };
    };
    
    Promise.attempt = Promise["try"] = function (fn, args, ctx) {
        if (typeof fn !== "function") {
            return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = util.isArray(args)
            ? tryCatch(fn).apply(ctx, args)
            : tryCatch(fn).call(ctx, args);
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
    };
    
    Promise.prototype._resolveFromSyncValue = function (value) {
        if (value === util.errorObj) {
            this._rejectCallback(value.e, false, true);
        } else {
            this._resolveCallback(value, true);
        }
    };
    };
    
  provide("bluebird/js/main/method.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/bind.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
    var rejectThis = function(_, e) {
        this._reject(e);
    };
    
    var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    
    var bindingResolved = function(thisArg, context) {
        this._setBoundTo(thisArg);
        if (this._isPending()) {
            this._resolveCallback(context.target);
        }
    };
    
    var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
    };
    
    Promise.prototype.bind = function (thisArg) {
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
        ret._propagateFrom(this, 1);
        var target = this._target();
        if (maybePromise instanceof Promise) {
            var context = {
                promiseRejectionQueued: false,
                promise: ret,
                target: target,
                bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, ret._progress, ret, context);
            maybePromise._then(
                bindingResolved, bindingRejected, ret._progress, ret, context);
        } else {
            ret._setBoundTo(thisArg);
            ret._resolveCallback(target);
        }
        return ret;
    };
    
    Promise.prototype._setBoundTo = function (obj) {
        if (obj !== undefined) {
            this._bitField = this._bitField | 131072;
            this._boundTo = obj;
        } else {
            this._bitField = this._bitField & (~131072);
        }
    };
    
    Promise.prototype._isBound = function () {
        return (this._bitField & 131072) === 131072;
    };
    
    Promise.bind = function (thisArg, value) {
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
    
        if (maybePromise instanceof Promise) {
            maybePromise._then(function(thisArg) {
                ret._setBoundTo(thisArg);
                ret._resolveCallback(value);
            }, ret._reject, ret._progress, ret, null);
        } else {
            ret._setBoundTo(thisArg);
            ret._resolveCallback(value);
        }
        return ret;
    };
    };
    
  provide("bluebird/js/main/bind.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/finally.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
    var util =  require('bluebird/js/main/util.js');
    var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
    var isPrimitive = util.isPrimitive;
    var thrower = util.thrower;
    
    function returnThis() {
        return this;
    }
    function throwThis() {
        throw this;
    }
    function return$(r) {
        return function() {
            return r;
        };
    }
    function throw$(r) {
        return function() {
            throw r;
        };
    }
    function promisedFinally(ret, reasonOrValue, isFulfilled) {
        var then;
        if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
            then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
        } else {
            then = isFulfilled ? returnThis : throwThis;
        }
        return ret._then(then, thrower, undefined, reasonOrValue, undefined);
    }
    
    function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
    
        var ret = promise._isBound()
                        ? handler.call(promise._boundTo)
                        : handler();
    
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, reasonOrValue,
                                        promise.isFulfilled());
            }
        }
    
        if (promise.isRejected()) {
            NEXT_FILTER.e = reasonOrValue;
            return NEXT_FILTER;
        } else {
            return reasonOrValue;
        }
    }
    
    function tapHandler(value) {
        var promise = this.promise;
        var handler = this.handler;
    
        var ret = promise._isBound()
                        ? handler.call(promise._boundTo, value)
                        : handler(value);
    
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                return promisedFinally(maybePromise, value, true);
            }
        }
        return value;
    }
    
    Promise.prototype._passThroughHandler = function (handler, isFinally) {
        if (typeof handler !== "function") return this.then();
    
        var promiseAndHandler = {
            promise: this,
            handler: handler
        };
    
        return this._then(
                isFinally ? finallyHandler : tapHandler,
                isFinally ? finallyHandler : undefined, undefined,
                promiseAndHandler, undefined);
    };
    
    Promise.prototype.lastly =
    Promise.prototype["finally"] = function (handler) {
        return this._passThroughHandler(handler, true);
    };
    
    Promise.prototype.tap = function (handler) {
        return this._passThroughHandler(handler, false);
    };
    };
    
  provide("bluebird/js/main/finally.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/direct_resolve.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var util =  require('bluebird/js/main/util.js');
    var isPrimitive = util.isPrimitive;
    var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
    
    module.exports = function(Promise) {
    var returner = function () {
        return this;
    };
    var thrower = function () {
        throw this;
    };
    var returnUndefined = function() {};
    var throwUndefined = function() {
        throw undefined;
    };
    
    var wrapper = function (value, action) {
        if (action === 1) {
            return function () {
                throw value;
            };
        } else if (action === 2) {
            return function () {
                return value;
            };
        }
    };
    
    
    Promise.prototype["return"] =
    Promise.prototype.thenReturn = function (value) {
        if (value === undefined) return this.then(returnUndefined);
    
        if (wrapsPrimitiveReceiver && isPrimitive(value)) {
            return this._then(
                wrapper(value, 2),
                undefined,
                undefined,
                undefined,
                undefined
           );
        }
        return this._then(returner, undefined, undefined, value, undefined);
    };
    
    Promise.prototype["throw"] =
    Promise.prototype.thenThrow = function (reason) {
        if (reason === undefined) return this.then(throwUndefined);
    
        if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
            return this._then(
                wrapper(reason, 1),
                undefined,
                undefined,
                undefined,
                undefined
           );
        }
        return this._then(thrower, undefined, undefined, reason, undefined);
    };
    };
    
  provide("bluebird/js/main/direct_resolve.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/synchronous_inspection.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    function PromiseInspection(promise) {
        if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValue = promise._settledValue;
        }
        else {
            this._bitField = 0;
            this._settledValue = undefined;
        }
    }
    
    PromiseInspection.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
        }
        return this._settledValue;
    };
    
    PromiseInspection.prototype.error =
    PromiseInspection.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
        }
        return this._settledValue;
    };
    
    PromiseInspection.prototype.isFulfilled =
    Promise.prototype._isFulfilled = function () {
        return (this._bitField & 268435456) > 0;
    };
    
    PromiseInspection.prototype.isRejected =
    Promise.prototype._isRejected = function () {
        return (this._bitField & 134217728) > 0;
    };
    
    PromiseInspection.prototype.isPending =
    Promise.prototype._isPending = function () {
        return (this._bitField & 402653184) === 0;
    };
    
    PromiseInspection.prototype.isResolved =
    Promise.prototype._isResolved = function () {
        return (this._bitField & 402653184) > 0;
    };
    
    Promise.prototype.isPending = function() {
        return this._target()._isPending();
    };
    
    Promise.prototype.isRejected = function() {
        return this._target()._isRejected();
    };
    
    Promise.prototype.isFulfilled = function() {
        return this._target()._isFulfilled();
    };
    
    Promise.prototype.isResolved = function() {
        return this._target()._isResolved();
    };
    
    Promise.prototype._value = function() {
        return this._settledValue;
    };
    
    Promise.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue;
    };
    
    Promise.prototype.value = function() {
        var target = this._target();
        if (!target.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
        }
        return target._settledValue;
    };
    
    Promise.prototype.reason = function() {
        var target = this._target();
        if (!target.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
        }
        target._unsetRejectionIsUnhandled();
        return target._settledValue;
    };
    
    
    Promise.PromiseInspection = PromiseInspection;
    };
    
  provide("bluebird/js/main/synchronous_inspection.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/join.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;
    
    if (!false) {
    if (canEvaluate) {
        var thenCallback = function(i) {
            return new Function("value", "holder", "                             \n\
                'use strict';                                                    \n\
                holder.pIndex = value;                                           \n\
                holder.checkFulfillment(this);                                   \n\
                ".replace(/Index/g, i));
        };
    
        var caller = function(count) {
            var values = [];
            for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
            return new Function("holder", "                                      \n\
                'use strict';                                                    \n\
                var callback = holder.fn;                                        \n\
                return callback(values);                                         \n\
                ".replace(/values/g, values.join(", ")));
        };
        var thenCallbacks = [];
        var callers = [undefined];
        for (var i = 1; i <= 5; ++i) {
            thenCallbacks.push(thenCallback(i));
            callers.push(caller(i));
        }
    
        var Holder = function(total, fn) {
            this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
            this.fn = fn;
            this.total = total;
            this.now = 0;
        };
    
        Holder.prototype.callers = callers;
        Holder.prototype.checkFulfillment = function(promise) {
            var now = this.now;
            now++;
            var total = this.total;
            if (now >= total) {
                var handler = this.callers[total];
                promise._pushContext();
                var ret = tryCatch(handler)(this);
                promise._popContext();
                if (ret === errorObj) {
                    promise._rejectCallback(ret.e, false, true);
                } else {
                    promise._resolveCallback(ret);
                }
            } else {
                this.now = now;
            }
        };
    
        var reject = function (reason) {
            this._reject(reason);
        };
    }
    }
    
    Promise.join = function () {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];
            if (!false) {
                if (last < 6 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var holder = new Holder(last, fn);
                    var callbacks = thenCallbacks;
                    for (var i = 0; i < last; ++i) {
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            if (maybePromise._isPending()) {
                                maybePromise._then(callbacks[i], reject,
                                                   undefined, ret, holder);
                            } else if (maybePromise._isFulfilled()) {
                                callbacks[i].call(ret,
                                                  maybePromise._value(), holder);
                            } else {
                                ret._reject(maybePromise._reason());
                            }
                        } else {
                            callbacks[i].call(ret, maybePromise, holder);
                        }
                    }
                    return ret;
                }
            }
        }
        var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
        if (fn) args.pop();
        var ret = new PromiseArray(args).promise();
        return fn !== undefined ? ret.spread(fn) : ret;
    };
    
    };
    
  provide("bluebird/js/main/join.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/map.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              PromiseArray,
                              apiRejection,
                              tryConvertToPromise,
                              INTERNAL) {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var PENDING = {};
    var EMPTY_ARRAY = [];
    
    function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        this._callback = fn;
        this._preservedValues = _filter === INTERNAL
            ? new Array(this.length())
            : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
        async.invoke(init, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);
    function init() {this._init$(undefined, -2);}
    
    MappingPromiseArray.prototype._init = function () {};
    
    MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (values[index] === PENDING) {
            values[index] = value;
            if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved()) return;
            }
        } else {
            if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return;
            }
            if (preservedValues !== null) preservedValues[index] = value;
    
            var callback = this._callback;
            var receiver = this._promise._boundTo;
            this._promise._pushContext();
            var ret = tryCatch(callback).call(receiver, value, index, length);
            this._promise._popContext();
            if (ret === errorObj) return this._reject(ret.e);
    
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = PENDING;
                    return maybePromise._proxyPromiseArray(this, index);
                } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                } else {
                    return this._reject(maybePromise._reason());
                }
            }
            values[index] = ret;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
            if (preservedValues !== null) {
                this._filter(values, preservedValues);
            } else {
                this._resolve(values);
            }
    
        }
    };
    
    MappingPromiseArray.prototype._drainQueue = function () {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
            if (this._isResolved()) return;
            var index = queue.pop();
            this._promiseFulfilled(values[index], index);
        }
    };
    
    MappingPromiseArray.prototype._filter = function (booleans, values) {
        var len = values.length;
        var ret = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
            if (booleans[i]) ret[j++] = values[i];
        }
        ret.length = j;
        this._resolve(ret);
    };
    
    MappingPromiseArray.prototype.preservedValues = function () {
        return this._preservedValues;
    };
    
    function map(promises, fn, options, _filter) {
        var limit = typeof options === "object" && options !== null
            ? options.concurrency
            : 0;
        limit = typeof limit === "number" &&
            isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter);
    }
    
    Promise.prototype.map = function (fn, options) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    
        return map(this, fn, options, null).promise();
    };
    
    Promise.map = function (promises, fn, options, _filter) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        return map(promises, fn, options, _filter).promise();
    };
    
    
    };
    
  provide("bluebird/js/main/map.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/cancel.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var errors =  require('bluebird/js/main/errors.js');
    var async =  require('bluebird/js/main/async.js');
    var CancellationError = errors.CancellationError;
    
    Promise.prototype._cancel = function (reason) {
        if (!this.isCancellable()) return this;
        var parent;
        var promiseToReject = this;
        while ((parent = promiseToReject._cancellationParent) !== undefined &&
            parent.isCancellable()) {
            promiseToReject = parent;
        }
        this._unsetCancellable();
        promiseToReject._target()._rejectCallback(reason, false, true);
    };
    
    Promise.prototype.cancel = function (reason) {
        if (!this.isCancellable()) return this;
        if (reason === undefined) reason = new CancellationError();
        async.invokeLater(this._cancel, this, reason);
        return this;
    };
    
    Promise.prototype.cancellable = function () {
        if (this._cancellable()) return this;
        async.enableTrampoline();
        this._setCancellable();
        this._cancellationParent = undefined;
        return this;
    };
    
    Promise.prototype.uncancellable = function () {
        var ret = this.then();
        ret._unsetCancellable();
        return ret;
    };
    
    Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
        var ret = this._then(didFulfill, didReject, didProgress,
                             undefined, undefined);
    
        ret._setCancellable();
        ret._cancellationParent = undefined;
        return ret;
    };
    };
    
  provide("bluebird/js/main/cancel.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/using.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function (Promise, apiRejection, tryConvertToPromise,
        createContext) {
        var TypeError =  require('bluebird/js/main/errors.js').TypeError;
        var inherits =  require('bluebird/js/main/util.js').inherits;
        var PromiseInspection = Promise.PromiseInspection;
    
        function inspectionMapper(inspections) {
            var len = inspections.length;
            for (var i = 0; i < len; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                    return Promise.reject(inspection.error());
                }
                inspections[i] = inspection._settledValue;
            }
            return inspections;
        }
    
        function thrower(e) {
            setTimeout(function(){throw e;}, 0);
        }
    
        function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable &&
                typeof thenable._isDisposable === "function" &&
                typeof thenable._getDisposer === "function" &&
                thenable._isDisposable()) {
                maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
        }
        function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret = Promise.defer();
            function iterator() {
                if (i >= len) return ret.resolve();
                var maybePromise = castPreservingDisposable(resources[i++]);
                if (maybePromise instanceof Promise &&
                    maybePromise._isDisposable()) {
                    try {
                        maybePromise = tryConvertToPromise(
                            maybePromise._getDisposer().tryDispose(inspection),
                            resources.promise);
                    } catch (e) {
                        return thrower(e);
                    }
                    if (maybePromise instanceof Promise) {
                        return maybePromise._then(iterator, thrower,
                                                  null, null, null);
                    }
                }
                iterator();
            }
            iterator();
            return ret.promise;
        }
    
        function disposerSuccess(value) {
            var inspection = new PromiseInspection();
            inspection._settledValue = value;
            inspection._bitField = 268435456;
            return dispose(this, inspection).thenReturn(value);
        }
    
        function disposerFail(reason) {
            var inspection = new PromiseInspection();
            inspection._settledValue = reason;
            inspection._bitField = 134217728;
            return dispose(this, inspection).thenThrow(reason);
        }
    
        function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
        }
    
        Disposer.prototype.data = function () {
            return this._data;
        };
    
        Disposer.prototype.promise = function () {
            return this._promise;
        };
    
        Disposer.prototype.resource = function () {
            if (this.promise().isFulfilled()) {
                return this.promise().value();
            }
            return null;
        };
    
        Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== undefined) context._pushContext();
            var ret = resource !== null
                ? this.doDispose(resource, inspection) : null;
            if (context !== undefined) context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret;
        };
    
        Disposer.isDisposer = function (d) {
            return (d != null &&
                    typeof d.resource === "function" &&
                    typeof d.tryDispose === "function");
        };
    
        function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
        }
        inherits(FunctionDisposer, Disposer);
    
        FunctionDisposer.prototype.doDispose = function (resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
        };
    
        function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
                this.resources[this.index]._setDisposable(value);
                return value.promise();
            }
            return value;
        }
    
        Promise.using = function () {
            var len = arguments.length;
            if (len < 2) return apiRejection(
                            "you must pass at least 2 arguments to Promise.using");
            var fn = arguments[len - 1];
            if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
            len--;
            var resources = new Array(len);
            for (var i = 0; i < len; ++i) {
                var resource = arguments[i];
                if (Disposer.isDisposer(resource)) {
                    var disposer = resource;
                    resource = resource.promise();
                    resource._setDisposable(disposer);
                } else {
                    var maybePromise = tryConvertToPromise(resource);
                    if (maybePromise instanceof Promise) {
                        resource =
                            maybePromise._then(maybeUnwrapDisposer, null, null, {
                                resources: resources,
                                index: i
                        }, undefined);
                    }
                }
                resources[i] = resource;
            }
    
            var promise = Promise.settle(resources)
                .then(inspectionMapper)
                .then(function(vals) {
                    promise._pushContext();
                    var ret;
                    try {
                        ret = fn.apply(undefined, vals);
                    } finally {
                        promise._popContext();
                    }
                    return ret;
                })
                ._then(
                    disposerSuccess, disposerFail, undefined, resources, undefined);
            resources.promise = promise;
            return promise;
        };
    
        Promise.prototype._setDisposable = function (disposer) {
            this._bitField = this._bitField | 262144;
            this._disposer = disposer;
        };
    
        Promise.prototype._isDisposable = function () {
            return (this._bitField & 262144) > 0;
        };
    
        Promise.prototype._getDisposer = function () {
            return this._disposer;
        };
    
        Promise.prototype._unsetDisposable = function () {
            this._bitField = this._bitField & (~262144);
            this._disposer = undefined;
        };
    
        Promise.prototype.disposer = function (fn) {
            if (typeof fn === "function") {
                return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError();
        };
    
    };
    
  provide("bluebird/js/main/using.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/generators.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              apiRejection,
                              INTERNAL,
                              tryConvertToPromise) {
    var errors =  require('bluebird/js/main/errors.js');
    var TypeError = errors.TypeError;
    var util =  require('bluebird/js/main/util.js');
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];
    
    function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
        for (var i = 0; i < yieldHandlers.length; ++i) {
            traceParent._pushContext();
            var result = tryCatch(yieldHandlers[i])(value);
            traceParent._popContext();
            if (result === errorObj) {
                traceParent._pushContext();
                var ret = Promise.reject(errorObj.e);
                traceParent._popContext();
                return ret;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
        }
        return null;
    }
    
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        var promise = this._promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = undefined;
        this._yieldHandlers = typeof yieldHandler === "function"
            ? [yieldHandler].concat(yieldHandlers)
            : yieldHandlers;
    }
    
    PromiseSpawn.prototype.promise = function () {
        return this._promise;
    };
    
    PromiseSpawn.prototype._run = function () {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver =
            this._generatorFunction = undefined;
        this._next(undefined);
    };
    
    PromiseSpawn.prototype._continue = function (result) {
        if (result === errorObj) {
            return this._promise._rejectCallback(result.e, false, true);
        }
    
        var value = result.value;
        if (result.done === true) {
            this._promise._resolveCallback(value);
        } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise)) {
                maybePromise =
                    promiseFromYieldHandler(maybePromise,
                                            this._yieldHandlers,
                                            this._promise);
                if (maybePromise === null) {
                    this._throw(
                        new TypeError(
                            "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
                            "From coroutine:\u000a" +
                            this._stack.split("\n").slice(1, -7).join("\n")
                        )
                    );
                    return;
                }
            }
            maybePromise._then(
                this._next,
                this._throw,
                undefined,
                this,
                null
           );
        }
    };
    
    PromiseSpawn.prototype._throw = function (reason) {
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch(this._generator["throw"])
            .call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
    };
    
    PromiseSpawn.prototype._next = function (value) {
        this._promise._pushContext();
        var result = tryCatch(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
    };
    
    Promise.coroutine = function (generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function () {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                          stack);
            spawn._generator = generator;
            spawn._next(undefined);
            return spawn.promise();
        };
    };
    
    Promise.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        yieldHandlers.push(fn);
    };
    
    Promise.spawn = function (generatorFunction) {
        if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret = spawn.promise();
        spawn._run(Promise.spawn);
        return ret;
    };
    };
    
  provide("bluebird/js/main/generators.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/nodeify.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    
    function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    
    function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundTo;
        var ret = val === undefined
            ? tryCatch(nodeback).call(receiver, null)
            : tryCatch(nodeback).call(receiver, null, val);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
            var target = promise._target();
            var newReason = target._getCarriedStackTrace();
            newReason.cause = reason;
            reason = newReason;
        }
        var ret = tryCatch(nodeback).call(promise._boundTo, reason);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    
    Promise.prototype.asCallback = 
    Promise.prototype.nodeify = function (nodeback, options) {
        if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options !== undefined && Object(options).spread) {
                adapter = spreadAdapter;
            }
            this._then(
                adapter,
                errorAdapter,
                undefined,
                this,
                nodeback
            );
        }
        return this;
    };
    };
    
  provide("bluebird/js/main/nodeify.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/call_get.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var cr = Object.create;
    if (cr) {
        var callerCache = cr(null);
        var getterCache = cr(null);
        callerCache[" size"] = getterCache[" size"] = 0;
    }
    
    module.exports = function(Promise) {
    var util =  require('bluebird/js/main/util.js');
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;
    
    var getMethodCaller;
    var getGetter;
    if (!false) {
    var makeMethodCaller = function (methodName) {
        return new Function("ensureMethod", "                                    \n\
            return function(obj) {                                               \n\
                'use strict'                                                     \n\
                var len = this.length;                                           \n\
                ensureMethod(obj, 'methodName');                                 \n\
                switch(len) {                                                    \n\
                    case 1: return obj.methodName(this[0]);                      \n\
                    case 2: return obj.methodName(this[0], this[1]);             \n\
                    case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                    case 0: return obj.methodName();                             \n\
                    default:                                                     \n\
                        return obj.methodName.apply(obj, this);                  \n\
                }                                                                \n\
            };                                                                   \n\
            ".replace(/methodName/g, methodName))(ensureMethod);
    };
    
    var makeGetter = function (propertyName) {
        return new Function("obj", "                                             \n\
            'use strict';                                                        \n\
            return obj.propertyName;                                             \n\
            ".replace("propertyName", propertyName));
    };
    
    var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
            if (!isIdentifier(name)) {
                return null;
            }
            ret = compiler(name);
            cache[name] = ret;
            cache[" size"]++;
            if (cache[" size"] > 512) {
                var keys = Object.keys(cache);
                for (var i = 0; i < 256; ++i) delete cache[keys[i]];
                cache[" size"] = keys.length - 256;
            }
        }
        return ret;
    };
    
    getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
    };
    
    getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
    };
    }
    
    function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null) fn = obj[methodName];
        if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" +
                util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
        }
        return fn;
    }
    
    function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
    }
    Promise.prototype.call = function (methodName) {
        var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
        if (!false) {
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                    return this._then(
                        maybeCaller, undefined, undefined, args, undefined);
                }
            }
        }
        args.push(methodName);
        return this._then(caller, undefined, undefined, args, undefined);
    };
    
    function namedGetter(obj) {
        return obj[this];
    }
    function indexedGetter(obj) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj.length);
        return obj[index];
    }
    Promise.prototype.get = function (propertyName) {
        var isIndex = (typeof propertyName === "number");
        var getter;
        if (!isIndex) {
            if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
                getter = namedGetter;
            }
        } else {
            getter = indexedGetter;
        }
        return this._then(getter, undefined, undefined, propertyName, undefined);
    };
    };
    
  provide("bluebird/js/main/call_get.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/props.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(
        Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var isObject = util.isObject;
    var es5 =  require('bluebird/js/main/es5.js');
    
    function PropertiesPromiseArray(obj) {
        var keys = es5.keys(obj);
        var len = keys.length;
        var values = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
            var key = keys[i];
            values[i] = obj[key];
            values[i + len] = key;
        }
        this.constructor$(values);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);
    
    PropertiesPromiseArray.prototype._init = function () {
        this._init$(undefined, -3) ;
    };
    
    PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            var val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
            this._resolve(val);
        }
    };
    
    PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
        this._promise._progress({
            key: this._values[index + this.length()],
            value: value
        });
    };
    
    PropertiesPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };
    
    PropertiesPromiseArray.prototype.getActualLength = function (len) {
        return len >> 1;
    };
    
    function props(promises) {
        var ret;
        var castValue = tryConvertToPromise(promises);
    
        if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
        } else if (castValue instanceof Promise) {
            ret = castValue._then(
                Promise.props, undefined, undefined, undefined, undefined);
        } else {
            ret = new PropertiesPromiseArray(castValue).promise();
        }
    
        if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 4);
        }
        return ret;
    }
    
    Promise.prototype.props = function () {
        return props(this);
    };
    
    Promise.props = function (promises) {
        return props(promises);
    };
    };
    
  provide("bluebird/js/main/props.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/race.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(
        Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var isArray =  require('bluebird/js/main/util.js').isArray;
    
    var raceLater = function (promise) {
        return promise.then(function(array) {
            return race(array, promise);
        });
    };
    
    function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
    
        if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
        } else if (!isArray(promises)) {
            return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
        }
    
        var ret = new Promise(INTERNAL);
        if (parent !== undefined) {
            ret._propagateFrom(parent, 4 | 1);
        }
        var fulfill = ret._fulfill;
        var reject = ret._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];
    
            if (val === undefined && !(i in promises)) {
                continue;
            }
    
            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
        }
        return ret;
    }
    
    Promise.race = function (promises) {
        return race(promises, undefined);
    };
    
    Promise.prototype.race = function () {
        return race(this, undefined);
    };
    
    };
    
  provide("bluebird/js/main/race.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/reduce.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise,
                              PromiseArray,
                              apiRejection,
                              tryConvertToPromise,
                              INTERNAL) {
    var async =  require('bluebird/js/main/async.js');
    var util =  require('bluebird/js/main/util.js');
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function ReductionPromiseArray(promises, fn, accum, _each) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        this._preservedValues = _each === INTERNAL ? [] : null;
        this._zerothIsAccum = (accum === undefined);
        this._gotAccum = false;
        this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
        this._valuesPhase = undefined;
        var maybePromise = tryConvertToPromise(accum, this._promise);
        var rejected = false;
        var isPromise = maybePromise instanceof Promise;
        if (isPromise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, -1);
            } else if (maybePromise._isFulfilled()) {
                accum = maybePromise._value();
                this._gotAccum = true;
            } else {
                this._reject(maybePromise._reason());
                rejected = true;
            }
        }
        if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
        this._callback = fn;
        this._accum = accum;
        if (!rejected) async.invoke(init, this, undefined);
    }
    function init() {
        this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);
    
    ReductionPromiseArray.prototype._init = function () {};
    
    ReductionPromiseArray.prototype._resolveEmptyArray = function () {
        if (this._gotAccum || this._zerothIsAccum) {
            this._resolve(this._preservedValues !== null
                            ? [] : this._accum);
        }
    };
    
    ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        values[index] = value;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var isEach = preservedValues !== null;
        var gotAccum = this._gotAccum;
        var valuesPhase = this._valuesPhase;
        var valuesPhaseIndex;
        if (!valuesPhase) {
            valuesPhase = this._valuesPhase = new Array(length);
            for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
                valuesPhase[valuesPhaseIndex] = 0;
            }
        }
        valuesPhaseIndex = valuesPhase[index];
    
        if (index === 0 && this._zerothIsAccum) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
            valuesPhase[index] = ((valuesPhaseIndex === 0)
                ? 1 : 2);
        } else if (index === -1) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
        } else {
            if (valuesPhaseIndex === 0) {
                valuesPhase[index] = 1;
            } else {
                valuesPhase[index] = 2;
                this._accum = value;
            }
        }
        if (!gotAccum) return;
    
        var callback = this._callback;
        var receiver = this._promise._boundTo;
        var ret;
    
        for (var i = this._reducingIndex; i < length; ++i) {
            valuesPhaseIndex = valuesPhase[i];
            if (valuesPhaseIndex === 2) {
                this._reducingIndex = i + 1;
                continue;
            }
            if (valuesPhaseIndex !== 1) return;
            value = values[i];
            this._promise._pushContext();
            if (isEach) {
                preservedValues.push(value);
                ret = tryCatch(callback).call(receiver, value, i, length);
            }
            else {
                ret = tryCatch(callback)
                    .call(receiver, this._accum, value, i, length);
            }
            this._promise._popContext();
    
            if (ret === errorObj) return this._reject(ret.e);
    
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                if (maybePromise._isPending()) {
                    valuesPhase[i] = 4;
                    return maybePromise._proxyPromiseArray(this, i);
                } else if (maybePromise._isFulfilled()) {
                    ret = maybePromise._value();
                } else {
                    return this._reject(maybePromise._reason());
                }
            }
    
            this._reducingIndex = i + 1;
            this._accum = ret;
        }
    
        this._resolve(isEach ? preservedValues : this._accum);
    };
    
    function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
    }
    
    Promise.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue, null);
    };
    
    Promise.reduce = function (promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
    };
    };
    
  provide("bluebird/js/main/reduce.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/settle.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
        function(Promise, PromiseArray) {
    var PromiseInspection = Promise.PromiseInspection;
    var util =  require('bluebird/js/main/util.js');
    
    function SettledPromiseArray(values) {
        this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);
    
    SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
        }
    };
    
    SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var ret = new PromiseInspection();
        ret._bitField = 268435456;
        ret._settledValue = value;
        this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
        var ret = new PromiseInspection();
        ret._bitField = 134217728;
        ret._settledValue = reason;
        this._promiseResolved(index, ret);
    };
    
    Promise.settle = function (promises) {
        return new SettledPromiseArray(promises).promise();
    };
    
    Promise.prototype.settle = function () {
        return new SettledPromiseArray(this).promise();
    };
    };
    
  provide("bluebird/js/main/settle.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/some.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports =
    function(Promise, PromiseArray, apiRejection) {
    var util =  require('bluebird/js/main/util.js');
    var RangeError =  require('bluebird/js/main/errors.js').RangeError;
    var AggregateError =  require('bluebird/js/main/errors.js').AggregateError;
    var isArray = util.isArray;
    
    
    function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);
    
    SomePromiseArray.prototype._init = function () {
        if (!this._initialized) {
            return;
        }
        if (this._howMany === 0) {
            this._resolve([]);
            return;
        }
        this._init$(undefined, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() &&
            isArrayResolved &&
            this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
        }
    };
    
    SomePromiseArray.prototype.init = function () {
        this._initialized = true;
        this._init();
    };
    
    SomePromiseArray.prototype.setUnwrap = function () {
        this._unwrap = true;
    };
    
    SomePromiseArray.prototype.howMany = function () {
        return this._howMany;
    };
    
    SomePromiseArray.prototype.setHowMany = function (count) {
        this._howMany = count;
    };
    
    SomePromiseArray.prototype._promiseFulfilled = function (value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
            } else {
                this._resolve(this._values);
            }
        }
    
    };
    SomePromiseArray.prototype._promiseRejected = function (reason) {
        this._addRejected(reason);
        if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for (var i = this.length(); i < this._values.length; ++i) {
                e.push(this._values[i]);
            }
            this._reject(e);
        }
    };
    
    SomePromiseArray.prototype._fulfilled = function () {
        return this._totalResolved;
    };
    
    SomePromiseArray.prototype._rejected = function () {
        return this._values.length - this.length();
    };
    
    SomePromiseArray.prototype._addRejected = function (reason) {
        this._values.push(reason);
    };
    
    SomePromiseArray.prototype._addFulfilled = function (value) {
        this._values[this._totalResolved++] = value;
    };
    
    SomePromiseArray.prototype._canPossiblyFulfill = function () {
        return this.length() - this._rejected();
    };
    
    SomePromiseArray.prototype._getRangeError = function (count) {
        var message = "Input array must contain at least " +
                this._howMany + " items but contains only " + count + " items";
        return new RangeError(message);
    };
    
    SomePromiseArray.prototype._resolveEmptyArray = function () {
        this._reject(this._getRangeError(0));
    };
    
    function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
        }
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(howMany);
        ret.init();
        return promise;
    }
    
    Promise.some = function (promises, howMany) {
        return some(promises, howMany);
    };
    
    Promise.prototype.some = function (howMany) {
        return some(this, howMany);
    };
    
    Promise._SomePromiseArray = SomePromiseArray;
    };
    
  provide("bluebird/js/main/some.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promisify.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var THIS = {};
    var util =  require('bluebird/js/main/util.js');
    var nodebackForPromise =  require('bluebird/js/main/promise_resolver.js')
        ._nodebackForPromise;
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError =  require('bluebird/js/main/errors').TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = {__isPromisified__: true};
    var noCopyPropsPattern =
        /^(?:length|name|arguments|caller|callee|prototype|__isPromisified__)$/;
    var defaultFilter = function(name, func) {
        return util.isIdentifier(name) &&
            name.charAt(0) !== "_" &&
            !util.isClass(func);
    };
    
    function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
    }
    
    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        }
        catch (e) {
            return false;
        }
    }
    
    function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                                defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
        for (var i = 0; i < ret.length; i += 2) {
            var key = ret[i];
            if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
                            .replace("%s", suffix));
                    }
                }
            }
        }
    }
    
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret = [];
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter
                ? true : defaultFilter(key, value, obj);
            if (typeof value === "function" &&
                !isPromisified(value) &&
                !hasPromisified(obj, key, suffix) &&
                filter(key, value, obj, passesDefaultFilter)) {
                ret.push(key, value);
            }
        }
        checkValid(ret, suffix, suffixRegexp);
        return ret;
    }
    
    var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
    };
    
    var makeNodePromisifiedEval;
    if (!false) {
    var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for(var i = likelyArgumentCount - 1; i >= min; --i) {
            ret.push(i);
        }
        for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret.push(i);
        }
        return ret;
    };
    
    var argumentSequence = function(argumentCount) {
        return util.filledRange(argumentCount, "_arg", "");
    };
    
    var parameterDeclaration = function(parameterCount) {
        return util.filledRange(
            Math.max(parameterCount, 3), "_arg", "");
    };
    
    var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
    };
    
    makeNodePromisifiedEval =
    function(callback, receiver, originalName, fn) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
    
        function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret;
            if (shouldProxyThis) {
                ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
                ret = receiver === undefined
                    ? "ret = callback({{args}}, nodeback); break;\n"
                    : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret.replace("{{args}}", args).replace(", ", comma);
        }
    
        function generateArgumentSwitchCase() {
            var ret = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
                ret += "case " + argumentOrder[i] +":" +
                    generateCallForArgumentCount(argumentOrder[i]);
            }
    
            ret += "                                                             \n\
            default:                                                             \n\
                var args = new Array(len + 1);                                   \n\
                var i = 0;                                                       \n\
                for (var i = 0; i < len; ++i) {                                  \n\
                   args[i] = arguments[i];                                       \n\
                }                                                                \n\
                args[i] = nodeback;                                              \n\
                [CodeForCall]                                                    \n\
                break;                                                           \n\
            ".replace("[CodeForCall]", (shouldProxyThis
                                    ? "ret = callback.apply(this, args);\n"
                                    : "ret = callback.apply(receiver, args);\n"));
            return ret;
        }
    
        var getFunctionCode = typeof callback === "string"
                                    ? ("this != null ? this['"+callback+"'] : fn")
                                    : "fn";
    
        return new Function("Promise",
                            "fn",
                            "receiver",
                            "withAppended",
                            "maybeWrapAsError",
                            "nodebackForPromise",
                            "tryCatch",
                            "errorObj",
                            "INTERNAL","'use strict';                            \n\
            var ret = function (Parameters) {                                    \n\
                'use strict';                                                    \n\
                var len = arguments.length;                                      \n\
                var promise = new Promise(INTERNAL);                             \n\
                promise._captureStackTrace();                                    \n\
                var nodeback = nodebackForPromise(promise);                      \n\
                var ret;                                                         \n\
                var callback = tryCatch([GetFunctionCode]);                      \n\
                switch(len) {                                                    \n\
                    [CodeForSwitchCase]                                          \n\
                }                                                                \n\
                if (ret === errorObj) {                                          \n\
                    promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
                }                                                                \n\
                return promise;                                                  \n\
            };                                                                   \n\
            ret.__isPromisified__ = true;                                        \n\
            return ret;                                                          \n\
            "
            .replace("Parameters", parameterDeclaration(newParameterCount))
            .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
            .replace("[GetFunctionCode]", getFunctionCode))(
                Promise,
                fn,
                receiver,
                withAppended,
                maybeWrapAsError,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                INTERNAL
            );
    };
    }
    
    function makeNodePromisifiedClosure(callback, receiver, _, fn) {
        var defaultThis = (function() {return this;})();
        var method = callback;
        if (typeof method === "string") {
            callback = fn;
        }
        function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis
                ? this[method] : callback;
            var fn = nodebackForPromise(promise);
            try {
                cb.apply(_receiver, withAppended(arguments, fn));
            } catch(e) {
                promise._rejectCallback(maybeWrapAsError(e), true, true);
            }
            return promise;
        }
        promisified.__isPromisified__ = true;
        return promisified;
    }
    
    var makeNodePromisified = canEvaluate
        ? makeNodePromisifiedEval
        : makeNodePromisifiedClosure;
    
    function promisifyAll(obj, suffix, filter, promisifier) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods =
            promisifiableMethods(obj, suffix, suffixRegexp, filter);
    
        for (var i = 0, len = methods.length; i < len; i+= 2) {
            var key = methods[i];
            var fn = methods[i+1];
            var promisifiedKey = key + suffix;
            obj[promisifiedKey] = promisifier === makeNodePromisified
                    ? makeNodePromisified(key, THIS, key, fn, suffix)
                    : promisifier(fn, function() {
                        return makeNodePromisified(key, THIS, key, fn, suffix);
                    });
        }
        util.toFastProperties(obj);
        return obj;
    }
    
    function promisify(callback, receiver) {
        return makeNodePromisified(callback, receiver, undefined, callback);
    }
    
    Promise.promisify = function (fn, receiver) {
        if (typeof fn !== "function") {
            throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        }
        if (isPromisified(fn)) {
            return fn;
        }
        var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
        util.copyDescriptors(fn, ret, propsFilter);
        return ret;
    };
    
    Promise.promisifyAll = function (target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
        }
        options = Object(options);
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function") filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;
    
        if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
        }
    
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
            var value = target[keys[i]];
            if (keys[i] !== "constructor" &&
                util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier);
                promisifyAll(value, suffix, filter, promisifier);
            }
        }
    
        return promisifyAll(target, suffix, filter, promisifier);
    };
    };
    
    
  provide("bluebird/js/main/promisify.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/any.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(1);
        ret.setUnwrap();
        ret.init();
        return promise;
    }
    
    Promise.any = function (promises) {
        return any(promises);
    };
    
    Promise.prototype.any = function () {
        return any(this);
    };
    
    };
    
  provide("bluebird/js/main/any.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/each.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce;
    
    Promise.prototype.each = function (fn) {
        return PromiseReduce(this, fn, null, INTERNAL);
    };
    
    Promise.each = function (promises, fn) {
        return PromiseReduce(promises, fn, null, INTERNAL);
    };
    };
    
  provide("bluebird/js/main/each.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/timers.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var util =  require('bluebird/js/main/util.js');
    var TimeoutError = Promise.TimeoutError;
    
    var afterTimeout = function (promise, message) {
        if (!promise.isPending()) return;
        if (typeof message !== "string") {
            message = "operation timed out";
        }
        var err = new TimeoutError(message);
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._cancel(err);
    };
    
    var afterValue = function(value) { return delay(+this).thenReturn(value); };
    var delay = Promise.delay = function (value, ms) {
        if (ms === undefined) {
            ms = value;
            value = undefined;
            var ret = new Promise(INTERNAL);
            setTimeout(function() { ret._fulfill(); }, ms);
            return ret;
        }
        ms = +ms;
        return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
    };
    
    Promise.prototype.delay = function (ms) {
        return delay(this, ms);
    };
    
    function successClear(value) {
        var handle = this;
        if (handle instanceof Number) handle = +handle;
        clearTimeout(handle);
        return value;
    }
    
    function failureClear(reason) {
        var handle = this;
        if (handle instanceof Number) handle = +handle;
        clearTimeout(handle);
        throw reason;
    }
    
    Promise.prototype.timeout = function (ms, message) {
        ms = +ms;
        var ret = this.then().cancellable();
        ret._cancellationParent = this;
        var handle = setTimeout(function timeoutTimeout() {
            afterTimeout(ret, message);
        }, ms);
        return ret._then(successClear, failureClear, undefined, handle, undefined);
    };
    
    };
    
  provide("bluebird/js/main/timers.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/filter.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function(Promise, INTERNAL) {
    var PromiseMap = Promise.map;
    
    Promise.prototype.filter = function (fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
    };
    
    Promise.filter = function (promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
    };
    };
    
  provide("bluebird/js/main/filter.js", module.exports);
}(global));

// pakmanager:bluebird/js/main/promise.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    module.exports = function() {
    var makeSelfResolutionError = function () {
        return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
    };
    var reflect = function() {
        return new Promise.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
        return Promise.reject(new TypeError(msg));
    };
    var util =  require('bluebird/js/main/util.js');
    var async =  require('bluebird/js/main/async.js');
    var errors =  require('bluebird/js/main/errors.js');
    var TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError;
    Promise.OperationalError = errors.OperationalError;
    Promise.RejectionError = errors.OperationalError;
    Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function(){};
    var APPLY = {};
    var NEXT_FILTER = {e: null};
    var tryConvertToPromise =  require('bluebird/js/main/thenables.js')(Promise, INTERNAL);
    var PromiseArray =
         require('bluebird/js/main/promise_array.js')(Promise, INTERNAL,
                                        tryConvertToPromise, apiRejection);
    var CapturedTrace =  require('bluebird/js/main/captured_trace.js')();
    var isDebugging =  require('bluebird/js/main/debuggability.js')(Promise, CapturedTrace);
     /*jshint unused:false*/
    var createContext =
         require('bluebird/js/main/context.js')(Promise, CapturedTrace, isDebugging);
    var CatchFilter =  require('bluebird/js/main/catch_filter.js')(NEXT_FILTER);
    var PromiseResolver =  require('bluebird/js/main/promise_resolver.js');
    var nodebackForPromise = PromiseResolver._nodebackForPromise;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function Promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
        }
        if (this.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = undefined;
        this._rejectionHandler0 = undefined;
        this._progressHandler0 = undefined;
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._settledValue = undefined;
        if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
    }
    
    Promise.prototype.toString = function () {
        return "[object Promise]";
    };
    
    Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
        var len = arguments.length;
        if (len > 1) {
            var catchInstances = new Array(len - 1),
                j = 0, i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (typeof item === "function") {
                    catchInstances[j++] = item;
                } else {
                    return Promise.reject(
                        new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
                }
            }
            catchInstances.length = j;
            fn = arguments[i];
            var catchFilter = new CatchFilter(catchInstances, fn, this);
            return this._then(undefined, catchFilter.doFilter, undefined,
                catchFilter, undefined);
        }
        return this._then(undefined, fn, undefined, undefined, undefined);
    };
    
    Promise.prototype.reflect = function () {
        return this._then(reflect, reflect, undefined, this, undefined);
    };
    
    Promise.prototype.then = function (didFulfill, didReject, didProgress) {
        if (isDebugging() && arguments.length > 0 &&
            typeof didFulfill !== "function" &&
            typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " +
                    util.classString(didFulfill);
            if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
            }
            this._warn(msg);
        }
        return this._then(didFulfill, didReject, didProgress,
            undefined, undefined);
    };
    
    Promise.prototype.done = function (didFulfill, didReject, didProgress) {
        var promise = this._then(didFulfill, didReject, didProgress,
            undefined, undefined);
        promise._setIsFinal();
    };
    
    Promise.prototype.spread = function (didFulfill, didReject) {
        return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
    };
    
    Promise.prototype.isCancellable = function () {
        return !this.isResolved() &&
            this._cancellable();
    };
    
    Promise.prototype.toJSON = function () {
        var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
        };
        if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
        } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
        }
        return ret;
    };
    
    Promise.prototype.all = function () {
        return new PromiseArray(this).promise();
    };
    
    Promise.prototype.error = function (fn) {
        return this.caught(util.originatesFromRejection, fn);
    };
    
    Promise.is = function (val) {
        return val instanceof Promise;
    };
    
    Promise.fromNode = function(fn) {
        var ret = new Promise(INTERNAL);
        var result = tryCatch(fn)(nodebackForPromise(ret));
        if (result === errorObj) {
            ret._rejectCallback(result.e, true, true);
        }
        return ret;
    };
    
    Promise.all = function (promises) {
        return new PromiseArray(promises).promise();
    };
    
    Promise.defer = Promise.pending = function () {
        var promise = new Promise(INTERNAL);
        return new PromiseResolver(promise);
    };
    
    Promise.cast = function (obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise)) {
            var val = ret;
            ret = new Promise(INTERNAL);
            ret._fulfillUnchecked(val);
        }
        return ret;
    };
    
    Promise.resolve = Promise.fulfilled = Promise.cast;
    
    Promise.reject = Promise.rejected = function (reason) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
    };
    
    Promise.setScheduler = function(fn) {
        if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        var prev = async._schedule;
        async._schedule = fn;
        return prev;
    };
    
    Promise.prototype._then = function (
        didFulfill,
        didReject,
        didProgress,
        receiver,
        internalData
    ) {
        var haveInternalData = internalData !== undefined;
        var ret = haveInternalData ? internalData : new Promise(INTERNAL);
    
        if (!haveInternalData) {
            ret._propagateFrom(this, 4 | 1);
            ret._captureStackTrace();
        }
    
        var target = this._target();
        if (target !== this) {
            if (receiver === undefined) receiver = this._boundTo;
            if (!haveInternalData) ret._setIsMigrated();
        }
    
        var callbackIndex =
            target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);
    
        if (target._isResolved() && !target._isSettlePromisesQueued()) {
            async.invoke(
                target._settlePromiseAtPostResolution, target, callbackIndex);
        }
    
        return ret;
    };
    
    Promise.prototype._settlePromiseAtPostResolution = function (index) {
        if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
        this._settlePromiseAt(index);
    };
    
    Promise.prototype._length = function () {
        return this._bitField & 131071;
    };
    
    Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
        return (this._bitField & 939524096) > 0;
    };
    
    Promise.prototype._isFollowing = function () {
        return (this._bitField & 536870912) === 536870912;
    };
    
    Promise.prototype._setLength = function (len) {
        this._bitField = (this._bitField & -131072) |
            (len & 131071);
    };
    
    Promise.prototype._setFulfilled = function () {
        this._bitField = this._bitField | 268435456;
    };
    
    Promise.prototype._setRejected = function () {
        this._bitField = this._bitField | 134217728;
    };
    
    Promise.prototype._setFollowing = function () {
        this._bitField = this._bitField | 536870912;
    };
    
    Promise.prototype._setIsFinal = function () {
        this._bitField = this._bitField | 33554432;
    };
    
    Promise.prototype._isFinal = function () {
        return (this._bitField & 33554432) > 0;
    };
    
    Promise.prototype._cancellable = function () {
        return (this._bitField & 67108864) > 0;
    };
    
    Promise.prototype._setCancellable = function () {
        this._bitField = this._bitField | 67108864;
    };
    
    Promise.prototype._unsetCancellable = function () {
        this._bitField = this._bitField & (~67108864);
    };
    
    Promise.prototype._setIsMigrated = function () {
        this._bitField = this._bitField | 4194304;
    };
    
    Promise.prototype._unsetIsMigrated = function () {
        this._bitField = this._bitField & (~4194304);
    };
    
    Promise.prototype._isMigrated = function () {
        return (this._bitField & 4194304) > 0;
    };
    
    Promise.prototype._receiverAt = function (index) {
        var ret = index === 0
            ? this._receiver0
            : this[
                index * 5 - 5 + 4];
        if (ret === undefined && this._isBound()) {
            return this._boundTo;
        }
        return ret;
    };
    
    Promise.prototype._promiseAt = function (index) {
        return index === 0
            ? this._promise0
            : this[index * 5 - 5 + 3];
    };
    
    Promise.prototype._fulfillmentHandlerAt = function (index) {
        return index === 0
            ? this._fulfillmentHandler0
            : this[index * 5 - 5 + 0];
    };
    
    Promise.prototype._rejectionHandlerAt = function (index) {
        return index === 0
            ? this._rejectionHandler0
            : this[index * 5 - 5 + 1];
    };
    
    Promise.prototype._migrateCallbacks = function (follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var progress = follower._progressHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (promise instanceof Promise) promise._setIsMigrated();
        this._addCallbacks(fulfill, reject, progress, promise, receiver);
    };
    
    Promise.prototype._addCallbacks = function (
        fulfill,
        reject,
        progress,
        promise,
        receiver
    ) {
        var index = this._length();
    
        if (index >= 131071 - 5) {
            index = 0;
            this._setLength(0);
        }
    
        if (index === 0) {
            this._promise0 = promise;
            if (receiver !== undefined) this._receiver0 = receiver;
            if (typeof fulfill === "function" && !this._isCarryingStackTrace())
                this._fulfillmentHandler0 = fulfill;
            if (typeof reject === "function") this._rejectionHandler0 = reject;
            if (typeof progress === "function") this._progressHandler0 = progress;
        } else {
            var base = index * 5 - 5;
            this[base + 3] = promise;
            this[base + 4] = receiver;
            if (typeof fulfill === "function")
                this[base + 0] = fulfill;
            if (typeof reject === "function")
                this[base + 1] = reject;
            if (typeof progress === "function")
                this[base + 2] = progress;
        }
        this._setLength(index + 1);
        return index;
    };
    
    Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
        var index = this._length();
    
        if (index >= 131071 - 5) {
            index = 0;
            this._setLength(0);
        }
        if (index === 0) {
            this._promise0 = promiseSlotValue;
            this._receiver0 = receiver;
        } else {
            var base = index * 5 - 5;
            this[base + 3] = promiseSlotValue;
            this[base + 4] = receiver;
        }
        this._setLength(index + 1);
    };
    
    Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
        this._setProxyHandlers(promiseArray, index);
    };
    
    Promise.prototype._resolveCallback = function(value, shouldBind) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        if (value === this)
            return this._rejectCallback(makeSelfResolutionError(), false, true);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise)) return this._fulfill(value);
    
        var propagationFlags = 1 | (shouldBind ? 4 : 0);
        this._propagateFrom(maybePromise, propagationFlags);
        var promise = maybePromise._target();
        if (promise._isPending()) {
            var len = this._length();
            for (var i = 0; i < len; ++i) {
                promise._migrateCallbacks(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
        } else if (promise._isFulfilled()) {
            this._fulfillUnchecked(promise._value());
        } else {
            this._rejectUnchecked(promise._reason(),
                promise._getCarriedStackTrace());
        }
    };
    
    Promise.prototype._rejectCallback =
    function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
        if (!shouldNotMarkOriginatingFromRejection) {
            util.markAsOriginatingFromRejection(reason);
        }
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason, hasStack ? undefined : trace);
    };
    
    Promise.prototype._resolveFromResolver = function (resolver) {
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = tryCatch(resolver)(function(value) {
            if (promise === null) return;
            promise._resolveCallback(value);
            promise = null;
        }, function (reason) {
            if (promise === null) return;
            promise._rejectCallback(reason, synchronous);
            promise = null;
        });
        synchronous = false;
        this._popContext();
    
        if (r !== undefined && r === errorObj && promise !== null) {
            promise._rejectCallback(r.e, true, true);
            promise = null;
        }
    };
    
    Promise.prototype._settlePromiseFromHandler = function (
        handler, receiver, value, promise
    ) {
        if (promise._isRejected()) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY && !this._isRejected()) {
            x = tryCatch(handler).apply(this._boundTo, value);
        } else {
            x = tryCatch(handler).call(receiver, value);
        }
        promise._popContext();
    
        if (x === errorObj || x === promise || x === NEXT_FILTER) {
            var err = x === promise ? makeSelfResolutionError() : x.e;
            promise._rejectCallback(err, false, true);
        } else {
            promise._resolveCallback(x);
        }
    };
    
    Promise.prototype._target = function() {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
    };
    
    Promise.prototype._followee = function() {
        return this._rejectionHandler0;
    };
    
    Promise.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
    };
    
    Promise.prototype._cleanValues = function () {
        if (this._cancellable()) {
            this._cancellationParent = undefined;
        }
    };
    
    Promise.prototype._propagateFrom = function (parent, flags) {
        if ((flags & 1) > 0 && parent._cancellable()) {
            this._setCancellable();
            this._cancellationParent = parent;
        }
        if ((flags & 4) > 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    };
    
    Promise.prototype._fulfill = function (value) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._fulfillUnchecked(value);
    };
    
    Promise.prototype._reject = function (reason, carriedStackTrace) {
        if (this._isFollowingOrFulfilledOrRejected()) return;
        this._rejectUnchecked(reason, carriedStackTrace);
    };
    
    Promise.prototype._settlePromiseAt = function (index) {
        var promise = this._promiseAt(index);
        var isPromise = promise instanceof Promise;
    
        if (isPromise && promise._isMigrated()) {
            promise._unsetIsMigrated();
            return async.invoke(this._settlePromiseAt, this, index);
        }
        var handler = this._isFulfilled()
            ? this._fulfillmentHandlerAt(index)
            : this._rejectionHandlerAt(index);
    
        var carriedStackTrace =
            this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
        var value = this._settledValue;
        var receiver = this._receiverAt(index);
    
    
        this._clearCallbackDataAtIndex(index);
    
        if (typeof handler === "function") {
            if (!isPromise) {
                handler.call(receiver, value, promise);
            } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (receiver instanceof PromiseArray) {
            if (!receiver._isResolved()) {
                if (this._isFulfilled()) {
                    receiver._promiseFulfilled(value, promise);
                }
                else {
                    receiver._promiseRejected(value, promise);
                }
            }
        } else if (isPromise) {
            if (this._isFulfilled()) {
                promise._fulfill(value);
            } else {
                promise._reject(value, carriedStackTrace);
            }
        }
    
        if (index >= 4 && (index & 31) === 4)
            async.invokeLater(this._setLength, this, 0);
    };
    
    Promise.prototype._clearCallbackDataAtIndex = function(index) {
        if (index === 0) {
            if (!this._isCarryingStackTrace()) {
                this._fulfillmentHandler0 = undefined;
            }
            this._rejectionHandler0 =
            this._progressHandler0 =
            this._receiver0 =
            this._promise0 = undefined;
        } else {
            var base = index * 5 - 5;
            this[base + 3] =
            this[base + 4] =
            this[base + 0] =
            this[base + 1] =
            this[base + 2] = undefined;
        }
    };
    
    Promise.prototype._isSettlePromisesQueued = function () {
        return (this._bitField &
                -1073741824) === -1073741824;
    };
    
    Promise.prototype._setSettlePromisesQueued = function () {
        this._bitField = this._bitField | -1073741824;
    };
    
    Promise.prototype._unsetSettlePromisesQueued = function () {
        this._bitField = this._bitField & (~-1073741824);
    };
    
    Promise.prototype._queueSettlePromises = function() {
        async.settlePromises(this);
        this._setSettlePromisesQueued();
    };
    
    Promise.prototype._fulfillUnchecked = function (value) {
        if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._rejectUnchecked(err, undefined);
        }
        this._setFulfilled();
        this._settledValue = value;
        this._cleanValues();
    
        if (this._length() > 0) {
            this._queueSettlePromises();
        }
    };
    
    Promise.prototype._rejectUncheckedCheckError = function (reason) {
        var trace = util.ensureErrorObject(reason);
        this._rejectUnchecked(reason, trace === reason ? undefined : trace);
    };
    
    Promise.prototype._rejectUnchecked = function (reason, trace) {
        if (reason === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._rejectUnchecked(err);
        }
        this._setRejected();
        this._settledValue = reason;
        this._cleanValues();
    
        if (this._isFinal()) {
            async.throwLater(function(e) {
                if ("stack" in e) {
                    async.invokeFirst(
                        CapturedTrace.unhandledRejection, undefined, e);
                }
                throw e;
            }, trace === undefined ? reason : trace);
            return;
        }
    
        if (trace !== undefined && trace !== reason) {
            this._setCarriedStackTrace(trace);
        }
    
        if (this._length() > 0) {
            this._queueSettlePromises();
        } else {
            this._ensurePossibleRejectionHandled();
        }
    };
    
    Promise.prototype._settlePromises = function () {
        this._unsetSettlePromisesQueued();
        var len = this._length();
        for (var i = 0; i < len; i++) {
            this._settlePromiseAt(i);
        }
    };
    
    Promise._makeSelfResolutionError = makeSelfResolutionError;
     require('bluebird/js/main/progress.js')(Promise, PromiseArray);
     require('bluebird/js/main/method.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/bind.js')(Promise, INTERNAL, tryConvertToPromise);
     require('bluebird/js/main/finally.js')(Promise, NEXT_FILTER, tryConvertToPromise);
     require('bluebird/js/main/direct_resolve.js')(Promise);
     require('bluebird/js/main/synchronous_inspection.js')(Promise);
     require('bluebird/js/main/join.js')(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
    Promise.Promise = Promise;
     require('bluebird/js/main/map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
     require('bluebird/js/main/cancel.js')(Promise);
     require('bluebird/js/main/using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
     require('bluebird/js/main/generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
     require('bluebird/js/main/nodeify.js')(Promise);
     require('bluebird/js/main/call_get.js')(Promise);
     require('bluebird/js/main/props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
     require('bluebird/js/main/reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
     require('bluebird/js/main/settle.js')(Promise, PromiseArray);
     require('bluebird/js/main/some.js')(Promise, PromiseArray, apiRejection);
     require('bluebird/js/main/promisify.js')(Promise, INTERNAL);
     require('bluebird/js/main/any.js')(Promise);
     require('bluebird/js/main/each.js')(Promise, INTERNAL);
     require('bluebird/js/main/timers.js')(Promise, INTERNAL);
     require('bluebird/js/main/filter.js')(Promise, INTERNAL);
                                                             
        util.toFastProperties(Promise);                                          
        util.toFastProperties(Promise.prototype);                                
        function fillTypes(value) {                                              
            var p = new Promise(INTERNAL);                                       
            p._fulfillmentHandler0 = value;                                      
            p._rejectionHandler0 = value;                                        
            p._progressHandler0 = value;                                         
            p._promise0 = value;                                                 
            p._receiver0 = value;                                                
            p._settledValue = value;                                             
        }                                                                        
        // Complete slack tracking, opt out of field-type tracking and           
        // stabilize map                                                         
        fillTypes({a: 1});                                                       
        fillTypes({b: 2});                                                       
        fillTypes({c: 3});                                                       
        fillTypes(1);                                                            
        fillTypes(function(){});                                                 
        fillTypes(undefined);                                                    
        fillTypes(false);                                                        
        fillTypes(new Promise(INTERNAL));                                        
        CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
        return Promise;                                                          
    
    };
    
  provide("bluebird/js/main/promise.js", module.exports);
}(global));

// pakmanager:bluebird
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    var old;
    if (typeof Promise !== "undefined") old = Promise;
    function noConflict() {
        try { if (Promise === bluebird) Promise = old; }
        catch (e) {}
        return bluebird;
    }
    var bluebird =  require('bluebird/js/main/promise.js')();
    bluebird.noConflict = noConflict;
    module.exports = bluebird;
    
  provide("bluebird", module.exports);
}(global));

// pakmanager:chalk
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var escapeStringRegexp = require('escape-string-regexp');
    var ansiStyles = require('ansi-styles');
    var stripAnsi = require('strip-ansi');
    var hasAnsi = require('has-ansi');
    var supportsColor = require('supports-color');
    var defineProps = Object.defineProperties;
    
    function Chalk(options) {
    	// detect mode if not set manually
    	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
    }
    
    // use bright blue on Windows as the normal blue color is illegible
    if (process.platform === 'win32') {
    	ansiStyles.blue.open = '\u001b[94m';
    }
    
    function build(_styles) {
    	var builder = function builder() {
    		return applyStyle.apply(builder, arguments);
    	};
    	builder._styles = _styles;
    	builder.enabled = this.enabled;
    	// __proto__ is used because we must return a function, but there is
    	// no way to create a function with a different prototype.
    	builder.__proto__ = proto;
    	return builder;
    }
    
    var styles = (function () {
    	var ret = {};
    
    	Object.keys(ansiStyles).forEach(function (key) {
    		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    
    		ret[key] = {
    			get: function () {
    				return build.call(this, this._styles.concat(key));
    			}
    		};
    	});
    
    	return ret;
    })();
    
    var proto = defineProps(function chalk() {}, styles);
    
    function applyStyle() {
    	// support varags, but simply cast to string in case there's only one arg
    	var args = arguments;
    	var argsLen = args.length;
    	var str = argsLen !== 0 && String(arguments[0]);
    	if (argsLen > 1) {
    		// don't slice `arguments`, it prevents v8 optimizations
    		for (var a = 1; a < argsLen; a++) {
    			str += ' ' + args[a];
    		}
    	}
    
    	if (!this.enabled || !str) {
    		return str;
    	}
    
    	/*jshint validthis: true */
    	var nestedStyles = this._styles;
    
    	var i = nestedStyles.length;
    	while (i--) {
    		var code = ansiStyles[nestedStyles[i]];
    		// Replace any instances already present with a re-opening code
    		// otherwise only the part of the string until said closing code
    		// will be colored, and the rest will simply be 'plain'.
    		str = code.open + str.replace(code.closeRe, code.open) + code.close;
    	}
    
    	return str;
    }
    
    function init() {
    	var ret = {};
    
    	Object.keys(styles).forEach(function (name) {
    		ret[name] = {
    			get: function () {
    				return build.call(this, [name]);
    			}
    		};
    	});
    
    	return ret;
    }
    
    defineProps(Chalk.prototype, init());
    
    module.exports = new Chalk();
    module.exports.styles = ansiStyles;
    module.exports.hasColor = hasAnsi;
    module.exports.stripColor = stripAnsi;
    module.exports.supportsColor = supportsColor;
    
  provide("chalk", module.exports);
}(global));

// pakmanager:create-error
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //     create-error.js 0.3.1
    //     (c) 2013 Tim Griesser
    //     This source may be freely distributed under the MIT license.
    (function(factory) {
    
    "use strict";
    
    // A simple utility for subclassing the "Error"
    // object in multiple environments, while maintaining
    // relevant stack traces, messages, and prototypes.
    factory(function() {
    
    var toString = Object.prototype.toString;
    
    // Creates an new error type with a "name",
    // and any additional properties that should be set
    // on the error instance.
    return function() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; ++i) {
        args[i] = arguments[i];
      }
      var name       = getName(args);
      var target     = getTarget(args);
      var properties = getProps(args);
      function ErrorCtor(message, obj) {
        attachProps(this, properties);
        attachProps(this, obj);
        this.message = (message || this.message);
        if (message instanceof Error) {
          this.message = message.message;
          this.stack = message.stack;
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      function Err() { this.constructor = ErrorCtor; }
      Err.prototype = target['prototype'];
      ErrorCtor.prototype = new Err();
      ErrorCtor.prototype.name = ('' + name) || 'CustomError';
      return ErrorCtor;
    };
    
    // Just a few helpers to clean up the function above
    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers
    function getName(args) {
      if (args.length === 0) return '';
      return isError(args[0]) ? (args[1] || '') : args[0];
    }
    function getTarget(args) {
      if (args.length === 0) return Error;
      return isError(args[0]) ? args[0] : Error;
    }
    function getProps(args) {
      if (args.length === 0) return null;
      return isError(args[0]) ? args[2] : args[1];
    }
    function inheritedKeys(obj) {
      var ret = [];
      for (var key in obj) {
        ret.push(key);
      }
      return ret;
    }
    
    // Right now we're just assuming that a function in the first argument is an error.
    function isError(obj) {
      return (typeof obj === "function");
    }
    
    // We don't need the full underscore check here, since it should either be
    // an object-literal, or nothing at all.
    function isObject(obj) {
      return (obj && typeof obj === "object" && toString.call(obj) === "[object Object]");
    }
    
    // Used to attach attributes to the error object in the constructor.
    function attachProps(context, target) {
      if (isObject(target)) {
        var keys = inheritedKeys(target);
        for (var i = 0, l = keys.length; i < l; ++i) {
          context[keys[i]] = clone(target[keys[i]]);
        }
      }
    }
    
    // Don't need the full-out "clone" mechanism here, since if you're
    // trying to set things other than empty arrays/objects on your
    // sub-classed `Error` object, you're probably doing it wrong.
    function clone(target) {
      if (target == null || typeof target !== "object") return target;
      var cloned = target.constructor ? target.constructor() : Object.create(null);
      for (var attr in target) {
        if (target.hasOwnProperty(attr)) {
          cloned[attr] = target[attr];
        }
      }
      return cloned;
    }
    
    });
    
    // Boilerplate UMD definition block...
    })(function(createErrorLib) {
      if (typeof define === "function" && define.amd) {
        define(createErrorLib);
      } else if (typeof exports === 'object') {
        module.exports = createErrorLib();
      } else {
        var root = this;
        var lastcreateError = root.createError;
        var createError = root.createError = createErrorLib();
        createError.noConflict = function() {
          root.createError = lastcreateError;
          return createError;
        };
      }
    });
    
  provide("create-error", module.exports);
}(global));

// pakmanager:inflection
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * inflection
     * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
     * MIT Licensed
     *
     * @fileoverview
     * A port of inflection-js to node.js module.
     */
    
    ( function ( root, factory ){
      if( typeof define === 'function' && define.amd ){
        define([], factory );
      }else if( typeof exports === 'object' ){
        module.exports = factory();
      }else{
        root.inflection = factory();
      }
    }( this, function (){
    
      /**
       * @description This is a list of nouns that use the same form for both singular and plural.
       *              This list should remain entirely in lower case to correctly match Strings.
       * @private
       */
      var uncountable_words = [
        // 'access',
        'accommodation',
        'adulthood',
        'advertising',
        'advice',
        'aggression',
        'aid',
        'air',
        'aircraft',
        'alcohol',
        'anger',
        'applause',
        'arithmetic',
        // 'art',
        'assistance',
        'athletics',
        // 'attention',
    
        'bacon',
        'baggage',
        // 'ballet',
        // 'beauty',
        'beef',
        // 'beer',
        // 'behavior',
        'biology',
        // 'billiards',
        'blood',
        'botany',
        // 'bowels',
        'bread',
        // 'business',
        'butter',
    
        'carbon',
        'cardboard',
        'cash',
        'chalk',
        'chaos',
        'chess',
        'crossroads',
        'countryside',
    
        // 'damage',
        'dancing',
        // 'danger',
        'deer',
        // 'delight',
        // 'dessert',
        'dignity',
        'dirt',
        // 'distribution',
        'dust',
    
        'economics',
        'education',
        'electricity',
        // 'employment',
        // 'energy',
        'engineering',
        'enjoyment',
        // 'entertainment',
        'envy',
        'equipment',
        'ethics',
        'evidence',
        'evolution',
    
        // 'failure',
        // 'faith',
        'fame',
        'fiction',
        // 'fish',
        'flour',
        'flu',
        'food',
        // 'freedom',
        // 'fruit',
        'fuel',
        'fun',
        // 'funeral',
        'furniture',
    
        'gallows',
        'garbage',
        'garlic',
        // 'gas',
        'genetics',
        // 'glass',
        'gold',
        'golf',
        'gossip',
        'grammar',
        // 'grass',
        'gratitude',
        'grief',
        // 'ground',
        'guilt',
        'gymnastics',
    
        // 'hair',
        'happiness',
        'hardware',
        'harm',
        'hate',
        'hatred',
        'health',
        'heat',
        // 'height',
        'help',
        'homework',
        'honesty',
        'honey',
        'hospitality',
        'housework',
        'humour',
        'hunger',
        'hydrogen',
    
        'ice',
        'importance',
        'inflation',
        'information',
        // 'injustice',
        'innocence',
        // 'intelligence',
        'iron',
        'irony',
    
        'jam',
        // 'jealousy',
        // 'jelly',
        'jewelry',
        // 'joy',
        'judo',
        // 'juice',
        // 'justice',
    
        'karate',
        // 'kindness',
        'knowledge',
    
        // 'labour',
        'lack',
        // 'land',
        'laughter',
        'lava',
        'leather',
        'leisure',
        'lightning',
        'linguine',
        'linguini',
        'linguistics',
        'literature',
        'litter',
        'livestock',
        'logic',
        'loneliness',
        // 'love',
        'luck',
        'luggage',
    
        'macaroni',
        'machinery',
        'magic',
        // 'mail',
        'management',
        'mankind',
        'marble',
        'mathematics',
        'mayonnaise',
        'measles',
        // 'meat',
        // 'metal',
        'methane',
        'milk',
        'money',
        // 'moose',
        'mud',
        'music',
        'mumps',
    
        'nature',
        'news',
        'nitrogen',
        'nonsense',
        'nurture',
        'nutrition',
    
        'obedience',
        'obesity',
        // 'oil',
        'oxygen',
    
        // 'paper',
        // 'passion',
        'pasta',
        'patience',
        // 'permission',
        'physics',
        'poetry',
        'pollution',
        'poverty',
        // 'power',
        'pride',
        // 'production',
        // 'progress',
        // 'pronunciation',
        'psychology',
        'publicity',
        'punctuation',
    
        // 'quality',
        // 'quantity',
        'quartz',
    
        'racism',
        // 'rain',
        // 'recreation',
        'relaxation',
        'reliability',
        'research',
        'respect',
        'revenge',
        'rice',
        'rubbish',
        'rum',
    
        'safety',
        // 'salad',
        // 'salt',
        // 'sand',
        // 'satire',
        'scenery',
        'seafood',
        'seaside',
        'series',
        'shame',
        'sheep',
        'shopping',
        // 'silence',
        'sleep',
        // 'slang'
        'smoke',
        'smoking',
        'snow',
        'soap',
        'software',
        'soil',
        // 'sorrow',
        // 'soup',
        'spaghetti',
        // 'speed',
        'species',
        // 'spelling',
        // 'sport',
        'steam',
        // 'strength',
        'stuff',
        'stupidity',
        // 'success',
        // 'sugar',
        'sunshine',
        'symmetry',
    
        // 'tea',
        'tennis',
        'thirst',
        'thunder',
        'timber',
        // 'time',
        // 'toast',
        // 'tolerance',
        // 'trade',
        'traffic',
        'transportation',
        // 'travel',
        'trust',
    
        // 'understanding',
        'underwear',
        'unemployment',
        'unity',
        // 'usage',
    
        'validity',
        'veal',
        'vegetation',
        'vegetarianism',
        'vengeance',
        'violence',
        // 'vision',
        'vitality',
    
        'warmth',
        // 'water',
        'wealth',
        'weather',
        // 'weight',
        'welfare',
        'wheat',
        // 'whiskey',
        // 'width',
        'wildlife',
        // 'wine',
        'wisdom',
        // 'wood',
        // 'wool',
        // 'work',
    
        // 'yeast',
        'yoga',
    
        'zinc',
        'zoology'
      ];
    
      /**
       * @description These rules translate from the singular form of a noun to its plural form.
       * @private
       */
    
      var regex = {
        plural : {
          men       : new RegExp( '^(m|wom)en$'             , 'gi' ),
          people    : new RegExp( '(pe)ople$'               , 'gi' ),
          children  : new RegExp( '(child)ren$'             , 'gi' ),
          tia       : new RegExp( '([ti])a$'                , 'gi' ),
          analyses  : new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ),
          hives     : new RegExp( '(hi|ti)ves$'             , 'gi' ),
          curves    : new RegExp( '(curve)s$'               , 'gi' ),
          lrves     : new RegExp( '([lr])ves$'              , 'gi' ),
          foves     : new RegExp( '([^fo])ves$'             , 'gi' ),
          movies    : new RegExp( '(m)ovies$'               , 'gi' ),
          aeiouyies : new RegExp( '([^aeiouy]|qu)ies$'      , 'gi' ),
          series    : new RegExp( '(s)eries$'               , 'gi' ),
          xes       : new RegExp( '(x|ch|ss|sh)es$'         , 'gi' ),
          mice      : new RegExp( '([m|l])ice$'             , 'gi' ),
          buses     : new RegExp( '(bus)es$'                , 'gi' ),
          oes       : new RegExp( '(o)es$'                  , 'gi' ),
          shoes     : new RegExp( '(shoe)s$'                , 'gi' ),
          crises    : new RegExp( '(cris|ax|test)es$'       , 'gi' ),
          octopi    : new RegExp( '(octop|vir)i$'           , 'gi' ),
          aliases   : new RegExp( '(alias|canvas|status)es$', 'gi' ),
          summonses : new RegExp( '^(summons)es$'           , 'gi' ),
          oxen      : new RegExp( '^(ox)en'                 , 'gi' ),
          matrices  : new RegExp( '(matr)ices$'             , 'gi' ),
          vertices  : new RegExp( '(vert|ind)ices$'         , 'gi' ),
          feet      : new RegExp( '^feet$'                  , 'gi' ),
          teeth     : new RegExp( '^teeth$'                 , 'gi' ),
          geese     : new RegExp( '^geese$'                 , 'gi' ),
          quizzes   : new RegExp( '(quiz)zes$'              , 'gi' ),
          whereases : new RegExp( '^(whereas)es$'           , 'gi' ),
          ss        : new RegExp( 'ss$'                     , 'gi' ),
          s         : new RegExp( 's$'                      , 'gi' )
        },
    
        singular : {
          man     : new RegExp( '^(m|wom)an$'           , 'gi' ),
          person  : new RegExp( '(pe)rson$'             , 'gi' ),
          child   : new RegExp( '(child)$'              , 'gi' ),
          ox      : new RegExp( '^(ox)$'                , 'gi' ),
          axis    : new RegExp( '(ax|test)is$'          , 'gi' ),
          octopus : new RegExp( '(octop|vir)us$'        , 'gi' ),
          alias   : new RegExp( '(alias|status|canvas)$', 'gi' ),
          summons : new RegExp( '^(summons)$'           , 'gi' ),
          bus     : new RegExp( '(bu)s$'                , 'gi' ),
          buffalo : new RegExp( '(buffal|tomat|potat)o$', 'gi' ),
          tium    : new RegExp( '([ti])um$'             , 'gi' ),
          sis     : new RegExp( 'sis$'                  , 'gi' ),
          ffe     : new RegExp( '(?:([^f])fe|([lr])f)$' , 'gi' ),
          hive    : new RegExp( '(hi|ti)ve$'            , 'gi' ),
          aeiouyy : new RegExp( '([^aeiouy]|qu)y$'      , 'gi' ),
          x       : new RegExp( '(x|ch|ss|sh)$'         , 'gi' ),
          matrix  : new RegExp( '(matr)ix$'             , 'gi' ),
          vertex  : new RegExp( '(vert|ind)ex$'         , 'gi' ),
          mouse   : new RegExp( '([m|l])ouse$'          , 'gi' ),
          foot    : new RegExp( '^foot$'                , 'gi' ),
          tooth   : new RegExp( '^tooth$'               , 'gi' ),
          goose   : new RegExp( '^goose$'               , 'gi' ),
          quiz    : new RegExp( '(quiz)$'               , 'gi' ),
          whereas : new RegExp( '^(whereas)$'           , 'gi' ),
          s       : new RegExp( 's$'                    , 'gi' ),
          common  : new RegExp( '$'                     , 'gi' )
        }
      };
    
      var plural_rules = [
    
        // do not replace if its already a plural word
        [ regex.plural.men       ],
        [ regex.plural.people    ],
        [ regex.plural.children  ],
        [ regex.plural.tia       ],
        [ regex.plural.analyses  ],
        [ regex.plural.hives     ],
        [ regex.plural.curves    ],
        [ regex.plural.lrves     ],
        [ regex.plural.foves     ],
        [ regex.plural.aeiouyies ],
        [ regex.plural.series    ],
        [ regex.plural.movies    ],
        [ regex.plural.xes       ],
        [ regex.plural.mice      ],
        [ regex.plural.buses     ],
        [ regex.plural.oes       ],
        [ regex.plural.shoes     ],
        [ regex.plural.crises    ],
        [ regex.plural.octopi    ],
        [ regex.plural.aliases   ],
        [ regex.plural.summonses ],
        [ regex.plural.oxen      ],
        [ regex.plural.matrices  ],
        [ regex.plural.feet      ],
        [ regex.plural.teeth     ],
        [ regex.plural.geese     ],
        [ regex.plural.quizzes   ],
        [ regex.plural.whereases ],
    
        // original rule
        [ regex.singular.man    , '$1en' ],
        [ regex.singular.person , '$1ople' ],
        [ regex.singular.child  , '$1ren' ],
        [ regex.singular.ox     , '$1en' ],
        [ regex.singular.axis   , '$1es' ],
        [ regex.singular.octopus, '$1i' ],
        [ regex.singular.alias  , '$1es' ],
        [ regex.singular.summons, '$1es' ],
        [ regex.singular.bus    , '$1ses' ],
        [ regex.singular.buffalo, '$1oes' ],
        [ regex.singular.tium   , '$1a' ],
        [ regex.singular.sis    , 'ses' ],
        [ regex.singular.ffe    , '$1$2ves' ],
        [ regex.singular.hive   , '$1ves' ],
        [ regex.singular.aeiouyy, '$1ies' ],
        [ regex.singular.matrix , '$1ices' ],
        [ regex.singular.vertex , '$1ices' ],
        [ regex.singular.x      , '$1es' ],
        [ regex.singular.mouse  , '$1ice' ],
        [ regex.singular.foot   , 'feet' ],
        [ regex.singular.tooth  , 'teeth' ],
        [ regex.singular.goose  , 'geese' ],
        [ regex.singular.quiz   , '$1zes' ],
        [ regex.singular.whereas, '$1es' ],
    
        [ regex.singular.s     , 's' ],
        [ regex.singular.common, 's' ]
      ];
    
      /**
       * @description These rules translate from the plural form of a noun to its singular form.
       * @private
       */
      var singular_rules = [
    
        // do not replace if its already a singular word
        [ regex.singular.man     ],
        [ regex.singular.person  ],
        [ regex.singular.child   ],
        [ regex.singular.ox      ],
        [ regex.singular.axis    ],
        [ regex.singular.octopus ],
        [ regex.singular.alias   ],
        [ regex.singular.summons ],
        [ regex.singular.bus     ],
        [ regex.singular.buffalo ],
        [ regex.singular.tium    ],
        [ regex.singular.sis     ],
        [ regex.singular.ffe     ],
        [ regex.singular.hive    ],
        [ regex.singular.aeiouyy ],
        [ regex.singular.x       ],
        [ regex.singular.matrix  ],
        [ regex.singular.mouse   ],
        [ regex.singular.foot    ],
        [ regex.singular.tooth   ],
        [ regex.singular.goose   ],
        [ regex.singular.quiz    ],
        [ regex.singular.whereas ],
    
        // original rule
        [ regex.plural.men      , '$1an' ],
        [ regex.plural.people   , '$1rson' ],
        [ regex.plural.children , '$1' ],
        [ regex.plural.tia      , '$1um' ],
        [ regex.plural.analyses , '$1$2sis' ],
        [ regex.plural.hives    , '$1ve' ],
        [ regex.plural.curves   , '$1' ],
        [ regex.plural.lrves    , '$1f' ],
        [ regex.plural.foves    , '$1fe' ],
        [ regex.plural.movies   , '$1ovie' ],
        [ regex.plural.aeiouyies, '$1y' ],
        [ regex.plural.series   , '$1eries' ],
        [ regex.plural.xes      , '$1' ],
        [ regex.plural.mice     , '$1ouse' ],
        [ regex.plural.buses    , '$1' ],
        [ regex.plural.oes      , '$1' ],
        [ regex.plural.shoes    , '$1' ],
        [ regex.plural.crises   , '$1is' ],
        [ regex.plural.octopi   , '$1us' ],
        [ regex.plural.aliases  , '$1' ],
        [ regex.plural.summonses, '$1' ],
        [ regex.plural.oxen     , '$1' ],
        [ regex.plural.matrices , '$1ix' ],
        [ regex.plural.vertices , '$1ex' ],
        [ regex.plural.feet     , 'foot' ],
        [ regex.plural.teeth    , 'tooth' ],
        [ regex.plural.geese    , 'goose' ],
        [ regex.plural.quizzes  , '$1' ],
        [ regex.plural.whereases, '$1' ],
    
        [ regex.plural.ss, 'ss' ],
        [ regex.plural.s , '' ]
      ];
    
      /**
       * @description This is a list of words that should not be capitalized for title case.
       * @private
       */
      var non_titlecased_words = [
        'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
        'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
      ];
    
      /**
       * @description These are regular expressions used for converting between String formats.
       * @private
       */
      var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
      var underbar          = new RegExp( '_', 'g' );
      var space_or_underbar = new RegExp( '[\ _]', 'g' );
      var uppercase         = new RegExp( '([A-Z])', 'g' );
      var underbar_prefix   = new RegExp( '^_' );
    
      var inflector = {
    
      /**
       * A helper method that applies rules based replacement to a String.
       * @private
       * @function
       * @param {String} str String to modify and return based on the passed rules.
       * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
       * @param {Array: [String]} skip Strings to skip if they match
       * @param {String} override String to return as though this method succeeded (used to conform to APIs)
       * @returns {String} Return passed String modified by passed rules.
       * @example
       *
       *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
       */
        _apply_rules : function ( str, rules, skip, override ){
          if( override ){
            str = override;
          }else{
            var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );
    
            if( !ignore ){
              var i = 0;
              var j = rules.length;
    
              for( ; i < j; i++ ){
                if( str.match( rules[ i ][ 0 ])){
                  if( rules[ i ][ 1 ] !== undefined ){
                    str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
                  }
                  break;
                }
              }
            }
          }
    
          return str;
        },
    
    
    
      /**
       * This lets us detect if an Array contains a given element.
       * @public
       * @function
       * @param {Array} arr The subject array.
       * @param {Object} item Object to locate in the Array.
       * @param {Number} from_index Starts checking from this position in the Array.(optional)
       * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
       * @returns {Number} Return index position in the Array of the passed item.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
       *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
       */
        indexOf : function ( arr, item, from_index, compare_func ){
          if( !from_index ){
            from_index = -1;
          }
    
          var index = -1;
          var i     = from_index;
          var j     = arr.length;
    
          for( ; i < j; i++ ){
            if( arr[ i ]  === item || compare_func && compare_func( arr[ i ], item )){
              index = i;
              break;
            }
          }
    
          return index;
        },
    
    
    
      /**
       * This function adds pluralization support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @param {String} plural Overrides normal output with said String.(optional)
       * @returns {String} Singular English language nouns are returned in plural form.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.pluralize( 'person' ); // === 'people'
       *     inflection.pluralize( 'octopus' ); // === 'octopi'
       *     inflection.pluralize( 'Hat' ); // === 'Hats'
       *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
       */
        pluralize : function ( str, plural ){
          return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
        },
    
    
    
      /**
       * This function adds singularization support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @param {String} singular Overrides normal output with said String.(optional)
       * @returns {String} Plural English language nouns are returned in singular form.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.singularize( 'people' ); // === 'person'
       *     inflection.singularize( 'octopi' ); // === 'octopus'
       *     inflection.singularize( 'Hats' ); // === 'Hat'
       *     inflection.singularize( 'guys', 'person' ); // === 'person'
       */
        singularize : function ( str, singular ){
          return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
        },
    
    
      /**
       * This function will pluralize or singularlize a String appropriately based on an integer value
       * @public
       * @function
       * @param {String} str The subject string.
       * @param {Number} count The number to base pluralization off of.
       * @param {String} singular Overrides normal output with said String.(optional)
       * @param {String} plural Overrides normal output with said String.(optional)
       * @returns {String} English language nouns are returned in the plural or singular form based on the count.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.inflect( 'people' 1 ); // === 'person'
       *     inflection.inflect( 'octopi' 1 ); // === 'octopus'
       *     inflection.inflect( 'Hats' 1 ); // === 'Hat'
       *     inflection.inflect( 'guys', 1 , 'person' ); // === 'person'
       *     inflection.inflect( 'person', 2 ); // === 'people'
       *     inflection.inflect( 'octopus', 2 ); // === 'octopi'
       *     inflection.inflect( 'Hat', 2 ); // === 'Hats'
       *     inflection.inflect( 'person', 2, null, 'guys' ); // === 'guys'
       */
        inflect : function ( str, count, singular, plural ){
          count = parseInt( count, 10 );
    
          if( isNaN( count )) return str;
    
          if( count === 0 || count > 1 ){
            return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
          }else{
            return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
          }
        },
    
    
    
      /**
       * This function adds camelization support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
       *                                 Passing true will lowercase it.
       * @returns {String} Lower case underscored words will be returned in camel case.
       *                  additionally '/' is translated to '::'
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
       *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
       */
        camelize : function ( str, low_first_letter ){
          var str_path = str.split( '/' );
          var i        = 0;
          var j        = str_path.length;
          var str_arr, init_x, k, l, first;
    
          for( ; i < j; i++ ){
            str_arr = str_path[ i ].split( '_' );
            k       = 0;
            l       = str_arr.length;
    
            for( ; k < l; k++ ){
              if( k !== 0 ){
                str_arr[ k ] = str_arr[ k ].toLowerCase();
              }
    
              first = str_arr[ k ].charAt( 0 );
              first = low_first_letter && i === 0 && k === 0
                ? first.toLowerCase() : first.toUpperCase();
              str_arr[ k ] = first + str_arr[ k ].substring( 1 );
            }
    
            str_path[ i ] = str_arr.join( '' );
          }
    
          return str_path.join( '::' );
        },
    
    
    
      /**
       * This function adds underscore support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
       *                  Passing true will return as entered.
       * @returns {String} Camel cased words are returned as lower cased and underscored.
       *                  additionally '::' is translated to '/'.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
       *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
       *     inflection.underscore( 'MP', true ); // === 'MP'
       */
        underscore : function ( str, all_upper_case ){
          if( all_upper_case && str === str.toUpperCase()) return str;
    
          var str_path = str.split( '::' );
          var i        = 0;
          var j        = str_path.length;
    
          for( ; i < j; i++ ){
            str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
            str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
          }
    
          return str_path.join( '/' ).toLowerCase();
        },
    
    
    
      /**
       * This function adds humanize support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
       *                                 Passing true will lowercase it.
       * @returns {String} Lower case underscored words will be returned in humanized form.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.humanize( 'message_properties' ); // === 'Message properties'
       *     inflection.humanize( 'message_properties', true ); // === 'message properties'
       */
        humanize : function ( str, low_first_letter ){
          str = str.toLowerCase();
          str = str.replace( id_suffix, '' );
          str = str.replace( underbar, ' ' );
    
          if( !low_first_letter ){
            str = inflector.capitalize( str );
          }
    
          return str;
        },
    
    
    
      /**
       * This function adds capitalization support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @returns {String} All characters will be lower case and the first will be upper.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
       *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
       */
        capitalize : function ( str ){
          str = str.toLowerCase();
    
          return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
        },
    
    
    
      /**
       * This function replaces underscores with dashes in the string.
       * @public
       * @function
       * @param {String} str The subject string.
       * @returns {String} Replaces all spaces or underscores with dashes.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
       *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
       */
        dasherize : function ( str ){
          return str.replace( space_or_underbar, '-' );
        },
    
    
    
      /**
       * This function adds titleize support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @returns {String} Capitalizes words as you would for a book title.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
       *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
       */
        titleize : function ( str ){
          str         = str.toLowerCase().replace( underbar, ' ' );
          var str_arr = str.split( ' ' );
          var i       = 0;
          var j       = str_arr.length;
          var d, k, l;
    
          for( ; i < j; i++ ){
            d = str_arr[ i ].split( '-' );
            k = 0;
            l = d.length;
    
            for( ; k < l; k++){
              if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
                d[ k ] = inflector.capitalize( d[ k ]);
              }
            }
    
            str_arr[ i ] = d.join( '-' );
          }
    
          str = str_arr.join( ' ' );
          str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
    
          return str;
        },
    
    
    
      /**
       * This function adds demodulize support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @returns {String} Removes module names leaving only class names.(Ruby style)
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
       */
        demodulize : function ( str ){
          var str_arr = str.split( '::' );
    
          return str_arr[ str_arr.length - 1 ];
        },
    
    
    
      /**
       * This function adds tableize support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @returns {String} Return camel cased words into their underscored plural form.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
       */
        tableize : function ( str ){
          str = inflector.underscore( str );
          str = inflector.pluralize( str );
    
          return str;
        },
    
    
    
      /**
       * This function adds classification support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @returns {String} Underscored plural nouns become the camel cased singular form.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
       */
        classify : function ( str ){
          str = inflector.camelize( str );
          str = inflector.singularize( str );
    
          return str;
        },
    
    
    
      /**
       * This function adds foreign key support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
                                     you can pass true to skip it.(optional)
       * @returns {String} Underscored plural nouns become the camel cased singular form.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
       *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
       */
        foreign_key : function ( str, drop_id_ubar ){
          str = inflector.demodulize( str );
          str = inflector.underscore( str ) + (( drop_id_ubar ) ? ( '' ) : ( '_' )) + 'id';
    
          return str;
        },
    
    
    
      /**
       * This function adds ordinalize support to every String object.
       * @public
       * @function
       * @param {String} str The subject string.
       * @returns {String} Return all found numbers their sequence like '22nd'.
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
       */
        ordinalize : function ( str ){
          var str_arr = str.split( ' ' );
          var i       = 0;
          var j       = str_arr.length;
    
          for( ; i < j; i++ ){
            var k = parseInt( str_arr[ i ], 10 );
    
            if( !isNaN( k )){
              var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
              var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
              var suf = 'th';
    
              if( ltd != '11' && ltd != '12' && ltd != '13' ){
                if( ld === '1' ){
                  suf = 'st';
                }else if( ld === '2' ){
                  suf = 'nd';
                }else if( ld === '3' ){
                  suf = 'rd';
                }
              }
    
              str_arr[ i ] += suf;
            }
          }
    
          return str_arr.join( ' ' );
        },
    
      /**
       * This function performs multiple inflection methods on a string
       * @public
       * @function
       * @param {String} str The subject string.
       * @param {Array} arr An array of inflection methods.
       * @returns {String}
       * @example
       *
       *     var inflection =  require('inflection');
       *
       *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
       */
        transform : function ( str, arr ){
          var i = 0;
          var j = arr.length;
    
          for( ;i < j; i++ ){
            var method = arr[ i ];
    
            if( this.hasOwnProperty( method )){
              str = this[ method ]( str );
            }
          }
    
          return str;
        }
      };
    
    /**
     * @public
     */
      inflector.version = '1.7.1';
    
      return inflector;
    }));
    
  provide("inflection", module.exports);
}(global));

// pakmanager:lodash
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * @license
     * lodash 3.9.3 (Custom Build) <https://lodash.com/>
     * Build: `lodash modern -d -o ./index.js`
     * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    ;(function() {
    
      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined;
    
      /** Used as the semantic version number. */
      var VERSION = '3.9.3';
    
      /** Used to compose bitmasks for wrapper metadata. */
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
    
      /** Used as default options for `_.trunc`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
    
      /** Used to detect when a function becomes hot. */
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
    
      /** Used to indicate the type of lazy iteratees. */
      var LAZY_DROP_WHILE_FLAG = 0,
          LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
    
      /** Used as the `TypeError` message for "Functions" methods. */
      var FUNC_ERROR_TEXT = 'Expected a function';
    
      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';
    
      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
    
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
    
      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    
      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    
      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
    
      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    
      /**
       * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
       * In addition to special characters the forward slash is escaped to allow for
       * easier `eval` use and `Function` compilation.
       */
      var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
    
      /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
    
      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;
    
      /** Used to match [ES template delimiters](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components). */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    
      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;
    
      /** Used to detect hexadecimal string values. */
      var reHasHexPrefix = /^0[xX]/;
    
      /** Used to detect host constructors (Safari > 5). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
    
      /** Used to detect unsigned integer values. */
      var reIsUint = /^\d+$/;
    
      /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    
      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;
    
      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    
      /** Used to match words to create compound words. */
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
    
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
    
      /** Used to detect and test for whitespace. */
      var whitespace = (
        // Basic whitespace characters.
        ' \t\x0b\f\xa0\ufeff' +
    
        // Line terminators.
        '\n\r\u2028\u2029' +
    
        // Unicode category "Zs" space separators.
        '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
      );
    
      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
        'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
        'isFinite', 'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', 'window'
      ];
    
      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;
    
      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dateTag] = typedArrayTags[errorTag] =
      typedArrayTags[funcTag] = typedArrayTags[mapTag] =
      typedArrayTags[numberTag] = typedArrayTags[objectTag] =
      typedArrayTags[regexpTag] = typedArrayTags[setTag] =
      typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    
      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
      cloneableTags[dateTag] = cloneableTags[float32Tag] =
      cloneableTags[float64Tag] = cloneableTags[int8Tag] =
      cloneableTags[int16Tag] = cloneableTags[int32Tag] =
      cloneableTags[numberTag] = cloneableTags[objectTag] =
      cloneableTags[regexpTag] = cloneableTags[stringTag] =
      cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
      cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[mapTag] = cloneableTags[setTag] =
      cloneableTags[weakMapTag] = false;
    
      /** Used as an internal `_.debounce` options object by `_.throttle`. */
      var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
      };
    
      /** Used to map latin-1 supplementary letters to basic latin letters. */
      var deburredLetters = {
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss'
      };
    
      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
    
      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
    
      /** Used to determine if values are of the language type `Object`. */
      var objectTypes = {
        'function': true,
        'object': true
      };
    
      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      /** Detect free variable `exports`. */
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    
      /** Detect free variable `module`. */
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    
      /** Detect free variable `global` from Node.js. */
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    
      /** Detect free variable `self`. */
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
    
      /** Detect free variable `window`. */
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
    
      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    
      /**
       * Used as a reference to the global object.
       *
       * The `this` value is used if it's the global object to avoid Greasemonkey's
       * restricted `window` object, otherwise the `window` object is used.
       */
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * The base implementation of `compareAscending` which compares values and
       * sorts them in ascending order without guaranteeing a stable sort.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
    
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
    
          if ((value > other && !othIsNull) || !valIsReflexive ||
              (valIsNull && !othIsUndef && othIsReflexive) ||
              (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive ||
              (othIsNull && !valIsUndef && valIsReflexive) ||
              (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
    
      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for callback shorthands and `this` binding.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
    
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * The base implementation of `_.indexOf` without support for binary searches.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
    
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * The base implementation of `_.isFunction` without support for environments
       * with incorrect `typeof` results.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       */
      function baseIsFunction(value) {
        // Avoid a Chakra JIT bug in compatibility modes of IE 11.
        // See https://github.com/jashkenas/underscore/issues/1621 for more details.
        return typeof value == 'function' || false;
      }
    
      /**
       * Converts `value` to a string if it's not one. An empty string is returned
       * for `null` or `undefined` values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
      function baseToString(value) {
        if (typeof value == 'string') {
          return value;
        }
        return value == null ? '' : (value + '');
      }
    
      /**
       * Used by `_.trim` and `_.trimLeft` to get the index of the first character
       * of `string` that is not found in `chars`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @param {string} chars The characters to find.
       * @returns {number} Returns the index of the first character not found in `chars`.
       */
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
    
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
    
      /**
       * Used by `_.trim` and `_.trimRight` to get the index of the last character
       * of `string` that is not found in `chars`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @param {string} chars The characters to find.
       * @returns {number} Returns the index of the last character not found in `chars`.
       */
      function charsRightIndex(string, chars) {
        var index = string.length;
    
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
    
      /**
       * Used by `_.sortBy` to compare transformed elements of a collection and stable
       * sort them in ascending order.
       *
       * @private
       * @param {Object} object The object to compare to `other`.
       * @param {Object} other The object to compare to `object`.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
    
      /**
       * Used by `_.sortByOrder` to compare multiple properties of each element
       * in a collection and stable sort them in the following order:
       *
       * If `orders` is unspecified, sort in ascending order for all properties.
       * Otherwise, for each property, sort in ascending order if its corresponding value in
       * orders is true, and descending order if false.
       *
       * @private
       * @param {Object} object The object to compare to `other`.
       * @param {Object} other The object to compare to `object`.
       * @param {boolean[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
    
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            return result * (orders[index] ? 1 : -1);
          }
        }
        // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
        // that causes it, under certain circumstances, to provide the same value for
        // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
        // for more details.
        //
        // This also ensures a stable sort in V8 and other engines.
        // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
        return object.index - other.index;
      }
    
      /**
       * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
    
      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
    
      /**
       * Used by `_.template` to escape characters for inclusion in compiled
       * string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
    
      /**
       * Gets the index at which the first occurrence of `NaN` is found in `array`.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched `NaN`, else `-1`.
       */
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
    
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * Checks if `value` is object-like.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       */
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
    
      /**
       * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
       * character code is whitespace.
       *
       * @private
       * @param {number} charCode The character code to inspect.
       * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
       */
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
          (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
    
      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
    
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
    
      /**
       * An implementation of `_.uniq` optimized for sorted arrays without support
       * for callback shorthands and `this` binding.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The function invoked per iteration.
       * @returns {Array} Returns the new duplicate-value-free array.
       */
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
    
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
    
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
    
      /**
       * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the first non-whitespace character.
       */
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
    
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
    
      /**
       * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the last non-whitespace character.
       */
      function trimmedRightIndex(string) {
        var index = string.length;
    
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
    
      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * Create a new pristine `lodash` function using the given `context` object.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // using `context` to mock `Date#getTime` use in `_.now`
       * var mock = _.runInContext({
       *   'Date': function() {
       *     return { 'getTime': getTimeMock };
       *   }
       * });
       *
       * // or creating a suped-up `defer` in Node.js
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      function runInContext(context) {
        // Avoid issues with some ES3 environments that attempt to use values, named
        // after built-in constructors like `Object`, for the creation of literals.
        // ES5 clears this up by stating that literals must use built-in constructors.
        // See https://es5.github.io/#x11.1.5 for more details.
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
    
        /** Native constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
    
        /** Used for native method references. */
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
    
        /** Used to detect DOM support. */
        var document = (document = context.window) ? document.document : null;
    
        /** Used to resolve the decompiled source of functions. */
        var fnToString = Function.prototype.toString;
    
        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;
    
        /** Used to generate unique IDs. */
        var idCounter = 0;
    
        /**
         * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;
    
        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = context._;
    
        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          escapeRegExp(fnToString.call(hasOwnProperty))
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );
    
        /** Native method references. */
        var ArrayBuffer = getNative(context, 'ArrayBuffer'),
            bufferSlice = getNative(ArrayBuffer && new ArrayBuffer(0), 'slice'),
            ceil = Math.ceil,
            clearTimeout = context.clearTimeout,
            floor = Math.floor,
            getPrototypeOf = getNative(Object, 'getPrototypeOf'),
            parseFloat = context.parseFloat,
            push = arrayProto.push,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = getNative(context, 'Uint8Array'),
            WeakMap = getNative(context, 'WeakMap');
    
        /** Used to clone array buffers. */
        var Float64Array = (function() {
          // Safari 5 errors when using an array buffer to initialize a typed array
          // where the array buffer's `byteLength` is not a multiple of the typed
          // array's `BYTES_PER_ELEMENT`.
          try {
            var func = getNative(context, 'Float64Array'),
                result = new func(new ArrayBuffer(10), 0, 1) && func;
          } catch(e) {}
          return result || null;
        }());
    
        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeCreate = getNative(Object, 'create'),
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeNumIsFinite = getNative(Number, 'isFinite'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
    
        /** Used as references for `-Infinity` and `Infinity`. */
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
    
        /** Used as references for the maximum length and index of an array. */
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    
        /** Used as the size, in bytes, of each `Float64Array` element. */
        var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
    
        /**
         * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
         * of an array-like value.
         */
        var MAX_SAFE_INTEGER = 9007199254740991;
    
        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;
    
        /** Used to lookup unminified function names. */
        var realNames = {};
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a `lodash` object which wraps `value` to enable implicit chaining.
         * Methods that operate on and return arrays, collections, and functions can
         * be chained together. Methods that return a boolean or single value will
         * automatically end the chain returning the unwrapped value. Explicit chaining
         * may be enabled using `_.chain`. The execution of chained methods is lazy,
         * that is, execution is deferred until `_#value` is implicitly or explicitly
         * called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
         * fusion is an optimization that merges iteratees to avoid creating intermediate
         * arrays and reduce the number of iteratee executions.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
         * `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
         * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
         * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
         * and `where`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
         * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
         * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
         * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
         * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
         * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
         * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
         * `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
         * `memoize`, `merge`, `method`, `methodOf`, `mixin`, `negate`, `omit`, `once`,
         * `pairs`, `partial`, `partialRight`, `partition`, `pick`, `plant`, `pluck`,
         * `property`, `propertyOf`, `pull`, `pullAt`, `push`, `range`, `rearg`,
         * `reject`, `remove`, `rest`, `restParam`, `reverse`, `set`, `shuffle`,
         * `slice`, `sort`, `sortBy`, `sortByAll`, `sortByOrder`, `splice`, `spread`,
         * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,
         * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,
         * `unshift`, `unzip`, `unzipWith`, `values`, `valuesIn`, `where`, `without`,
         * `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
         * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
         * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `get`,
         * `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`, `inRange`, `isArguments`,
         * `isArray`, `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`,
         * `isFinite` `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
         * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
         * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `lt`, `lte`,
         * `max`, `min`, `noConflict`, `noop`, `now`, `pad`, `padLeft`, `padRight`,
         * `parseInt`, `pop`, `random`, `reduce`, `reduceRight`, `repeat`, `result`,
         * `runInContext`, `shift`, `size`, `snakeCase`, `some`, `sortedIndex`,
         * `sortedLastIndex`, `startCase`, `startsWith`, `sum`, `template`, `trim`,
         * `trimLeft`, `trimRight`, `trunc`, `unescape`, `uniqueId`, `value`, and `words`
         *
         * The wrapper method `sample` will return a wrapped value when `n` is provided,
         * otherwise an unwrapped value is returned.
         *
         * @name _
         * @constructor
         * @category Chain
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // returns an unwrapped value
         * wrapped.reduce(function(total, n) {
         *   return total + n;
         * });
         * // => 6
         *
         * // returns a wrapped value
         * var squares = wrapped.map(function(n) {
         *   return n * n;
         * });
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
    
        /**
         * The function whose prototype all chaining wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }
    
        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
         * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
         */
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
    
        /**
         * An object environment feature flags.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        var support = lodash.support = {};
    
        (function(x) {
          var Ctor = function() { this.x = x; },
              object = { '0': x, 'length': x },
              props = [];
    
          Ctor.prototype = { 'valueOf': x, 'y': x };
          for (var key in new Ctor) { props.push(key); }
    
          /**
           * Detect if the DOM is supported.
           *
           * @memberOf _.support
           * @type boolean
           */
          try {
            support.dom = document.createDocumentFragment().nodeType === 11;
          } catch(e) {
            support.dom = false;
          }
        }(1, 0));
    
        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB). Change the following template settings to use
         * alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        lodash.templateSettings = {
    
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'escape': reEscape,
    
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'evaluate': reEvaluate,
    
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'interpolate': reInterpolate,
    
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type string
           */
          'variable': '',
    
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type Object
           */
          'imports': {
    
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type Function
             */
            '_': lodash
          }
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = null;
          this.__dir__ = 1;
          this.__dropCount__ = 0;
          this.__filtered__ = false;
          this.__iteratees__ = null;
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = null;
        }
    
        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var actions = this.__actions__,
              iteratees = this.__iteratees__,
              views = this.__views__,
              result = new LazyWrapper(this.__wrapped__);
    
          result.__actions__ = actions ? arrayCopy(actions) : null;
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = views ? arrayCopy(views) : null;
          return result;
        }
    
        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
    
        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value();
          if (!isArray(array)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var dir = this.__dir__,
              isRight = dir < 0,
              view = getView(0, array.length, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              takeCount = nativeMin(length, this.__takeCount__),
              iteratees = this.__iteratees__,
              iterLength = iteratees ? iteratees.length : 0,
              resIndex = 0,
              result = [];
    
          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
    
            var iterIndex = -1,
                value = array[index];
    
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type;
    
              if (type == LAZY_DROP_WHILE_FLAG) {
                if (data.done && (isRight ? (index > data.index) : (index < data.index))) {
                  data.count = 0;
                  data.done = false;
                }
                data.index = index;
                if (!data.done) {
                  var limit = data.limit;
                  if (!(data.done = limit > -1 ? (data.count++ >= limit) : !iteratee(value))) {
                    continue outer;
                  }
                }
              } else {
                var computed = iteratee(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a cache object to store key/value pairs.
         *
         * @private
         * @static
         * @name Cache
         * @memberOf _.memoize
         */
        function MapCache() {
          this.__data__ = {};
        }
    
        /**
         * Removes `key` and its value from the cache.
         *
         * @private
         * @name delete
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
         */
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
    
        /**
         * Gets the cached value for `key`.
         *
         * @private
         * @name get
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the cached value.
         */
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
    
        /**
         * Checks if a cached value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
    
        /**
         * Sets `value` to `key` of the cache.
         *
         * @private
         * @name set
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to cache.
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache object.
         */
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         *
         * Creates a cache object to store unique values.
         *
         * @private
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var length = values ? values.length : 0;
    
          this.data = { 'hash': nativeCreate(null), 'set': new Set };
          while (length--) {
            this.push(values[length]);
          }
        }
    
        /**
         * Checks if `value` is in `cache` mimicking the return signature of
         * `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache to search.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
    
          return result ? 0 : -1;
        }
    
        /**
         * Adds `value` to the cache.
         *
         * @private
         * @name push
         * @memberOf SetCache
         * @param {*} value The value to cache.
         */
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
    
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
    
        /**
         * A specialized version of `_.forEach` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
    
        /**
         * A specialized version of `_.forEachRight` for arrays without support for
         * callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEachRight(array, iteratee) {
          var length = array.length;
    
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
    
        /**
         * A specialized version of `_.every` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
         * with one argument: (value).
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {*} Returns the extremum value.
         */
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
    
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
    
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.filter` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.map` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
    
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
    
        /**
         * A specialized version of `_.reduce` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initFromArray] Specify using the first element of `array`
         *  as the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
    
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
    
        /**
         * A specialized version of `_.reduceRight` for arrays without support for
         * callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initFromArray] Specify using the last element of `array`
         *  as the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
    
        /**
         * A specialized version of `_.some` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
    
        /**
         * A specialized version of `_.sum` for arrays without support for iteratees.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the sum.
         */
        function arraySum(array) {
          var length = array.length,
              result = 0;
    
          while (length--) {
            result += +array[length] || 0;
          }
          return result;
        }
    
        /**
         * Used by `_.defaults` to customize its `_.assign` use.
         *
         * @private
         * @param {*} objectValue The destination object property value.
         * @param {*} sourceValue The source object property value.
         * @returns {*} Returns the value to assign to the destination object.
         */
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
    
        /**
         * Used by `_.template` to customize its `_.assign` use.
         *
         * **Note:** This function is like `assignDefaults` except that it ignores
         * inherited property values when checking if a property is `undefined`.
         *
         * @private
         * @param {*} objectValue The destination object property value.
         * @param {*} sourceValue The source object property value.
         * @param {string} key The key associated with the object and source values.
         * @param {Object} object The destination object.
         * @returns {*} Returns the value to assign to the destination object.
         */
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key))
            ? sourceValue
            : objectValue;
        }
    
        /**
         * A specialized version of `_.assign` for customizing assigned values without
         * support for argument juggling, multiple sources, and `this` binding `customizer`
         * functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         */
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
    
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
    
            if ((result === result ? (result !== value) : (value === value)) ||
                (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
    
        /**
         * The base implementation of `_.assign` without support for argument juggling,
         * multiple sources, and `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return source == null
            ? object
            : baseCopy(source, keys(source), object);
        }
    
        /**
         * The base implementation of `_.at` without support for string collections
         * and individual key arguments.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {number[]|string[]} props The property names or indexes of elements to pick.
         * @returns {Array} Returns the new array of picked elements.
         */
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
    
          while(++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
    
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property names to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @returns {Object} Returns `object`.
         */
        function baseCopy(source, props, object) {
          object || (object = {});
    
          var index = -1,
              length = props.length;
    
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
    
        /**
         * The base implementation of `_.callback` which supports specifying the
         * number of arguments to provide to `func`.
         *
         * @private
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined
              ? func
              : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined
            ? property(func)
            : baseMatchesProperty(func, thisArg);
        }
    
        /**
         * The base implementation of `_.clone` without support for argument juggling
         * and `this` binding `customizer` functions.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The object `value` belongs to.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates clones with source counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
    
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag]
                ? initCloneByTag(value, tag, isDeep)
                : (object ? value : {});
            }
          }
          // Check for circular references and return corresponding clone.
          stackA || (stackA = []);
          stackB || (stackB = []);
    
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          // Add the source value to the stack of traversed objects and associate it with its clone.
          stackA.push(value);
          stackB.push(result);
    
          // Recursively populate clone (susceptible to call stack limits).
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
    
        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} prototype The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = null;
            }
            return result || {};
          };
        }());
    
        /**
         * The base implementation of `_.delay` and `_.defer` which accepts an index
         * of where to slice the arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Object} args The arguments provide to `func`.
         * @returns {number} Returns the timer id.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined, args); }, wait);
        }
    
        /**
         * The base implementation of `_.difference` which accepts a single array
         * of values to exclude.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
    
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= 200) ? createCache(values) : null,
              valuesLength = values.length;
    
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer:
          while (++index < length) {
            var value = array[index];
    
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.forEach` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object|string} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);
    
        /**
         * The base implementation of `_.forEachRight` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object|string} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);
    
        /**
         * The base implementation of `_.every` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
    
        /**
         * Gets the extremum value of `collection` invoking `iteratee` for each value
         * in `collection` to generate the criterion by which the value is ranked.
         * The `iteratee` is invoked with three arguments: (value, index|key, collection).
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
    
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;
    
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
    
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
    
        /**
         * The base implementation of `_.filter` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
         * without support for callback shorthands and `this` binding, which iterates
         * over `collection` using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @param {boolean} [retKey] Specify returning the key of the found element
         *  instead of the element itself.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.flatten` with added support for restricting
         * flattening and specifying the start index.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, isDeep, isStrict) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) &&
                (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                // Recursively flatten arrays (susceptible to call stack limits).
                value = baseFlatten(value, isDeep, isStrict);
              }
              var valIndex = -1,
                  valLength = value.length;
    
              while (++valIndex < valLength) {
                result[++resIndex] = value[valIndex];
              }
            } else if (!isStrict) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `baseForIn` and `baseForOwn` which iterates
         * over `object` properties returned by `keysFunc` invoking `iteratee` for
         * each property. Iteratee functions may exit iteration early by explicitly
         * returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();
    
        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);
    
        /**
         * The base implementation of `_.forIn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
    
        /**
         * The base implementation of `_.forOwn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
    
        /**
         * The base implementation of `_.forOwnRight` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
    
        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from those provided.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the new array of filtered property names.
         */
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `get` without support for string paths
         * and default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path of the property to get.
         * @param {string} [pathKey] The key representation of path.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          if (pathKey !== undefined && pathKey in toObject(object)) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
    
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
    
        /**
         * The base implementation of `_.isEqual` without support for `this` binding
         * `customizer` functions.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
    
        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA=[]] Tracks traversed `value` objects.
         * @param {Array} [stackB=[]] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
    
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
    
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
    
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          // Assume cyclic values are equal.
          // For more information on detecting circular references see https://es5.github.io/#JO.
          stackA || (stackA = []);
          stackB || (stackB = []);
    
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          // Add `object` and `other` to the stack of traversed objects.
          stackA.push(object);
          stackB.push(other);
    
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
    
          stackA.pop();
          stackB.pop();
    
          return result;
        }
    
        /**
         * The base implementation of `_.isMatch` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} matchData The propery names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
    
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
    
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
    
        /**
         * The base implementation of `_.map` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
    
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
    
        /**
         * The base implementation of `_.matches` which does not clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
    
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value && (value !== undefined || (key in toObject(object)));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
    
        /**
         * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to compare.
         * @returns {Function} Returns the new function.
         */
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
    
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue
              ? (srcValue !== undefined || (key in object))
              : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
    
        /**
         * The base implementation of `_.merge` without support for argument juggling,
         * multiple sources, and `this` binding `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} [customizer] The function to customize merging properties.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {Object} Returns `object`.
         */
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? null : keys(source);
    
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            }
            else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
    
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) &&
                  (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
    
        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize merging properties.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
    
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
    
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value)
                ? value
                : (isArrayLike(value) ? arrayCopy(value) : []);
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value)
                ? toPlainObject(value)
                : (isPlainObject(value) ? value : {});
            }
            else {
              isCommon = false;
            }
          }
          // Add the source value to the stack of traversed objects and associate
          // it with its merged value.
          stackA.push(srcValue);
          stackB.push(result);
    
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
    
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new function.
         */
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
    
        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         */
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
    
        /**
         * The base implementation of `_.pullAt` without support for individual
         * index arguments and capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
    
        /**
         * The base implementation of `_.random` without support for argument juggling
         * and returning floating-point numbers.
         *
         * @private
         * @param {number} min The minimum possible value.
         * @param {number} max The maximum possible value.
         * @returns {number} Returns the random number.
         */
        function baseRandom(min, max) {
          return min + floor(nativeRandom() * (max - min + 1));
        }
    
        /**
         * The base implementation of `_.reduce` and `_.reduceRight` without support
         * for callback shorthands and `this` binding, which iterates over `collection`
         * using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initFromCollection Specify using the first or last element
         *  of `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection
              ? (initFromCollection = false, value)
              : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
    
        /**
         * The base implementation of `setData` without support for hot loop detection.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
    
        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
    
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
    
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
    
        /**
         * The base implementation of `_.some` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          var result;
    
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
    
        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define
         * the sort order of `array` and replaces criteria objects with their
         * corresponding values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */
        function baseSortBy(array, comparer) {
          var length = array.length;
    
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
    
        /**
         * The base implementation of `_.sortByOrder` without param guards.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {boolean[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
    
          iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });
    
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });
    
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
    
        /**
         * The base implementation of `_.sum` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
    
        /**
         * The base implementation of `_.uniq` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate-value-free array.
         */
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= 200,
              seen = isLarge ? createCache() : null,
              result = [];
    
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
    
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
    
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
    
        /**
         * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
         * and `_.takeWhile` without support for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
    
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
    
        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to peform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
    
          while (++index < length) {
            var args = [result],
                action = actions[index];
    
            push.apply(args, action.args);
            result = action.func.apply(action.thisArg, args);
          }
          return result;
        }
    
        /**
         * Performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
    
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
    
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
    
        /**
         * This function is like `binaryIndex` except that it invokes `iteratee` for
         * `value` and each element of `array` to compute their sort ranking. The
         * iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
    
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
    
          while (low < high) {
            var mid = floor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
    
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
    
        /**
         * A specialized version of `baseCallback` which only supports `this` binding
         * and specifying the number of arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1: return function(value) {
              return func.call(thisArg, value);
            };
            case 3: return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
            case 4: return function(accumulator, value, index, collection) {
              return func.call(thisArg, accumulator, value, index, collection);
            };
            case 5: return function(value, other, key, object, source) {
              return func.call(thisArg, value, other, key, object, source);
            };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
    
        /**
         * Creates a clone of the given array buffer.
         *
         * @private
         * @param {ArrayBuffer} buffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function bufferClone(buffer) {
          return bufferSlice.call(buffer, 0);
        }
        if (!bufferSlice) {
          // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
          bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
            var byteLength = buffer.byteLength,
                floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
                offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
                result = new ArrayBuffer(byteLength);
    
            if (floatLength) {
              var view = new Float64Array(result, 0, floatLength);
              view.set(new Float64Array(buffer, 0, floatLength));
            }
            if (byteLength != offset) {
              view = new Uint8Array(result, offset);
              view.set(new Uint8Array(buffer, offset));
            }
            return result;
          };
        }
    
        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(argsLength + leftLength);
    
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
    
        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
    
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
    
        /**
         * Creates a function that aggregates a collection, creating an accumulator
         * object composed from the results of running each element in the collection
         * through an iteratee.
         *
         * **Note:** This function is used to create `_.countBy`, `_.groupBy`, `_.indexBy`,
         * and `_.partition`.
         *
         * @private
         * @param {Function} setter The function to set keys and values of the accumulator object.
         * @param {Function} [initializer] The function to initialize the accumulator object.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
    
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
    
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
    
        /**
         * Creates a function that assigns properties of source object(s) to a given
         * destination object.
         *
         * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
    
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
    
        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
    
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
    
        /**
         * Creates a base function for `_.forIn` or `_.forInRight`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
    
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with the `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new bound function.
         */
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
    
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
    
        /**
         * Creates a `Set` cache object to optimize linear searches of large arrays.
         *
         * @private
         * @param {Array} [values] The values to cache.
         * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
         */
        var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
          return new SetCache(values);
        };
    
        /**
         * Creates a function that produces compound words out of the words in a
         * given string.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
    
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
    
        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtorWrapper(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors.
            // See https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
    
            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }
    
        /**
         * Creates a `_.curry` or `_.curryRight` function.
         *
         * @private
         * @param {boolean} flag The curry bit flag.
         * @returns {Function} Returns the new curry function.
         */
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = null;
            }
            var result = createWrapper(func, flag, null, null, null, null, null, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
    
        /**
         * Creates a `_.max` or `_.min` function.
         *
         * @private
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {Function} Returns the new extremum function.
         */
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = null;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
    
        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
    
        /**
         * Creates a `_.findIndex` or `_.findLastIndex` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
    
        /**
         * Creates a `_.findKey` or `_.findLastKey` function.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new find function.
         */
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
    
        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
    
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([]);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
    
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : null;
    
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments;
              if (wrapper && args.length == 1 && isArray(args[0])) {
                return wrapper.plant(args[0]).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : args[0];
    
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
    
        /**
         * Creates a function for `_.forEach` or `_.forEachRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
              ? arrayFunc(collection, iteratee)
              : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
    
        /**
         * Creates a function for `_.forIn` or `_.forInRight`.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new each function.
         */
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
    
        /**
         * Creates a function for `_.forOwn` or `_.forOwnRight`.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new each function.
         */
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
    
        /**
         * Creates a function for `_.mapKeys` or `_.mapValues`.
         *
         * @private
         * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
         * @returns {Function} Returns the new map function.
         */
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
    
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
    
        /**
         * Creates a function for `_.padLeft` or `_.padRight`.
         *
         * @private
         * @param {boolean} [fromRight] Specify padding from the right.
         * @returns {Function} Returns the new pad function.
         */
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
    
        /**
         * Creates a `_.partial` or `_.partialRight` function.
         *
         * @private
         * @param {boolean} flag The partial bit flag.
         * @returns {Function} Returns the new partial function.
         */
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, null, partials, holders);
          });
          return partialFunc;
        }
    
        /**
         * Creates a function for `_.reduce` or `_.reduceRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
              ? arrayFunc(collection, iteratee, accumulator, initFromArray)
              : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with optional `this`
         * binding of, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? null : createCtorWrapper(func);
    
          function wrapper() {
            // Avoid `arguments` object use disqualifying optimizations by
            // converting it to an array before providing it to other functions.
            var length = arguments.length,
                index = length,
                args = Array(length);
    
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
    
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : null,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : null,
                    newHoldersRight = isCurry ? null : argsHolders,
                    newPartials = isCurry ? args : null,
                    newPartialsRight = isCurry ? null : args;
    
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
    
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
    
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
    
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
    
        /**
         * Creates the padding required for `string` based on the given `length`.
         * The `chars` string is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {string} string The string to create padding for.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the pad for `string`.
         */
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
    
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with the optional `this`
         * binding of `thisArg` and the `partials` prepended to those provided to
         * the wrapper.
         *
         * @private
         * @param {Function} func The function to partially apply arguments to.
         * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to the new function.
         * @returns {Function} Returns the new bound function.
         */
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
    
          function wrapper() {
            // Avoid `arguments` object use disqualifying optimizations by
            // converting it to an array before providing it `func`.
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(argsLength + leftLength);
    
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
    
        /**
         * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
         *
         * @private
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {Function} Returns the new index function.
         */
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback)
              ? binaryIndex(array, value, retHighest)
              : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
    
        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags.
         *  The bitmask may be composed of the following flags:
         *     1 - `_.bind`
         *     2 - `_.bindKey`
         *     4 - `_.curry` or `_.curryRight` of a bound function
         *     8 - `_.curry`
         *    16 - `_.curryRight`
         *    32 - `_.partial`
         *    64 - `_.partialRight`
         *   128 - `_.rearg`
         *   256 - `_.ary`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = null;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
    
            partials = holders = null;
          }
          var data = isBindKey ? null : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
    
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null
            ? (isBindKey ? 0 : func.length)
            : (nativeMax(arity - length, 0) || 0);
    
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing arrays.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
    
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
    
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                    return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                  })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} value The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              // Coerce dates and booleans to numbers, dates to milliseconds and booleans
              // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
              return +object == +other;
    
            case errorTag:
              return object.name == other.name && object.message == other.message;
    
            case numberTag:
              // Treat `NaN` vs. `NaN` as equal.
              return (object != +object)
                ? other != +other
                : object == +other;
    
            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings primitives and string
              // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
              return object == (other + '');
          }
          return false;
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
    
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;
    
            // Recursively compare objects (susceptible to call stack limits).
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
    
            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * Gets the appropriate "callback" function. If the `_.callback` method is
         * customized this function returns the custom method, otherwise it returns
         * the `baseCallback` function. If arguments are provided the chosen function
         * is invoked with them and its result is returned.
         *
         * @private
         * @returns {Function} Returns the chosen function or its result.
         */
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
    
        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
    
        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;
    
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
    
        /**
         * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
         * customized this function returns the custom method, otherwise it returns
         * the `baseIndexOf` function. If arguments are provided the chosen function
         * is invoked with them and its result is returned.
         *
         * @private
         * @returns {Function|number} Returns the chosen function or its result.
         */
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
    
        /**
         * Gets the "length" property value of `object`.
         *
         * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
         * that affects Safari on at least iOS 8.1-8.3 ARM64.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {*} Returns the "length" value.
         */
        var getLength = baseProperty('length');
    
        /**
         * Gets the propery names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
    
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
    
        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
    
        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} [transforms] The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms ? transforms.length : 0;
    
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
    
            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }
    
        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
    
          // Add array properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
    
        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
    
        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
    
            case boolTag:
            case dateTag:
              return new Ctor(+object);
    
            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
    
            case numberTag:
            case stringTag:
              return new Ctor(object);
    
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
    
        /**
         * Invokes the method at `path` on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
    
        /**
         * Checks if `value` is array-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         */
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
    
        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
    
        /**
         * Checks if the provided arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
              ? (isArrayLike(object) && isIndex(index, object.length))
              : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
    
        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
    
        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func);
          if (!(funcName in LazyWrapper.prototype)) {
            return false;
          }
          var other = lodash[funcName];
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
    
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         */
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
    
        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
    
        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers required to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
         * augment function arguments, making the order in which they are executed important,
         * preventing the merging of metadata. However, we make an exception for a safe
         * common case where curried functions have `_.ary` and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
    
          var isCombo =
            (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
            (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
            (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
    
          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;
    
          return data;
        }
    
        /**
         * A specialized version of `_.pick` which picks `object` properties specified
         * by `props`.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} props The property names to pick.
         * @returns {Object} Returns the new object.
         */
        function pickByArray(object, props) {
          object = toObject(object);
    
          var index = -1,
              length = props.length,
              result = {};
    
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.pick` which picks `object` properties `predicate`
         * returns truthy for.
         *
         * @private
         * @param {Object} object The source object.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Object} Returns the new object.
         */
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
    
        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
    
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
    
        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity function
         * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
    
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
    
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
    
        /**
         * A fallback implementation of `_.isPlainObject` which checks if `value`
         * is an object created by the `Object` constructor or has a `[[Prototype]]`
         * of `null`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         */
        function shimIsPlainObject(value) {
          var Ctor,
              support = lodash.support;
    
          // Exit early for non `Object` objects.
          if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
              (!hasOwnProperty.call(value, 'constructor') &&
                (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          // IE < 9 iterates inherited properties before own properties. If the first
          // iterated property is an object's own property then there are no inherited
          // enumerable properties.
          var result;
          // In most environments an object's own properties are iterated before
          // its inherited properties. If the last iterated property is an object's
          // own property then there are no inherited enumerable properties.
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
    
        /**
         * A fallback implementation of `Object.keys` which creates an array of the
         * own enumerable property names of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
    
          var allowIndexes = !!length && isLength(length) &&
            (isArray(object) || isArguments(object));
    
          var index = -1,
              result = [];
    
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
    
        /**
         * Converts `value` to an array-like object if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Array|Object} Returns the array-like object.
         */
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
    
        /**
         * Converts `value` to an object if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Object} Returns the object.
         */
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
    
        /**
         * Converts `value` to property path array if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Array} Returns the property path array.
         */
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
    
        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper
            ? wrapper.clone()
            : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `collection` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the new array containing chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(+size || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(ceil(length / size));
    
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
    
        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
    
        /**
         * Creates an array of unique `array` values not included in the other
         * provided arrays using [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The arrays of values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.difference([1, 2, 3], [4, 2]);
         * // => [1, 3]
         */
        var difference = restParam(function(array, values) {
          return isArrayLike(array)
            ? baseDifference(array, baseFlatten(values, false, true))
            : [];
        });
    
        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that match the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRightWhile([1, 2, 3], function(n) {
         *   return n > 1;
         * });
         * // => [1]
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
         * // => ['barney', 'fred']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
         * // => ['barney']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.dropRightWhile(users, 'active'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
            : [];
        }
    
        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropWhile([1, 2, 3], function(n) {
         *   return n < 3;
         * });
         * // => [3]
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
         * // => ['fred', 'pebbles']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.dropWhile(users, 'active', false), 'user');
         * // => ['pebbles']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.dropWhile(users, 'active'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
            : [];
        }
    
        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8], '*', 1, 2);
         * // => [4, '*', 8]
         */
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
    
        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(chr) {
         *   return chr.user == 'barney';
         * });
         * // => 0
         *
         * // using the `_.matches` callback shorthand
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findIndex(users, 'active', false);
         * // => 0
         *
         * // using the `_.property` callback shorthand
         * _.findIndex(users, 'active');
         * // => 2
         */
        var findIndex = createFindIndex();
    
        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(chr) {
         *   return chr.user == 'pebbles';
         * });
         * // => 2
         *
         * // using the `_.matches` callback shorthand
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findLastIndex(users, 'active', false);
         * // => 2
         *
         * // using the `_.property` callback shorthand
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        var findLastIndex = createFindIndex(true);
    
        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @alias head
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.first([1, 2, 3]);
         * // => 1
         *
         * _.first([]);
         * // => undefined
         */
        function first(array) {
          return array ? array[0] : undefined;
        }
    
        /**
         * Flattens a nested array. If `isDeep` is `true` the array is recursively
         * flattened, otherwise it is only flattened a single level.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, 3, [4]]]);
         * // => [1, 2, 3, [4]]
         *
         * // using `isDeep`
         * _.flatten([1, [2, 3, [4]]], true);
         * // => [1, 2, 3, 4]
         */
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
    
        /**
         * Recursively flattens a nested array.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to recursively flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, 3, [4]]]);
         * // => [1, 2, 3, 4]
         */
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
    
        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it is used as the offset
         * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
         * performs a faster binary search.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {boolean|number} [fromIndex=0] The index to search from or `true`
         *  to perform a binary search on a sorted array.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // using `fromIndex`
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         *
         * // performing a binary search
         * _.indexOf([1, 1, 2, 2], 2, true);
         * // => 2
         */
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value),
                other = array[index];
    
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
    
        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          return dropRight(array, 1);
        }
    
        /**
         * Creates an array of unique values that are included in all of the provided
         * arrays using [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of shared values.
         * @example
         * _.intersection([1, 2], [4, 2], [2, 1]);
         * // => [2]
         */
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];
    
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
    
          outer:
          while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
    
        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
    
        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {boolean|number} [fromIndex=array.length-1] The index to search from
         *  or `true` to perform a binary search on a sorted array.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // using `fromIndex`
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         *
         * // performing a binary search
         * _.lastIndexOf([1, 1, 2, 2], 2, true);
         * // => 3
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
    
        /**
         * Removes all provided values from `array` using
         * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3, 1, 2, 3];
         *
         * _.pull(array, 2, 3);
         * console.log(array);
         * // => [1, 1]
         */
        function pull() {
          var args = arguments,
              array = args[0];
    
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
    
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
    
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
    
        /**
         * Removes elements from `array` corresponding to the given indexes and returns
         * an array of the removed elements. Indexes may be specified as an array of
         * indexes or as individual arguments.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove,
         *  specified as individual indexes or arrays of indexes.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [5, 10, 15, 20];
         * var evens = _.pullAt(array, 1, 3);
         *
         * console.log(array);
         * // => [5, 15]
         *
         * console.log(evens);
         * // => [10, 20]
         */
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
    
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
    
        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is bound to
         * `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
    
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
    
        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @alias tail
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.rest([1, 2, 3]);
         * // => [2, 3]
         */
        function rest(array) {
          return drop(array, 1);
        }
    
        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of `Array#slice` to support node
         * lists in IE < 9 and to ensure dense arrays are returned.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
    
        /**
         * Uses a binary search to determine the lowest index at which `value` should
         * be inserted into `array` in order to maintain its sort order. If an iteratee
         * function is provided it is invoked for `value` and each element of `array`
         * to compute their sort ranking. The iteratee is bound to `thisArg` and
         * invoked with one argument; (value).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         *
         * _.sortedIndex([4, 4, 5, 5], 5);
         * // => 2
         *
         * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
         *
         * // using an iteratee function
         * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
         *   return this.data[word];
         * }, dict);
         * // => 1
         *
         * // using the `_.property` callback shorthand
         * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
         * // => 1
         */
        var sortedIndex = createSortedIndex();
    
        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 4, 5, 5], 5);
         * // => 4
         */
        var sortedLastIndex = createSortedIndex(true);
    
        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
         * and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRightWhile([1, 2, 3], function(n) {
         *   return n > 1;
         * });
         * // => [2, 3]
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
         * // => ['pebbles']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
         * // => ['fred', 'pebbles']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.takeRightWhile(users, 'active'), 'user');
         * // => []
         */
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
            : [];
        }
    
        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is bound to
         * `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeWhile([1, 2, 3], function(n) {
         *   return n < 3;
         * });
         * // => [1, 2]
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false},
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.takeWhile(users, 'active', false), 'user');
         * // => ['barney', 'fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.takeWhile(users, 'active'), 'user');
         * // => []
         */
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3))
            : [];
        }
    
        /**
         * Creates an array of unique values, in order, from all of the provided arrays
         * using [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([1, 2], [4, 2], [2, 1]);
         * // => [1, 2, 4]
         */
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
    
        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
         * for equality comparisons, in which only the first occurence of each element
         * is kept. Providing `true` for `isSorted` performs a faster search algorithm
         * for sorted arrays. If an iteratee function is provided it is invoked for
         * each element in the array to generate the criterion by which uniqueness
         * is computed. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, array).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias unique
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {boolean} [isSorted] Specify the array is sorted.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new duplicate-value-free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         *
         * // using `isSorted`
         * _.uniq([1, 1, 2], true);
         * // => [1, 2]
         *
         * // using an iteratee function
         * _.uniq([1, 2.5, 1.5, 2], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => [1, 2.5]
         *
         * // using the `_.property` callback shorthand
         * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf)
            ? sortedUniq(array, iteratee)
            : baseUniq(array, iteratee);
        }
    
        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         *
         * _.unzip(zipped);
         * // => [['fred', 'barney'], [30, 40], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
    
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
    
        /**
         * This method is like `_.unzip` except that it accepts an iteratee to specify
         * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
         * and invoked with four arguments: (accumulator, value, index, group).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee] The function to combine regrouped values.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
    
        /**
         * Creates an array excluding all provided values using
         * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to filter.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.without([1, 2, 1, 3], 1, 2);
         * // => [3]
         */
        var without = restParam(function(array, values) {
          return isArrayLike(array)
            ? baseDifference(array, values)
            : [];
        });
    
        /**
         * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the provided arrays.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of values.
         * @example
         *
         * _.xor([1, 2], [4, 2]);
         * // => [1, 4]
         */
        function xor() {
          var index = -1,
              length = arguments.length;
    
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result
                ? baseDifference(result, array).concat(baseDifference(array, result))
                : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
    
        /**
         * Creates an array of grouped elements, the first of which contains the first
         * elements of the given arrays, the second of which contains the second elements
         * of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         */
        var zip = restParam(unzip);
    
        /**
         * The inverse of `_.pairs`; this method returns an object composed from arrays
         * of property names and values. Provide either a single two dimensional array,
         * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
         * and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @alias object
         * @category Array
         * @param {Array} props The property names.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject([['fred', 30], ['barney', 40]]);
         * // => { 'fred': 30, 'barney': 40 }
         *
         * _.zipObject(['fred', 'barney'], [30, 40]);
         * // => { 'fred': 30, 'barney': 40 }
         */
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
    
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
    
        /**
         * This method is like `_.zip` except that it accepts an iteratee to specify
         * how grouped values should be combined. The `iteratee` is bound to `thisArg`
         * and invoked with four arguments: (accumulator, value, index, group).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee] The function to combine grouped values.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
         * // => [111, 222]
         */
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
    
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a `lodash` object that wraps `value` with explicit method
         * chaining enabled.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _.chain(users)
         *   .sortBy('age')
         *   .map(function(chr) {
         *     return chr.user + ' is ' + chr.age;
         *   })
         *   .first()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
    
        /**
         * This method invokes `interceptor` and returns `value`. The interceptor is
         * bound to `thisArg` and invoked with one argument; (value). The purpose of
         * this method is to "tap into" a method chain in order to perform operations
         * on intermediate results within the chain.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @param {*} [thisArg] The `this` binding of `interceptor`.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
    
        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @param {*} [thisArg] The `this` binding of `interceptor`.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
    
        /**
         * Enables explicit method chaining on the wrapper object.
         *
         * @name chain
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // without explicit chaining
         * _(users).first();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // with explicit chaining
         * _(users).chain()
         *   .first()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }
    
        /**
         * Executes the chained sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapper = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapper = wrapper.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapper.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
    
        /**
         * Creates a clone of the chained sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapper = _(array).map(function(value) {
         *   return Math.pow(value, 2);
         * });
         *
         * var other = [3, 4];
         * var otherWrapper = wrapper.plant(other);
         *
         * otherWrapper.value();
         * // => [9, 16]
         *
         * wrapper.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;
    
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
    
        /**
         * Reverses the wrapped array so the first element becomes the last, the
         * second element becomes the second to last, and so on.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new reversed `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            if (this.__actions__.length) {
              value = new LazyWrapper(this);
            }
            return new LodashWrapper(value.reverse(), this.__chain__);
          }
          return this.thru(function(value) {
            return value.reverse();
          });
        }
    
        /**
         * Produces the result of coercing the unwrapped value to a string.
         *
         * @name toString
         * @memberOf _
         * @category Chain
         * @returns {string} Returns the coerced string value.
         * @example
         *
         * _([1, 2, 3]).toString();
         * // => '1,2,3'
         */
        function wrapperToString() {
          return (this.value() + '');
        }
    
        /**
         * Executes the chained sequence to extract the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @alias run, toJSON, valueOf
         * @category Chain
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an array of elements corresponding to the given keys, or indexes,
         * of `collection`. Keys may be specified as individual arguments or as arrays
         * of keys.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {...(number|number[]|string|string[])} [props] The property names
         *  or indexes of elements to pick, specified individually or in arrays.
         * @returns {Array} Returns the new array of picked elements.
         * @example
         *
         * _.at(['a', 'b', 'c'], [0, 2]);
         * // => ['a', 'c']
         *
         * _.at(['barney', 'fred', 'pebbles'], 0, 2);
         * // => ['barney', 'pebbles']
         */
        var at = restParam(function(collection, props) {
          return baseAt(collection, baseFlatten(props));
        });
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is the number of times the key was returned by `iteratee`.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([4.3, 6.1, 6.4], function(n) {
         *   return Math.floor(n);
         * });
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy([4.3, 6.1, 6.4], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
    
        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * The predicate is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias all
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'active': false },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.every(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = null;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
    
        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias select
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.filter([4, 5, 6], function(n) {
         *   return n % 2 == 0;
         * });
         * // => [4, 6]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.filter(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.filter(users, 'active'), 'user');
         * // => ['barney']
         */
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
    
        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias detect
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.result(_.find(users, function(chr) {
         *   return chr.age < 40;
         * }), 'user');
         * // => 'barney'
         *
         * // using the `_.matches` callback shorthand
         * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
         * // => 'pebbles'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.result(_.find(users, 'active', false), 'user');
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.result(_.find(users, 'active'), 'user');
         * // => 'barney'
         */
        var find = createFind(baseEach);
    
        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        var findLast = createFind(baseEachRight, true);
    
        /**
         * Performs a deep comparison between each element in `collection` and the
         * source object, returning the first element that has equivalent property
         * values.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Object} source The object of property values to match.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
         * // => 'barney'
         *
         * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
         * // => 'fred'
         */
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
    
        /**
         * Iterates over elements of `collection` invoking `iteratee` for each element.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection). Iteratee functions may exit iteration early
         * by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length" property
         * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
         * may be used for object iteration.
         *
         * @static
         * @memberOf _
         * @alias each
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEach(function(n) {
         *   console.log(n);
         * }).value();
         * // => logs each value from left to right and returns the array
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
         *   console.log(n, key);
         * });
         * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
         */
        var forEach = createForEach(arrayEach, baseEach);
    
        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias eachRight
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEachRight(function(n) {
         *   console.log(n);
         * }).value();
         * // => logs each value from right to left and returns the array
         */
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is an array of the elements responsible for generating the key.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
         *   return Math.floor(n);
         * });
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * // using the `_.property` callback shorthand
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
    
        /**
         * Checks if `value` is in `collection` using
         * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it is used as the offset
         * from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @alias contains, include
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {*} target The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
         * @returns {boolean} Returns `true` if a matching element is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
         * // => true
         *
         * _.includes('pebbles', 'eb');
         * // => true
         */
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (!length) {
            return false;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection))
            ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
            : (getIndexOf(collection, target, fromIndex) > -1);
        }
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is the last element responsible for generating the key. The
         * iteratee function is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var keyData = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.indexBy(keyData, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         *
         * _.indexBy(keyData, function(object) {
         *   return String.fromCharCode(object.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.indexBy(keyData, function(object) {
         *   return this.fromCharCode(object.code);
         * }, String);
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         */
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
    
        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `methodName` is a function it is
         * invoked for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invoke([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
    
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : null);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
    
        /**
         * Creates an array of values by running each element in `collection` through
         * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
         * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
         * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
         * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
         * `sum`, `uniq`, and `words`
         *
         * @static
         * @memberOf _
         * @alias collect
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function timesThree(n) {
         *   return n * 3;
         * }
         *
         * _.map([1, 2], timesThree);
         * // => [3, 6]
         *
         * _.map({ 'a': 1, 'b': 2 }, timesThree);
         * // => [3, 6] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
    
        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, while the second of which
         * contains elements `predicate` returns falsey for. The predicate is bound
         * to `thisArg` and invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * _.partition([1, 2, 3], function(n) {
         *   return n % 2;
         * });
         * // => [[1, 3], [2]]
         *
         * _.partition([1.2, 2.3, 3.4], function(n) {
         *   return this.floor(n) % 2;
         * }, Math);
         * // => [[1.2, 3.4], [2.3]]
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * var mapper = function(array) {
         *   return _.pluck(array, 'user');
         * };
         *
         * // using the `_.matches` callback shorthand
         * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
         * // => [['pebbles'], ['barney', 'fred']]
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.map(_.partition(users, 'active', false), mapper);
         * // => [['barney', 'pebbles'], ['fred']]
         *
         * // using the `_.property` callback shorthand
         * _.map(_.partition(users, 'active'), mapper);
         * // => [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });
    
        /**
         * Gets the property value of `path` from all elements in `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Array|string} path The path of the property to pluck.
         * @returns {Array} Returns the property values.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.pluck(users, 'user');
         * // => ['barney', 'fred']
         *
         * var userIndex = _.indexBy(users, 'user');
         * _.pluck(userIndex, 'age');
         * // => [36, 40] (iteration order is not guaranteed)
         */
        function pluck(collection, path) {
          return map(collection, property(path));
        }
    
        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` through `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not provided the first element of `collection` is used as the initial
         * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `includes`, `merge`, `sortByAll`, and `sortByOrder`
         *
         * @static
         * @memberOf _
         * @alias foldl, inject
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.reduce([1, 2], function(total, n) {
         *   return total + n;
         * });
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
         *   result[key] = n * 3;
         *   return result;
         * }, {});
         * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
         */
        var reduce = createReduce(arrayReduce, baseEach);
    
        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias foldr
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
    
        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.reject([1, 2, 3, 4], function(n) {
         *   return n % 2 == 0;
         * });
         * // => [1, 3]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.reject(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.reject(users, 'active'), 'user');
         * // => ['barney']
         */
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
    
        /**
         * Gets a random element or `n` random elements from a collection.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to sample.
         * @param {number} [n] The number of elements to sample.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {*} Returns the random sample(s).
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         *
         * _.sample([1, 2, 3, 4], 2);
         * // => [3, 1]
         */
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
    
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
    
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
    
        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
    
        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable properties for objects.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the size of `collection`.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
    
        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * The function returns as soon as it finds a passing value and does not iterate
         * over the entire collection. The predicate is bound to `thisArg` and invoked
         * with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias any
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.some(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = null;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
    
        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection through `iteratee`. This method performs
         * a stable sort, that is, it preserves the original sort order of equal elements.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * _.sortBy([1, 2, 3], function(n) {
         *   return Math.sin(n);
         * });
         * // => [3, 1, 2]
         *
         * _.sortBy([1, 2, 3], function(n) {
         *   return this.sin(n);
         * }, Math);
         * // => [3, 1, 2]
         *
         * var users = [
         *   { 'user': 'fred' },
         *   { 'user': 'pebbles' },
         *   { 'user': 'barney' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.sortBy(users, 'user'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = null;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
    
          var result = baseMap(collection, function(value, key, collection) {
            return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
          });
          return baseSortBy(result, compareAscending);
        }
    
        /**
         * This method is like `_.sortBy` except that it can sort by multiple iteratees
         * or property names.
         *
         * If a property name is provided for an iteratee the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If an object is provided for an iteratee the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
         *  The iteratees to sort by, specified as individual values or arrays of values.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.map(_.sortByAll(users, ['user', 'age']), _.values);
         * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
         *
         * _.map(_.sortByAll(users, 'user', function(chr) {
         *   return Math.floor(chr.age / 10);
         * }), _.values);
         * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
    
        /**
         * This method is like `_.sortByAll` except that it allows specifying the
         * sort orders of the iteratees to sort by. A truthy value in `orders` will
         * sort the corresponding property name in ascending order while a falsey
         * value will sort it in descending order.
         *
         * If a property name is provided for an iteratee the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If an object is provided for an iteratee the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {boolean[]} orders The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // sort by `user` in ascending order and by `age` in descending order
         * _.map(_.sortByOrder(users, ['user', 'age'], [true, false]), _.values);
         * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = null;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
    
        /**
         * Performs a deep comparison between each element in `collection` and the
         * source object, returning an array of all elements that have equivalent
         * property values.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Object} source The object of property values to match.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
         *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
         * ];
         *
         * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
         * // => ['barney']
         *
         * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
         * // => ['fred']
         */
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Gets the number of milliseconds that have elapsed since the Unix epoch
         * (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @category Date
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => logs the number of milliseconds it took for the deferred function to be invoked
         */
        var now = nativeNow || function() {
          return new Date().getTime();
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it is called `n` or more times.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => logs 'done saving!' after the two async saves have completed
         */
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
    
        /**
         * Creates a function that accepts up to `n` arguments ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = null;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, null, null, null, null, n);
        }
    
        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it is called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery('#add').on('click', _.before(5, addContactToList));
         * // => allows adding up to 4 contacts to the list
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = null;
            }
            return result;
          };
        }
    
        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and prepends any additional `_.bind` arguments to those provided to the
         * bound function.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind` this method does not set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var greet = function(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * };
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // using placeholders
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
    
        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method. Method names may be specified as individual arguments or as arrays
         * of method names. If no method names are provided all enumerable function
         * properties, own and inherited, of `object` are bound.
         *
         * **Note:** This method does not set the "length" property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} [methodNames] The object method names to bind,
         *  specified as individual method names or arrays of method names.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'onClick': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view);
         * jQuery('#docs').on('click', view.onClick);
         * // => logs 'clicked docs' when the element is clicked
         */
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
    
          var index = -1,
              length = methodNames.length;
    
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
    
        /**
         * Creates a function that invokes the method at `object[key]` and prepends
         * any additional `_.bindKey` arguments to those provided to the bound function.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist.
         * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Object} object The object the method belongs to.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // using placeholders
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
    
        /**
         * Creates a function that accepts one or more arguments of `func` that when
         * called either invokes `func` returning its result, if all `func` arguments
         * have been provided, or returns a function that accepts one or more of the
         * remaining `func` arguments, and so on. The arity of `func` may be specified
         * if `func.length` is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method does not set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // using placeholders
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        var curry = createCurry(CURRY_FLAG);
    
        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method does not set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // using placeholders
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
    
        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed invocations. Provide an options object to indicate that `func`
         * should be invoked on the leading and/or trailing edge of the `wait` timeout.
         * Subsequent calls to the debounced function return the result of the last
         * `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the the debounced function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=false] Specify invoking on the leading
         *  edge of the timeout.
         * @param {number} [options.maxWait] The maximum time `func` is allowed to be
         *  delayed before it is invoked.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // avoid costly calculations while the window size is in flux
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
         * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // ensure `batchLog` is invoked once after 1 second of debounced calls
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', _.debounce(batchLog, 250, {
         *   'maxWait': 1000
         * }));
         *
         * // cancel a debounced call
         * var todoChanges = _.debounce(batchLog, 1000);
         * Object.observe(models.todo, todoChanges);
         *
         * Object.observe(models, function(changes) {
         *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
         *     todoChanges.cancel();
         *   }
         * }, ['delete']);
         *
         * // ...at some point `models.todo` is changed
         * models.todo.completed = true;
         *
         * // ...before 1 second has passed `models.todo` is deleted
         * // which cancels the debounced `todoChanges` call
         * delete models.todo;
         */
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
    
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
    
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
    
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
    
          function maxDelayed() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (trailing || (maxWait !== wait)) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          }
    
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
    
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
    
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              }
              else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            }
            else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
    
        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // logs 'deferred' after one or more milliseconds
         */
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
    
        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => logs 'later' after one second
         */
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
    
        /**
         * Creates a function that returns the result of invoking the provided
         * functions with the `this` binding of the created function, where each
         * successive invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {...Function} [funcs] Functions to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow(_.add, square);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();
    
        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the provided functions from right to left.
         *
         * @static
         * @memberOf _
         * @alias backflow, compose
         * @category Function
         * @param {...Function} [funcs] Functions to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight(square, _.add);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);
    
        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is coerced to a string and used as the
         * cache key. The `func` is invoked with the `this` binding of the memoized
         * function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the [`Map`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
         * method interface of `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoizing function.
         * @example
         *
         * var upperCase = _.memoize(function(string) {
         *   return string.toUpperCase();
         * });
         *
         * upperCase('fred');
         * // => 'FRED'
         *
         * // modifying the result cache
         * upperCase.cache.set('fred', 'BARNEY');
         * upperCase('fred');
         * // => 'BARNEY'
         *
         * // replacing `_.memoize.Cache`
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'barney' };
         * var identity = _.memoize(_.identity);
         *
         * identity(object);
         * // => { 'user': 'fred' }
         * identity(other);
         * // => { 'user': 'fred' }
         *
         * _.memoize.Cache = WeakMap;
         * var identity = _.memoize(_.identity);
         *
         * identity(object);
         * // => { 'user': 'fred' }
         * identity(other);
         * // => { 'user': 'barney' }
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
    
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
    
        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
    
        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first call. The `func` is invoked
         * with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // `initialize` invokes `createApplication` once
         */
        function once(func) {
          return before(2, func);
        }
    
        /**
         * Creates a function that invokes `func` with `partial` arguments prepended
         * to those provided to the new function. This method is like `_.bind` except
         * it does **not** alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method does not set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) {
         *   return greeting + ' ' + name;
         * };
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // using placeholders
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = createPartial(PARTIAL_FLAG);
    
        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to those provided to the new function.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method does not set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) {
         *   return greeting + ' ' + name;
         * };
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // using placeholders
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
    
        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified indexes where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes,
         *  specified as individual indexes or arrays of indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, 2, 0, 1);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         *
         * var map = _.rearg(_.map, [1, 0]);
         * map(function(n) {
         *   return n * 3;
         * }, [1, 2, 3]);
         * // => [3, 6, 9]
         */
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));
        });
    
        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as an array.
         *
         * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.restParam(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
    
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0: return func.call(this, rest);
              case 1: return func.call(this, args[0], rest);
              case 2: return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
    
        /**
         * Creates a function that invokes `func` with the `this` binding of the created
         * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
         *
         * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * // with a Promise
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
    
        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed invocations. Provide an options object to indicate
         * that `func` should be invoked on the leading and/or trailing edge of the
         * `wait` timeout. Subsequent calls to the throttled function return the
         * result of the last `func` call.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the the throttled function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=true] Specify invoking on the leading
         *  edge of the timeout.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // avoid excessively updating the position while scrolling
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
         * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
         *   'trailing': false
         * }));
         *
         * // cancel a trailing throttled call
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
    
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          debounceOptions.leading = leading;
          debounceOptions.maxWait = +wait;
          debounceOptions.trailing = trailing;
          return debounce(func, wait, debounceOptions);
        }
    
        /**
         * Creates a function that provides `value` to the wrapper function as its
         * first argument. Any additional arguments provided to the function are
         * appended to those provided to the wrapper function. The wrapper is invoked
         * with the `this` binding of the created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} wrapper The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
         * otherwise they are assigned by reference. If `customizer` is provided it is
         * invoked to produce the cloned values. If `customizer` returns `undefined`
         * cloning is handled by the method instead. The `customizer` is bound to
         * `thisArg` and invoked with two argument; (value [, index|key, object]).
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
         * The enumerable properties of `arguments` objects and objects created by
         * constructors other than `Object` are cloned to plain `Object` objects. An
         * empty object is returned for uncloneable values such as functions, DOM nodes,
         * Maps, Sets, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {*} Returns the cloned value.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * var shallow = _.clone(users);
         * shallow[0] === users[0];
         * // => true
         *
         * var deep = _.clone(users, true);
         * deep[0] === users[0];
         * // => false
         *
         * // using a customizer callback
         * var el = _.clone(document.body, function(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * });
         *
         * el === document.body
         * // => false
         * el.nodeName
         * // => BODY
         * el.childNodes.length;
         * // => 0
         */
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          }
          else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function'
            ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
            : baseClone(value, isDeep);
        }
    
        /**
         * Creates a deep clone of `value`. If `customizer` is provided it is invoked
         * to produce the cloned values. If `customizer` returns `undefined` cloning
         * is handled by the method instead. The `customizer` is bound to `thisArg`
         * and invoked with two argument; (value [, index|key, object]).
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
         * The enumerable properties of `arguments` objects and objects created by
         * constructors other than `Object` are cloned to plain `Object` objects. An
         * empty object is returned for uncloneable values such as functions, DOM nodes,
         * Maps, Sets, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {*} Returns the deep cloned value.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * var deep = _.cloneDeep(users);
         * deep[0] === users[0];
         * // => false
         *
         * // using a customizer callback
         * var el = _.cloneDeep(document.body, function(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * });
         *
         * el === document.body
         * // => false
         * el.nodeName
         * // => BODY
         * el.childNodes.length;
         * // => 20
         */
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function'
            ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
            : baseClone(value, true);
        }
    
        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        function gt(value, other) {
          return value > other;
        }
    
        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        function gte(value, other) {
          return value >= other;
        }
    
        /**
         * Checks if `value` is classified as an `arguments` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;
        }
    
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(function() { return arguments; }());
         * // => false
         */
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
    
        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
    
        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
    
        /**
         * Checks if `value` is a DOM element.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) &&
            (objToString.call(value).indexOf('Element') > -1);
        }
        // Fallback for environments without DOM support.
        if (!support.dom) {
          isElement = function(value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
          };
        }
    
        /**
         * Checks if `value` is empty. A value is considered empty unless it is an
         * `arguments` object, array, string, or jQuery-like collection with a length
         * greater than `0` or an object with own enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {Array|Object|string} value The value to inspect.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
              (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
    
        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent. If `customizer` is provided it is invoked to compare values.
         * If `customizer` returns `undefined` comparisons are handled by the method
         * instead. The `customizer` is bound to `thisArg` and invoked with three
         * arguments: (value, other [, index|key]).
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. Functions and DOM nodes
         * are **not** supported. Provide a customizer function to extend support
         * for comparing other values.
         *
         * @static
         * @memberOf _
         * @alias eq
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize value comparisons.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'fred' };
         *
         * object == other;
         * // => false
         *
         * _.isEqual(object, other);
         * // => true
         *
         * // using a customizer callback
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqual(array, other, function(value, other) {
         *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
         *     return true;
         *   }
         * });
         * // => true
         */
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
    
        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
    
        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on [`Number.isFinite`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(10);
         * // => true
         *
         * _.isFinite('10');
         * // => false
         *
         * _.isFinite(true);
         * // => false
         *
         * _.isFinite(Object(10));
         * // => false
         *
         * _.isFinite(Infinity);
         * // => false
         */
        var isFinite = nativeNumIsFinite || function(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        };
    
        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in older versions of Chrome and Safari which return 'function' for regexes
          // and Safari 8 equivalents which return 'object' for typed array constructors.
          return objToString.call(value) == funcTag;
        };
    
        /**
         * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
         * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(1);
         * // => false
         */
        function isObject(value) {
          // Avoid a V8 JIT bug in Chrome 19-20.
          // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
    
        /**
         * Performs a deep comparison between `object` and `source` to determine if
         * `object` contains equivalent property values. If `customizer` is provided
         * it is invoked to compare values. If `customizer` returns `undefined`
         * comparisons are handled by the method instead. The `customizer` is bound
         * to `thisArg` and invoked with three arguments: (value, other, index|key).
         *
         * **Note:** This method supports comparing properties of arrays, booleans,
         * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
         * and DOM nodes are **not** supported. Provide a customizer function to extend
         * support for comparing other values.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize value comparisons.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.isMatch(object, { 'age': 40 });
         * // => true
         *
         * _.isMatch(object, { 'age': 36 });
         * // => false
         *
         * // using a customizer callback
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatch(object, source, function(value, other) {
         *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
         * });
         * // => true
         */
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
    
        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
         * which returns `true` for `undefined` and other non-numeric values.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
          return isNumber(value) && value != +value;
        }
    
        /**
         * Checks if `value` is a native function.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (objToString.call(value) == funcTag) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reIsHostCtor.test(value);
        }
    
        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }
    
        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
         * as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isNumber(8.4);
         * // => true
         *
         * _.isNumber(NaN);
         * // => true
         *
         * _.isNumber('8.4');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
    
        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * **Note:** This method assumes objects created by the `Object` constructor
         * have no inherited enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
          if (!(value && objToString.call(value) == objectTag)) {
            return false;
          }
          var valueOf = getNative(value, 'valueOf'),
              objProto = valueOf && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
    
          return objProto
            ? (value == objProto || getPrototypeOf(value) == objProto)
            : shimIsPlainObject(value);
        };
    
        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        function isRegExp(value) {
          return isObjectLike(value) && objToString.call(value) == regexpTag;
        }
    
        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
    
        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
    
        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined;
        }
    
        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        function lt(value, other) {
          return value < other;
        }
    
        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        function lte(value, other) {
          return value <= other;
        }
    
        /**
         * Converts `value` to an array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * (function() {
         *   return _.toArray(arguments).slice(1);
         * }(1, 2, 3));
         * // => [2, 3]
         */
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
    
        /**
         * Converts `value` to a plain object flattening inherited enumerable
         * properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object. Subsequent sources overwrite property assignments of previous sources.
         * If `customizer` is provided it is invoked to produce the assigned values.
         * The `customizer` is bound to `thisArg` and invoked with five arguments:
         * (objectValue, sourceValue, key, object, source).
         *
         * **Note:** This method mutates `object` and is based on
         * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
         *
         * @static
         * @memberOf _
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
         * // => { 'user': 'fred', 'age': 40 }
         *
         * // using a customizer callback
         * var defaults = _.partialRight(_.assign, function(value, other) {
         *   return _.isUndefined(value) ? other : value;
         * });
         *
         * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var assign = createAssigner(function(object, source, customizer) {
          return customizer
            ? assignWith(object, source, customizer)
            : baseAssign(object, source);
        });
    
        /**
         * Creates an object that inherits from the given `prototype` object. If a
         * `properties` object is provided its own enumerable properties are assigned
         * to the created object.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = null;
          }
          return properties ? baseAssign(result, properties) : result;
        }
    
        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object for all destination properties that resolve to `undefined`. Once a
         * property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var defaults = restParam(function(args) {
          var object = args[0];
          if (object == null) {
            return object;
          }
          args.push(assignDefaults);
          return assign.apply(undefined, args);
        });
    
        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(chr) {
         *   return chr.age < 40;
         * });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // using the `_.matches` callback shorthand
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findKey(users, 'active', false);
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        var findKey = createFindKey(baseForOwn);
    
        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(chr) {
         *   return chr.age < 40;
         * });
         * // => returns `pebbles` assuming `_.findKey` returns `barney`
         *
         * // using the `_.matches` callback shorthand
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findLastKey(users, 'active', false);
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        var findLastKey = createFindKey(baseForOwnRight);
    
        /**
         * Iterates over own and inherited enumerable properties of an object invoking
         * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
         */
        var forIn = createForIn(baseFor);
    
        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
         */
        var forInRight = createForIn(baseForRight);
    
        /**
         * Iterates over own enumerable properties of an object invoking `iteratee`
         * for each property. The `iteratee` is bound to `thisArg` and invoked with
         * three arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a' and 'b' (iteration order is not guaranteed)
         */
        var forOwn = createForOwn(baseForOwn);
    
        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
         */
        var forOwnRight = createForOwn(baseForOwnRight);
    
        /**
         * Creates an array of function property names from all enumerable properties,
         * own and inherited, of `object`.
         *
         * @static
         * @memberOf _
         * @alias methods
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the new array of property names.
         * @example
         *
         * _.functions(_);
         * // => ['after', 'ary', 'assign', ...]
         */
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
    
        /**
         * Gets the property value at `path` of `object`. If the resolved value is
         * `undefined` the `defaultValue` is used in its place.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
          return result === undefined ? defaultValue : result;
        }
    
        /**
         * Checks if `path` is a direct property.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': { 'c': 3 } } };
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b.c');
         * // => true
         *
         * _.has(object, ['a', 'b', 'c']);
         * // => true
         */
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) &&
            (isArray(object) || isArguments(object)));
        }
    
        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite property
         * assignments of previous values unless `multiValue` is `true`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to invert.
         * @param {boolean} [multiValue] Allow multiple values per key.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         *
         * // with `multiValue`
         * _.invert(object, true);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = null;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
    
          while (++index < length) {
            var key = props[index],
                value = object[key];
    
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            }
            else {
              result[value] = key;
            }
          }
          return result;
        }
    
        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
         * for more details.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? null : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
              (typeof object != 'function' && isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
    
        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) &&
            (isArray(object) || isArguments(object)) && length) || 0;
    
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
    
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) &&
                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
    
        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * property of `object` through `iteratee`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the new mapped object.
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        var mapKeys = createObjectMapper(true);
    
        /**
         * Creates an object with the same keys as `object` and values generated by
         * running each own enumerable property of `object` through `iteratee`. The
         * iteratee function is bound to `thisArg` and invoked with three arguments:
         * (value, key, object).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the new mapped object.
         * @example
         *
         * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
         *   return n * 3;
         * });
         * // => { 'a': 3, 'b': 6 }
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * // using the `_.property` callback shorthand
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        var mapValues = createObjectMapper();
    
        /**
         * Recursively merges own enumerable properties of the source object(s), that
         * don't resolve to `undefined` into the destination object. Subsequent sources
         * overwrite property assignments of previous sources. If `customizer` is
         * provided it is invoked to produce the merged values of the destination and
         * source properties. If `customizer` returns `undefined` merging is handled
         * by the method instead. The `customizer` is bound to `thisArg` and invoked
         * with five arguments: (objectValue, sourceValue, key, object, source).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var users = {
         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
         * };
         *
         * var ages = {
         *   'data': [{ 'age': 36 }, { 'age': 40 }]
         * };
         *
         * _.merge(users, ages);
         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
         *
         * // using a customizer callback
         * var object = {
         *   'fruits': ['apple'],
         *   'vegetables': ['beet']
         * };
         *
         * var other = {
         *   'fruits': ['banana'],
         *   'vegetables': ['carrot']
         * };
         *
         * _.merge(object, other, function(a, b) {
         *   if (_.isArray(a)) {
         *     return a.concat(b);
         *   }
         * });
         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
         */
        var merge = createAssigner(baseMerge);
    
        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable properties of `object` that are not omitted.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to omit, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.omit(object, 'age');
         * // => { 'user': 'fred' }
         *
         * _.omit(object, _.isNumber);
         * // => { 'user': 'fred' }
         */
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
    
        /**
         * Creates a two dimensional array of the key-value pairs for `object`,
         * e.g. `[[key1, value1], [key2, value2]]`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the new array of key-value pairs.
         * @example
         *
         * _.pairs({ 'barney': 36, 'fred': 40 });
         * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
         */
        function pairs(object) {
          object = toObject(object);
    
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
    
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
    
        /**
         * Creates an object composed of the picked `object` properties. Property
         * names may be specified as individual arguments or as arrays of property
         * names. If `predicate` is provided it is invoked for each property of `object`
         * picking the properties `predicate` returns truthy for. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to pick, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.pick(object, 'user');
         * // => { 'user': 'fred' }
         *
         * _.pick(object, _.isString);
         * // => { 'user': 'fred' }
         */
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function'
            ? pickByCallback(object, bindCallback(props[0], props[1], 3))
            : pickByArray(object, baseFlatten(props));
        });
    
        /**
         * This method is like `_.get` except that if the resolved value is a function
         * it is invoked with the `this` binding of its parent object and its result
         * is returned.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a.b.c', 'default');
         * // => 'default'
         *
         * _.result(object, 'a.b.c', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : object[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : object[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
    
        /**
         * Sets the property value of `path` on `object`. If a portion of `path`
         * does not exist it is created.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to augment.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, 'x[0].y.z', 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
    
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
    
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
    
        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own enumerable
         * properties through `iteratee`, with each invocation potentially mutating
         * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
         * with four arguments: (accumulator, value, key, object). Iteratee functions
         * may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Array|Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * });
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
         *   result[key] = n * 3;
         * });
         * // => { 'a': 3, 'b': 6 }
         */
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
    
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : null);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
    
        /**
         * Creates an array of the own enumerable property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return baseValues(object, keys(object));
        }
    
        /**
         * Creates an array of the own and inherited enumerable property values
         * of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Checks if `n` is between `start` and up to but not including, `end`. If
         * `end` is not specified it is set to `start` with `start` then set to `0`.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} n The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         */
        function inRange(value, start, end) {
          start = +start || 0;
          if (typeof end === 'undefined') {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
    
        /**
         * Produces a random number between `min` and `max` (inclusive). If only one
         * argument is provided a number between `0` and the given number is returned.
         * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
         * number is returned instead of an integer.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} [min=0] The minimum possible value.
         * @param {number} [max=1] The maximum possible value.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = null;
          }
          var noMin = min == null,
              noMax = max == null;
    
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            }
            else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar');
         * // => 'fooBar'
         *
         * _.camelCase('__foo_bar__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
    
        /**
         * Capitalizes the first character of `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('fred');
         * // => 'Fred'
         */
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
    
        /**
         * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('dj vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
    
        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to search.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search from.
         * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
    
          var length = string.length;
          position = position === undefined
            ? length
            : nativeMin(position < 0 ? 0 : (+position || 0), length);
    
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
    
        /**
         * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
         * their corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional characters
         * use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value.
         * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * Backticks are escaped because in Internet Explorer < 9, they can break out
         * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
         * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
         * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
         * for more details.
         *
         * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
         * to reduce XSS vectors.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          // Reset `lastIndex` because in IE < 9 `String#replace` does not.
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }
    
        /**
         * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
         * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
         */
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string))
            ? string.replace(reRegExpChars, '\\$&')
            : string;
        }
    
        /**
         * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__foo_bar__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
    
        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
    
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = floor(mid),
              rightLength = ceil(mid);
    
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
    
        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padLeft('abc', 6);
         * // => '   abc'
         *
         * _.padLeft('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padLeft('abc', 3);
         * // => 'abc'
         */
        var padLeft = createPadDir();
    
        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padRight('abc', 6);
         * // => 'abc   '
         *
         * _.padRight('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padRight('abc', 3);
         * // => 'abc'
         */
        var padRight = createPadDir(true);
    
        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
         * in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
         * of `parseInt`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          if (guard && isIterateeCall(string, radix, guard)) {
            radix = 0;
          }
          return nativeParseInt(string, radix);
        }
        // Fallback for environments with pre-ES5 implementations.
        if (nativeParseInt(whitespace + '08') != 8) {
          parseInt = function(string, radix, guard) {
            // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
            // Chrome fails to trim leading <BOM> whitespace characters.
            // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
            if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            string = trim(string);
            return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
          };
        }
    
        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=0] The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = floor(n / 2);
            string += string;
          } while (n);
    
          return result;
        }
    
        /**
         * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--foo-bar');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
    
        /**
         * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__foo_bar__');
         * // => 'Foo Bar'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
    
        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to search.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null
            ? 0
            : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
    
          return string.lastIndexOf(target, position) == position;
        }
    
        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is provided it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options] The options object.
         * @param {RegExp} [options.escape] The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
         * @param {Object} [options.imports] An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
         * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
         * @param {string} [options.variable] The data object variable name.
         * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // using the "interpolate" delimiter to create a compiled template
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // using the HTML "escape" delimiter to escape data property values
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // using the "evaluate" delimiter to execute JavaScript and generate HTML
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // using the internal `print` function in "evaluate" delimiters
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // using the ES delimiter as an alternative to the default "interpolate" delimiter
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // using custom template delimiters
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // using backslashes to treat delimiters as plain text
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // using the `imports` option to import `jQuery` as `jq`
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // using the `sourceURL` option to specify a custom sourceURL for the template
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
         *
         * // using the `variable` option to ensure a with-statement isn't used in the compiled template
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // using the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and a stack trace
         * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, otherOptions) {
          // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;
    
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = null;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
    
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
    
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
    
          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');
    
          // Use a sourceURL for easier debugging.
          var sourceURL = '//# sourceURL=' +
            ('sourceURL' in options
              ? options.sourceURL
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';
    
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
    
            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
    
            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
    
            // The JS engine embedded in Adobe products requires returning the `match`
            // string in order to produce the correct `offset` value.
            return match;
          });
    
          source += "';\n";
    
          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');
    
          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';
    
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
    
          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
    
        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
    
        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimLeft('  abc  ');
         * // => 'abc  '
         *
         * _.trimLeft('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
    
        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimRight('  abc  ');
         * // => '  abc'
         *
         * _.trimRight('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
    
        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object|number} [options] The options object or maximum string length.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.trunc('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', 24);
         * // => 'hi-diddly-ho there, n...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = null;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
    
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
    
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
    
        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
         * corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional HTML
         * entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }
    
        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = null;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Function} func The function to attempt.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // avoid throwing errors for invalid selectors
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch(e) {
            return isError(e) ? e : new Error(e);
          }
        });
    
        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and arguments of the created function. If `func` is a property name the
         * created callback returns the property value for a given element. If `func`
         * is an object the created callback returns `true` for elements that contain
         * the equivalent object properties, otherwise it returns `false`.
         *
         * @static
         * @memberOf _
         * @alias iteratee
         * @category Utility
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // wrap to create custom callback shorthands
         * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
         *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
         *   if (!match) {
         *     return callback(func, thisArg);
         *   }
         *   return function(object) {
         *     return match[2] == 'gt'
         *       ? object[match[1]] > match[3]
         *       : object[match[1]] < match[3];
         *   };
         * });
         *
         * _.filter(users, 'age__gt36');
         * // => [{ 'user': 'fred', 'age': 40 }]
         */
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = null;
          }
          return isObjectLike(func)
            ? matches(func)
            : baseCallback(func, thisArg);
        }
    
        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var getter = _.constant(object);
         *
         * getter() === object;
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }
    
        /**
         * This method returns the first argument provided to it.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.identity(object) === object;
         * // => true
         */
        function identity(value) {
          return value;
        }
    
        /**
         * Creates a function that performs a deep comparison between a given object
         * and `source`, returning `true` if the given object has equivalent property
         * values, else `false`.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, _.matches({ 'age': 40, 'active': false }));
         * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
    
        /**
         * Creates a function that compares the property value of `path` on a given
         * object to `value`.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * _.find(users, _.matchesProperty('user', 'fred'));
         * // => { 'user': 'fred' }
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
    
        /**
         * Creates a function that invokes the method at `path` on a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': _.constant(2) } } },
         *   { 'a': { 'b': { 'c': _.constant(1) } } }
         * ];
         *
         * _.map(objects, _.method('a.b.c'));
         * // => [2, 1]
         *
         * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
    
        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path on `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
    
        /**
         * Adds all own enumerable function properties of a source object to the
         * destination object. If `object` is a function then methods are added to
         * its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.chain=true] Specify whether the functions added
         *  are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : null,
                methodNames = (props && props.length) ? baseFunctions(source, props) : null;
    
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
    
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
    
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
    
                    actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  var args = [this.value()];
                  push.apply(args, arguments);
                  return func.apply(object, args);
                };
              }(func));
            }
          }
          return object;
        }
    
        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          context._ = oldDash;
          return this;
        }
    
        /**
         * A no-operation function that returns `undefined` regardless of the
         * arguments it receives.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.noop(object) === undefined;
         * // => true
         */
        function noop() {
          // No operation performed.
        }
    
        /**
         * Creates a function that returns the property value at `path` on a
         * given object.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': 2 } } },
         *   { 'a': { 'b': { 'c': 1 } } }
         * ];
         *
         * _.map(objects, _.property('a.b.c'));
         * // => [2, 1]
         *
         * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
    
        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the property value at a given path on `object`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), path + '');
          };
        }
    
        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. If `end` is not specified it is
         * set to `start` with `start` then set to `0`. If `end` is less than `start`
         * a zero-length range is created unless a negative `step` is specified.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the new array of numbers.
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = null;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
    
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
          // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
          var index = -1,
              length = nativeMax(ceil((end - start) / (step || 1)), 0),
              result = Array(length);
    
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
    
        /**
         * Invokes the iteratee function `n` times, returning an array of the results
         * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
         * one argument; (index).
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
         * // => [3, 6, 4]
         *
         * _.times(3, function(n) {
         *   mage.castSpell(n);
         * });
         * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
         *
         * _.times(3, function(n) {
         *   this.cast(n);
         * }, mage);
         * // => also invokes `mage.castSpell(n)` three times
         */
        function times(n, iteratee, thisArg) {
          n = floor(n);
    
          // Exit early to avoid a JSC JIT bug in Safari 8
          // where `Array(0)` is treated as `Array(1)`.
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
    
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
    
        /**
         * Generates a unique ID. If `prefix` is provided the ID is appended to it.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {string} [prefix] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} augend The first number to add.
         * @param {number} addend The second number to add.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
    
        /**
         * Gets the maximum value of `collection`. If `collection` is empty or falsey
         * `-Infinity` is returned. If an iteratee function is provided it is invoked
         * for each value in `collection` to generate the criterion by which the value
         * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => -Infinity
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.max(users, function(chr) {
         *   return chr.age;
         * });
         * // => { 'user': 'fred', 'age': 40 }
         *
         * // using the `_.property` callback shorthand
         * _.max(users, 'age');
         * // => { 'user': 'fred', 'age': 40 }
         */
        var max = createExtremum(gt, NEGATIVE_INFINITY);
    
        /**
         * Gets the minimum value of `collection`. If `collection` is empty or falsey
         * `Infinity` is returned. If an iteratee function is provided it is invoked
         * for each value in `collection` to generate the criterion by which the value
         * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => Infinity
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.min(users, function(chr) {
         *   return chr.age;
         * });
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // using the `_.property` callback shorthand
         * _.min(users, 'age');
         * // => { 'user': 'barney', 'age': 36 }
         */
        var min = createExtremum(lt, POSITIVE_INFINITY);
    
        /**
         * Gets the sum of the values in `collection`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 6]);
         * // => 10
         *
         * _.sum({ 'a': 4, 'b': 6 });
         * // => 10
         *
         * var objects = [
         *   { 'n': 4 },
         *   { 'n': 6 }
         * ];
         *
         * _.sum(objects, function(object) {
         *   return object.n;
         * });
         * // => 10
         *
         * // using the `_.property` callback shorthand
         * _.sum(objects, 'n');
         * // => 10
         */
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = null;
          }
          var callback = getCallback(),
              noIteratee = iteratee == null;
    
          if (!(noIteratee && callback === baseCallback)) {
            noIteratee = false;
            iteratee = callback(iteratee, thisArg, 3);
          }
          return noIteratee
            ? arraySum(isArray(collection) ? collection : toIterable(collection))
            : baseSum(collection, iteratee);
        }
    
        /*------------------------------------------------------------------------*/
    
        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
    
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
    
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
    
        // Add functions to the `Map` cache.
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
    
        // Add functions to the `Set` cache.
        SetCache.prototype.push = cachePush;
    
        // Assign cache to `_.memoize`.
        memoize.Cache = MapCache;
    
        // Add functions that return wrapped values when chaining.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
    
        // Add aliases.
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
    
        // Add functions to `lodash.prototype`.
        mixin(lodash, lodash);
    
        /*------------------------------------------------------------------------*/
    
        // Add functions that return unwrapped values when chaining.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
    
        // Add aliases.
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
    
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
    
        /*------------------------------------------------------------------------*/
    
        // Add functions capable of returning wrapped and unwrapped values when chaining.
        lodash.sample = sample;
    
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type string
         */
        lodash.VERSION = VERSION;
    
        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
    
        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['dropWhile', 'filter', 'map', 'takeWhile'], function(methodName, type) {
          var isFilter = type != LAZY_MAP_FLAG,
              isDropWhile = type == LAZY_DROP_WHILE_FLAG;
    
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var filtered = this.__filtered__,
                result = (filtered && isDropWhile) ? new LazyWrapper(this) : this.clone(),
                iteratees = result.__iteratees__ || (result.__iteratees__ = []);
    
            iteratees.push({
              'done': false,
              'count': 0,
              'index': 0,
              'iteratee': getCallback(iteratee, thisArg, 1),
              'limit': -1,
              'type': type
            });
    
            result.__filtered__ = filtered || isFilter;
            return result;
          };
        });
    
        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          var whileName = methodName + 'While';
    
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__,
                result = (filtered && !index) ? this.dropWhile() : this.clone();
    
            n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
            if (filtered) {
              if (index) {
                result.__takeCount__ = nativeMin(result.__takeCount__, n);
              } else {
                last(result.__iteratees__).limit = n;
              }
            } else {
              var views = result.__views__ || (result.__views__ = []);
              views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
            }
            return result;
          };
    
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
    
          LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
            return this.reverse()[whileName](predicate, thisArg).reverse();
          };
        });
    
        // Add `LazyWrapper` methods for `_.first` and `_.last`.
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
    
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
    
        // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
    
          LazyWrapper.prototype[methodName] = function() {
            return this[dropName](1);
          };
        });
    
        // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
    
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
    
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
    
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
    
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
    
          var result = this;
          if (start < 0) {
            result = this.takeRight(-start);
          } else if (start) {
            result = this.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
    
        LazyWrapper.prototype.toArray = function() {
          return this.drop(0);
        };
    
        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (!lodashFunc) {
            return;
          }
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName);
    
          lodash.prototype[methodName] = function() {
            var args = arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
    
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // avoid lazy use if the iteratee has a "length" value other than `1`
              isLazy = useLazy = false;
            }
            var onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              return onlyLazy
                ? func.call(value)
                : lodashFunc.call(lodash, this.value());
            }
            var interceptor = function(value) {
              var otherArgs = [value];
              push.apply(otherArgs, args);
              return lodashFunc.apply(lodash, otherArgs);
            };
            if (useLazy) {
              var wrapper = onlyLazy ? value : new LazyWrapper(this),
                  result = func.apply(wrapper, args);
    
              if (!retUnwrapped && (isHybrid || result.__actions__)) {
                var actions = result.__actions__ || (result.__actions__ = []);
                actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
              }
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
    
        // Add `Array` and `String` methods to `lodash.prototype`.
        arrayEach(['concat', 'join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
    
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
    
        // Map minified function names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);
    
            names.push({ 'name': methodName, 'func': lodashFunc });
          }
        });
    
        realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': null }];
    
        // Add functions to the lazy wrapper.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
    
        // Add chaining functions to the `lodash` wrapper.
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
    
        // Add function aliases to the `lodash` wrapper.
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
    
        return lodash;
      }
    
      /*--------------------------------------------------------------------------*/
    
      // Export lodash.
      var _ = runInContext();
    
      // Some AMD build optimizers like r.js check for condition patterns like the following:
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        // Expose lodash to the global object when an AMD loader is present to avoid
        // errors in cases where lodash is loaded by a script tag and not intended
        // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
        // more details.
        root._ = _;
    
        // Define as an anonymous module so, through path mapping, it can be
        // referenced as the "underscore" module.
        define(function() {
          return _;
        });
      }
      // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
      else if (freeExports && freeModule) {
        // Export for Node.js or RingoJS.
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        }
        // Export for Rhino with CommonJS support.
        else {
          freeExports._ = _;
        }
      }
      else {
        // Export for a browser or Rhino.
        root._ = _;
      }
    }.call(this));
    
  provide("lodash", module.exports);
}(global));

// pakmanager:semver
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // export the class if we are in a Node-like system.
    if (typeof module === 'object' && module.exports === exports)
      exports = module.exports = SemVer;
    
    // The debug function is excluded entirely from the minified version.
    /* nomin */ var debug;
    /* nomin */ if (typeof process === 'object' &&
        /* nomin */ process.env &&
        /* nomin */ process.env.NODE_DEBUG &&
        /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
      /* nomin */ debug = function() {
        /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
        /* nomin */ args.unshift('SEMVER');
        /* nomin */ console.log.apply(console, args);
        /* nomin */ };
    /* nomin */ else
      /* nomin */ debug = function() {};
    
    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    exports.SEMVER_SPEC_VERSION = '2.0.0';
    
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    
    // The actual regexps go on exports.re
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    
    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.
    
    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.
    
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    
    
    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.
    
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    
    
    // ## Main Version
    // Three dot-separated numeric identifiers.
    
    var MAINVERSION = R++;
    src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')';
    
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
    
    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.
    
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                                '|' + src[NONNUMERICIDENTIFIER] + ')';
    
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                     '|' + src[NONNUMERICIDENTIFIER] + ')';
    
    
    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.
    
    var PRERELEASE = R++;
    src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                      '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
    
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                           '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
    
    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.
    
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    
    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.
    
    var BUILD = R++;
    src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
                 '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
    
    
    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.
    
    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.
    
    var FULL = R++;
    var FULLPLAIN = 'v?' + src[MAINVERSION] +
                    src[PRERELEASE] + '?' +
                    src[BUILD] + '?';
    
    src[FULL] = '^' + FULLPLAIN + '$';
    
    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                     src[PRERELEASELOOSE] + '?' +
                     src[BUILD] + '?';
    
    var LOOSE = R++;
    src[LOOSE] = '^' + LOOSEPLAIN + '$';
    
    var GTLT = R++;
    src[GTLT] = '((?:<|>)?=?)';
    
    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
    
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:' + src[PRERELEASE] + ')?' +
                       src[BUILD] + '?' +
                       ')?)?';
    
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:' + src[PRERELEASELOOSE] + ')?' +
                            src[BUILD] + '?' +
                            ')?)?';
    
    var XRANGE = R++;
    src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
    
    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    var LONETILDE = R++;
    src[LONETILDE] = '(?:~>?)';
    
    var TILDETRIM = R++;
    src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
    re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    
    var TILDE = R++;
    src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
    var TILDELOOSE = R++;
    src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
    
    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    var LONECARET = R++;
    src[LONECARET] = '(?:\\^)';
    
    var CARETTRIM = R++;
    src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
    re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    
    var CARET = R++;
    src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
    var CARETLOOSE = R++;
    src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
    
    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
    var COMPARATOR = R++;
    src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
    
    
    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                          '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
    
    // this one has to use the /g flag
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    
    
    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                       '\\s+-\\s+' +
                       '(' + src[XRANGEPLAIN] + ')' +
                       '\\s*$';
    
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s+-\\s+' +
                            '(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s*$';
    
    // Star ranges basically just allow anything at all.
    var STAR = R++;
    src[STAR] = '(<|>)?=?\\s*\\*';
    
    // Compile to actual regexp objects.
    // All are flag-free, unless they were created above with a flag.
    for (var i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i])
        re[i] = new RegExp(src[i]);
    }
    
    exports.parse = parse;
    function parse(version, loose) {
      if (version instanceof SemVer)
        return version;
    
      if (typeof version !== 'string')
        return null;
    
      if (version.length > MAX_LENGTH)
        return null;
    
      var r = loose ? re[LOOSE] : re[FULL];
      if (!r.test(version))
        return null;
    
      try {
        return new SemVer(version, loose);
      } catch (er) {
        return null;
      }
    }
    
    exports.valid = valid;
    function valid(version, loose) {
      var v = parse(version, loose);
      return v ? v.version : null;
    }
    
    
    exports.clean = clean;
    function clean(version, loose) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
      return s ? s.version : null;
    }
    
    exports.SemVer = SemVer;
    
    function SemVer(version, loose) {
      if (version instanceof SemVer) {
        if (version.loose === loose)
          return version;
        else
          version = version.version;
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }
    
      if (version.length > MAX_LENGTH)
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
    
      if (!(this instanceof SemVer))
        return new SemVer(version, loose);
    
      debug('SemVer', version, loose);
      this.loose = loose;
      var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
    
      if (!m)
        throw new TypeError('Invalid Version: ' + version);
    
      this.raw = version;
    
      // these are actually numbers
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
    
      if (this.major > MAX_SAFE_INTEGER || this.major < 0)
        throw new TypeError('Invalid major version')
    
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
        throw new TypeError('Invalid minor version')
    
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
        throw new TypeError('Invalid patch version')
    
      // numberify any prerelease numeric ids
      if (!m[4])
        this.prerelease = [];
      else
        this.prerelease = m[4].split('.').map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id
            if (num >= 0 && num < MAX_SAFE_INTEGER)
              return num
          }
          return id;
        });
    
      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }
    
    SemVer.prototype.format = function() {
      this.version = this.major + '.' + this.minor + '.' + this.patch;
      if (this.prerelease.length)
        this.version += '-' + this.prerelease.join('.');
      return this.version;
    };
    
    SemVer.prototype.inspect = function() {
      return '<SemVer "' + this + '">';
    };
    
    SemVer.prototype.toString = function() {
      return this.version;
    };
    
    SemVer.prototype.compare = function(other) {
      debug('SemVer.compare', this.version, this.loose, other);
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      return this.compareMain(other) || this.comparePre(other);
    };
    
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      return compareIdentifiers(this.major, other.major) ||
             compareIdentifiers(this.minor, other.minor) ||
             compareIdentifiers(this.patch, other.patch);
    };
    
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      // NOT having a prerelease is > having one
      if (this.prerelease.length && !other.prerelease.length)
        return -1;
      else if (!this.prerelease.length && other.prerelease.length)
        return 1;
      else if (!this.prerelease.length && !other.prerelease.length)
        return 0;
    
      var i = 0;
      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);
        if (a === undefined && b === undefined)
          return 0;
        else if (b === undefined)
          return 1;
        else if (a === undefined)
          return -1;
        else if (a === b)
          continue;
        else
          return compareIdentifiers(a, b);
      } while (++i);
    };
    
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;
        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;
        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case 'prerelease':
          if (this.prerelease.length === 0)
            this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
    
        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
            this.major++;
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0)
            this.minor++;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0)
            this.patch++;
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case 'pre':
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            var i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) // didn't increment anything
              this.prerelease.push(0);
          }
          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1]))
                this.prerelease = [identifier, 0];
            } else
              this.prerelease = [identifier, 0];
          }
          break;
    
        default:
          throw new Error('invalid increment argument: ' + release);
      }
      this.format();
      return this;
    };
    
    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof(loose) === 'string') {
        identifier = loose;
        loose = undefined;
      }
    
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        if (v1.prerelease.length || v2.prerelease.length) {
          for (var key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return 'pre'+key;
              }
            }
          }
          return 'prerelease';
        }
        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return key;
            }
          }
        }
      }
    }
    
    exports.compareIdentifiers = compareIdentifiers;
    
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
    
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
    
      return (anum && !bnum) ? -1 :
             (bnum && !anum) ? 1 :
             a < b ? -1 :
             a > b ? 1 :
             0;
    }
    
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(b);
    }
    
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      var ret;
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a === b;
          break;
        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a !== b;
          break;
        case '': case '=': case '==': ret = eq(a, b, loose); break;
        case '!=': ret = neq(a, b, loose); break;
        case '>': ret = gt(a, b, loose); break;
        case '>=': ret = gte(a, b, loose); break;
        case '<': ret = lt(a, b, loose); break;
        case '<=': ret = lte(a, b, loose); break;
        default: throw new TypeError('Invalid operator: ' + op);
      }
      return ret;
    }
    
    exports.Comparator = Comparator;
    function Comparator(comp, loose) {
      if (comp instanceof Comparator) {
        if (comp.loose === loose)
          return comp;
        else
          comp = comp.value;
      }
    
      if (!(this instanceof Comparator))
        return new Comparator(comp, loose);
    
      debug('comparator', comp, loose);
      this.loose = loose;
      this.parse(comp);
    
      if (this.semver === ANY)
        this.value = '';
      else
        this.value = this.operator + this.semver.version;
    
      debug('comp', this);
    }
    
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
    
      if (!m)
        throw new TypeError('Invalid comparator: ' + comp);
    
      this.operator = m[1];
      if (this.operator === '=')
        this.operator = '';
    
      // if it literally is just '>' or '' then allow anything.
      if (!m[2])
        this.semver = ANY;
      else
        this.semver = new SemVer(m[2], this.loose);
    };
    
    Comparator.prototype.inspect = function() {
      return '<SemVer Comparator "' + this + '">';
    };
    
    Comparator.prototype.toString = function() {
      return this.value;
    };
    
    Comparator.prototype.test = function(version) {
      debug('Comparator.test', version, this.loose);
    
      if (this.semver === ANY)
        return true;
    
      if (typeof version === 'string')
        version = new SemVer(version, this.loose);
    
      return cmp(version, this.operator, this.semver, this.loose);
    };
    
    
    exports.Range = Range;
    function Range(range, loose) {
      if ((range instanceof Range) && range.loose === loose)
        return range;
    
      if (!(this instanceof Range))
        return new Range(range, loose);
    
      this.loose = loose;
    
      // First, split based on boolean or ||
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range) {
        return this.parseRange(range.trim());
      }, this).filter(function(c) {
        // throw out any that are not relevant for whatever reason
        return c.length;
      });
    
      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }
    
      this.format();
    }
    
    Range.prototype.inspect = function() {
      return '<SemVer Range "' + this.range + '">';
    };
    
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };
    
    Range.prototype.toString = function() {
      return this.range;
    };
    
    Range.prototype.parseRange = function(range) {
      var loose = this.loose;
      range = range.trim();
      debug('range', range, loose);
      // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[COMPARATORTRIM]);
    
      // `~ 1.2.3` => `~1.2.3`
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
    
      // `^ 1.2.3` => `^1.2.3`
      range = range.replace(re[CARETTRIM], caretTrimReplace);
    
      // normalize spaces
      range = range.split(/\s+/).join(' ');
    
      // At this point, the range is completely trimmed and
      // ready to be split into comparators.
    
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(' ').map(function(comp) {
        return parseComparator(comp, loose);
      }).join(' ').split(/\s+/);
      if (this.loose) {
        // in loose mode, throw out any that are not valid comparators
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, loose);
      });
    
      return set;
    };
    
    // Mostly just for testing and legacy API reasons
    exports.toComparators = toComparators;
    function toComparators(range, loose) {
      return new Range(range, loose).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }
    
    // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.
    function parseComparator(comp, loose) {
      debug('comp', comp);
      comp = replaceCarets(comp, loose);
      debug('caret', comp);
      comp = replaceTildes(comp, loose);
      debug('tildes', comp);
      comp = replaceXRanges(comp, loose);
      debug('xrange', comp);
      comp = replaceStars(comp, loose);
      debug('stars', comp);
      return comp;
    }
    
    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }
    
    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
    function replaceTildes(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceTilde(comp, loose);
      }).join(' ');
    }
    
    function replaceTilde(comp, loose) {
      var r = loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;
    
        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p))
          // ~1.2 == >=1.2.0- <1.3.0-
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        else if (pr) {
          debug('replaceTilde pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
        } else
          // ~1.2.3 == >=1.2.3 <1.3.0
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
    
        debug('tilde return', ret);
        return ret;
      });
    }
    
    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
    // ^1.2.3 --> >=1.2.3 <2.0.0
    // ^1.2.0 --> >=1.2.0 <2.0.0
    function replaceCarets(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceCaret(comp, loose);
      }).join(' ');
    }
    
    function replaceCaret(comp, loose) {
      debug('caret', comp, loose);
      var r = loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;
    
        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p)) {
          if (M === '0')
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          else
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p + pr +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p + pr +
                    ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p + pr +
                  ' <' + (+M + 1) + '.0.0';
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + (+M + 1) + '.0.0';
        }
    
        debug('caret return', ret);
        return ret;
      });
    }
    
    function replaceXRanges(comp, loose) {
      debug('replaceXRanges', comp, loose);
      return comp.split(/\s+/).map(function(comp) {
        return replaceXRange(comp, loose);
      }).join(' ');
    }
    
    function replaceXRange(comp, loose) {
      comp = comp.trim();
      var r = loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
    
        if (gtlt === '=' && anyX)
          gtlt = '';
    
        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            // nothing is allowed
            ret = '<0.0.0';
          } else {
            // nothing is forbidden
            ret = '*';
          }
        } else if (gtlt && anyX) {
          // replace X with 0
          if (xm)
            m = 0;
          if (xp)
            p = 0;
    
          if (gtlt === '>') {
            // >1 => >=2.0.0
            // >1.2 => >=1.3.0
            // >1.2.3 => >= 1.2.4
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else if (xp) {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            // <=0.7.x is actually <0.8.0, since any 0.7.x should
            // pass.  Similarly, <=7.x is actually <8.0.0, etc.
            gtlt = '<'
            if (xm)
              M = +M + 1
            else
              m = +m + 1
          }
    
          ret = gtlt + M + '.' + m + '.' + p;
        } else if (xm) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        }
    
        debug('xRange return', ret);
    
        return ret;
      });
    }
    
    // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.
    function replaceStars(comp, loose) {
      debug('replaceStars', comp, loose);
      // Looseness is ignored here.  star is always as loose as it gets!
      return comp.trim().replace(re[STAR], '');
    }
    
    // This function is passed to string.replace(re[HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0
    function hyphenReplace($0,
                           from, fM, fm, fp, fpr, fb,
                           to, tM, tm, tp, tpr, tb) {
    
      if (isX(fM))
        from = '';
      else if (isX(fm))
        from = '>=' + fM + '.0.0';
      else if (isX(fp))
        from = '>=' + fM + '.' + fm + '.0';
      else
        from = '>=' + from;
    
      if (isX(tM))
        to = '';
      else if (isX(tm))
        to = '<' + (+tM + 1) + '.0.0';
      else if (isX(tp))
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      else if (tpr)
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      else
        to = '<=' + to;
    
      return (from + ' ' + to).trim();
    }
    
    
    // if ANY of the sets match ALL of its comparators, then pass
    Range.prototype.test = function(version) {
      if (!version)
        return false;
    
      if (typeof version === 'string')
        version = new SemVer(version, this.loose);
    
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version))
          return true;
      }
      return false;
    };
    
    function testSet(set, version) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version))
          return false;
      }
    
      if (version.prerelease.length) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for (var i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === ANY)
            continue;
    
          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;
            if (allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch)
              return true;
          }
        }
    
        // Version has a -pre, but it's not one of the ones we like.
        return false;
      }
    
      return true;
    }
    
    exports.satisfies = satisfies;
    function satisfies(version, range, loose) {
      try {
        range = new Range(range, loose);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, loose) {
      return versions.filter(function(version) {
        return satisfies(version, range, loose);
      }).sort(function(a, b) {
        return rcompare(a, b, loose);
      })[0] || null;
    }
    
    exports.validRange = validRange;
    function validRange(range, loose) {
      try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, loose).range || '*';
      } catch (er) {
        return null;
      }
    }
    
    // Determine if version is less than all the versions possible in the range
    exports.ltr = ltr;
    function ltr(version, range, loose) {
      return outside(version, range, '<', loose);
    }
    
    // Determine if version is greater than all the versions possible in the range.
    exports.gtr = gtr;
    function gtr(version, range, loose) {
      return outside(version, range, '>', loose);
    }
    
    exports.outside = outside;
    function outside(version, range, hilo, loose) {
      version = new SemVer(version, loose);
      range = new Range(range, loose);
    
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
    
      // If it satisifes the range it is not outside
      if (satisfies(version, range, loose)) {
        return false;
      }
    
      // From now on, variable terms are as if we're in "gtr" mode.
      // but note that everything is flipped for the "ltr" function.
    
      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
    
        var high = null;
        var low = null;
    
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0')
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, loose)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, loose)) {
            low = comparator;
          }
        });
    
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
    
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    
    // Use the define() function if we're in AMD land
    if (typeof define === 'function' && define.amd)
      define(exports);
    
  provide("semver", module.exports);
}(global));

// pakmanager:commander
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter;
    var spawn = require('child_process').spawn;
    var readlink = require('graceful-readlink').readlinkSync;
    var path = require('path');
    var dirname = path.dirname;
    var basename = path.basename;
    var fs = require('fs');
    
    /**
     * Expose the root command.
     */
    
    exports = module.exports = new Command();
    
    /**
     * Expose `Command`.
     */
    
    exports.Command = Command;
    
    /**
     * Expose `Option`.
     */
    
    exports.Option = Option;
    
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {String} flags
     * @param {String} description
     * @api public
     */
    
    function Option(flags, description) {
      this.flags = flags;
      this.required = ~flags.indexOf('<');
      this.optional = ~flags.indexOf('[');
      this.bool = !~flags.indexOf('-no-');
      flags = flags.split(/[ ,|]+/);
      if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
      this.long = flags.shift();
      this.description = description || '';
    }
    
    /**
     * Return option name.
     *
     * @return {String}
     * @api private
     */
    
    Option.prototype.name = function() {
      return this.long
        .replace('--', '')
        .replace('no-', '');
    };
    
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {String} arg
     * @return {Boolean}
     * @api private
     */
    
    Option.prototype.is = function(arg) {
      return arg == this.short || arg == this.long;
    };
    
    /**
     * Initialize a new `Command`.
     *
     * @param {String} name
     * @api public
     */
    
    function Command(name) {
      this.commands = [];
      this.options = [];
      this._execs = [];
      this._allowUnknownOption = false;
      this._args = [];
      this._name = name;
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Command.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Add command `name`.
     *
     * The `.action()` callback is invoked when the
     * command `name` is specified via __ARGV__,
     * and the remaining arguments are applied to the
     * function for access.
     *
     * When the `name` is "*" an un-matched command
     * will be passed as the first arg, followed by
     * the rest of __ARGV__ remaining.
     *
     * Examples:
     *
     *      program
     *        .version('0.0.1')
     *        .option('-C, --chdir <path>', 'change the working directory')
     *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
     *        .option('-T, --no-tests', 'ignore test hook')
     *
     *      program
     *        .command('setup')
     *        .description('run remote setup commands')
     *        .action(function() {
     *          console.log('setup');
     *        });
     *
     *      program
     *        .command('exec <cmd>')
     *        .description('run the given remote command')
     *        .action(function(cmd) {
     *          console.log('exec "%s"', cmd);
     *        });
     *
     *      program
     *        .command('teardown <dir> [otherDirs...]')
     *        .description('run teardown commands')
     *        .action(function(dir, otherDirs) {
     *          console.log('dir "%s"', dir);
     *          if (otherDirs) {
     *            otherDirs.forEach(function (oDir) {
     *              console.log('dir "%s"', oDir);
     *            });
     *          }
     *        });
     *
     *      program
     *        .command('*')
     *        .description('deploy the given env')
     *        .action(function(env) {
     *          console.log('deploying "%s"', env);
     *        });
     *
     *      program.parse(process.argv);
      *
     * @param {String} name
     * @param {String} [desc] for git-style sub-commands
     * @return {Command} the new command
     * @api public
     */
    
    Command.prototype.command = function(name, desc, opts) {
      opts = opts || {};
      var args = name.split(/ +/);
      var cmd = new Command(args.shift());
    
      if (desc) {
        cmd.description(desc);
        this.executables = true;
        this._execs[cmd._name] = true;
      }
    
      cmd._noHelp = !!opts.noHelp;
      this.commands.push(cmd);
      cmd.parseExpectedArgs(args);
      cmd.parent = this;
    
      if (desc) return this;
      return cmd;
    };
    
    /**
     * Define argument syntax for the top-level command.
     *
     * @api public
     */
    
    Command.prototype.arguments = function (desc) {
      return this.parseExpectedArgs(desc.split(/ +/));
    }
    
    /**
     * Add an implicit `help [cmd]` subcommand
     * which invokes `--help` for the given command.
     *
     * @api private
     */
    
    Command.prototype.addImplicitHelpCommand = function() {
      this.command('help [cmd]', 'display help for [cmd]');
    };
    
    /**
     * Parse expected `args`.
     *
     * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parseExpectedArgs = function(args) {
      if (!args.length) return;
      var self = this;
      args.forEach(function(arg) {
        var argDetails = {
          required: false,
          name: '',
          variadic: false
        };
    
        switch (arg[0]) {
          case '<':
            argDetails.required = true;
            argDetails.name = arg.slice(1, -1);
            break;
          case '[':
            argDetails.name = arg.slice(1, -1);
            break;
        }
    
        if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
          argDetails.variadic = true;
          argDetails.name = argDetails.name.slice(0, -3);
        }
        if (argDetails.name) {
          self._args.push(argDetails);
        }
      });
      return this;
    };
    
    /**
     * Register callback `fn` for the command.
     *
     * Examples:
     *
     *      program
     *        .command('help')
     *        .description('display verbose help')
     *        .action(function() {
     *           // output help here
     *        });
     *
     * @param {Function} fn
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.action = function(fn) {
      var self = this;
      var listener = function(args, unknown) {
        // Parse any so-far unknown options
        args = args || [];
        unknown = unknown || [];
    
        var parsed = self.parseOptions(unknown);
    
        // Output help if necessary
        outputHelpIfNecessary(self, parsed.unknown);
    
        // If there are still any unknown options, then we simply
        // die, unless someone asked for help, in which case we give it
        // to them, and then we die.
        if (parsed.unknown.length > 0) {
          self.unknownOption(parsed.unknown[0]);
        }
    
        // Leftover arguments need to be pushed back. Fixes issue #56
        if (parsed.args.length) args = parsed.args.concat(args);
    
        self._args.forEach(function(arg, i) {
          if (arg.required && null == args[i]) {
            self.missingArgument(arg.name);
          } else if (arg.variadic) {
            if (i !== self._args.length - 1) {
              self.variadicArgNotLast(arg.name);
            }
    
            args[i] = args.splice(i);
          }
        });
    
        // Always append ourselves to the end of the arguments,
        // to make sure we match the number of arguments the user
        // expects
        if (self._args.length) {
          args[self._args.length] = self;
        } else {
          args.push(self);
        }
    
        fn.apply(self, args);
      };
      var parent = this.parent || this;
      var name = parent === this ? '*' : this._name;
      parent.on(name, listener);
      if (this._alias) parent.on(this._alias, listener);
      return this;
    };
    
    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to false
     *     program.option('-p, --pepper', 'add pepper');
     *
     *     --pepper
     *     program.pepper
     *     // => Boolean
     *
     *     // simple boolean defaulting to true
     *     program.option('-C, --no-cheese', 'remove cheese');
     *
     *     program.cheese
     *     // => true
     *
     *     --no-cheese
     *     program.cheese
     *     // => false
     *
     *     // required argument
     *     program.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     program.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {String} flags
     * @param {String} description
     * @param {Function|Mixed} fn or default
     * @param {Mixed} defaultValue
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this
        , option = new Option(flags, description)
        , oname = option.name()
        , name = camelcase(oname);
    
      // default as 3rd arg
      if (typeof fn != 'function') {
        if (fn instanceof RegExp) {
          var regex = fn;
          fn = function(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          }
        }
        else {
          defaultValue = fn;
          fn = null;
        }
      }
    
      // preassign default value only for --no-*, [optional], or <required>
      if (false == option.bool || option.optional || option.required) {
        // when --no-* we make sure default is true
        if (false == option.bool) defaultValue = true;
        // preassign only if we have a default
        if (undefined !== defaultValue) self[name] = defaultValue;
      }
    
      // register the option
      this.options.push(option);
    
      // when it's passed assign the value
      // and conditionally invoke the callback
      this.on(oname, function(val) {
        // coercion
        if (null !== val && fn) val = fn(val, undefined === self[name]
          ? defaultValue
          : self[name]);
    
        // unassigned or bool
        if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
          // if no value, bool true, and we have a default, then use it!
          if (null == val) {
            self[name] = option.bool
              ? defaultValue || true
              : false;
          } else {
            self[name] = val;
          }
        } else if (null !== val) {
          // reassign
          self[name] = val;
        }
      });
    
      return this;
    };
    
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} arg if `true` or omitted, no error will be thrown
     * for unknown options.
     * @api public
     */
    Command.prototype.allowUnknownOption = function(arg) {
        this._allowUnknownOption = arguments.length === 0 || arg;
        return this;
    };
    
    /**
     * Parse `argv`, settings options and invoking commands when defined.
     *
     * @param {Array} argv
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parse = function(argv) {
      // implicit help
      if (this.executables) this.addImplicitHelpCommand();
    
      // store raw args
      this.rawArgs = argv;
    
      // guess name
      this._name = this._name || basename(argv[1], '.js');
    
      // github-style sub-commands with no sub-command
      if (this.executables && argv.length < 3) {
        // this user needs help
        argv.push('--help');
      }
    
      // process argv
      var parsed = this.parseOptions(this.normalize(argv.slice(2)));
      var args = this.args = parsed.args;
    
      var result = this.parseArgs(this.args, parsed.unknown);
    
      // executable sub-commands
      var name = result.args[0];
      if (this._execs[name] && typeof this._execs[name] != "function") {
        return this.executeSubCommand(argv, args, parsed.unknown);
      }
    
      return result;
    };
    
    /**
     * Execute a sub-command executable.
     *
     * @param {Array} argv
     * @param {Array} args
     * @param {Array} unknown
     * @api private
     */
    
    Command.prototype.executeSubCommand = function(argv, args, unknown) {
      args = args.concat(unknown);
    
      if (!args.length) this.help();
      if ('help' == args[0] && 1 == args.length) this.help();
    
      // <cmd> --help
      if ('help' == args[0]) {
        args[0] = args[1];
        args[1] = '--help';
      }
    
      // executable
      var f = argv[1];
      // name of the subcommand, link `pm-install`
      var bin = basename(f, '.js') + '-' + args[0];
    
    
      // In case of globally installed, get the base dir where executable
      //  subcommand file should be located at
      var baseDir
        , link = readlink(f);
    
      // when symbolink is relative path
      if (link !== f && link.charAt(0) !== '/') {
        link = path.join(dirname(f), link)
      }
      baseDir = dirname(link);
    
      // prefer local `./<bin>` to bin in the $PATH
      var localBin = path.join(baseDir, bin);
    
      // whether bin file is a js script with explicit `.js` extension
      var isExplicitJS = false;
      if (exists(localBin + '.js')) {
        bin = localBin + '.js';
        isExplicitJS = true;
      } else if (exists(localBin)) {
        bin = localBin;
      }
    
      args = args.slice(1);
    
      var proc;
      if (process.platform !== 'win32') {
        if (isExplicitJS) {
          args.unshift(localBin);
          // add executable arguments to spawn
          args = (process.execArgv || []).concat(args);
    
          proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
        } else {
          proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
        }
      } else {
        args.unshift(localBin);
        proc = spawn(process.execPath, args, { stdio: 'inherit'});
      }
    
      proc.on('close', process.exit.bind(process));
      proc.on('error', function(err) {
        if (err.code == "ENOENT") {
          console.error('\n  %s(1) does not exist, try --help\n', bin);
        } else if (err.code == "EACCES") {
          console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
        }
        process.exit(1);
      });
    
      this.runningCommand = proc;
    };
    
    /**
     * Normalize `args`, splitting joined short flags. For example
     * the arg "-abc" is equivalent to "-a -b -c".
     * This also normalizes equal sign and splits "--abc=def" into "--abc def".
     *
     * @param {Array} args
     * @return {Array}
     * @api private
     */
    
    Command.prototype.normalize = function(args) {
      var ret = []
        , arg
        , lastOpt
        , index;
    
      for (var i = 0, len = args.length; i < len; ++i) {
        arg = args[i];
        if (i > 0) {
          lastOpt = this.optionFor(args[i-1]);
        }
    
        if (arg === '--') {
          // Honor option terminator
          ret = ret.concat(args.slice(i));
          break;
        } else if (lastOpt && lastOpt.required) {
          ret.push(arg);
        } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
          arg.slice(1).split('').forEach(function(c) {
            ret.push('-' + c);
          });
        } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
          ret.push(arg.slice(0, index), arg.slice(index + 1));
        } else {
          ret.push(arg);
        }
      }
    
      return ret;
    };
    
    /**
     * Parse command `args`.
     *
     * When listener(s) are available those
     * callbacks are invoked, otherwise the "*"
     * event is emitted and those actions are invoked.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api private
     */
    
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
    
      if (args.length) {
        name = args[0];
        if (this.listeners(name).length) {
          this.emit(args.shift(), args, unknown);
        } else {
          this.emit('*', args);
        }
      } else {
        outputHelpIfNecessary(this, unknown);
    
        // If there were no args and we have unknown options,
        // then they are extraneous and we need to error.
        if (unknown.length > 0) {
          this.unknownOption(unknown[0]);
        }
      }
    
      return this;
    };
    
    /**
     * Return an option matching `arg` if any.
     *
     * @param {String} arg
     * @return {Option}
     * @api private
     */
    
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i) {
        if (this.options[i].is(arg)) {
          return this.options[i];
        }
      }
    };
    
    /**
     * Parse options from `argv` returning `argv`
     * void of these options.
     *
     * @param {Array} argv
     * @return {Array}
     * @api public
     */
    
    Command.prototype.parseOptions = function(argv) {
      var args = []
        , len = argv.length
        , literal
        , option
        , arg;
    
      var unknownOptions = [];
    
      // parse options
      for (var i = 0; i < len; ++i) {
        arg = argv[i];
    
        // literal args after --
        if ('--' == arg) {
          literal = true;
          continue;
        }
    
        if (literal) {
          args.push(arg);
          continue;
        }
    
        // find matching Option
        option = this.optionFor(arg);
    
        // option is defined
        if (option) {
          // requires arg
          if (option.required) {
            arg = argv[++i];
            if (null == arg) return this.optionMissingArgument(option);
            this.emit(option.name(), arg);
          // optional arg
          } else if (option.optional) {
            arg = argv[i+1];
            if (null == arg || ('-' == arg[0] && '-' != arg)) {
              arg = null;
            } else {
              ++i;
            }
            this.emit(option.name(), arg);
          // bool
          } else {
            this.emit(option.name());
          }
          continue;
        }
    
        // looks like an option
        if (arg.length > 1 && '-' == arg[0]) {
          unknownOptions.push(arg);
    
          // If the next argument looks like it might be
          // an argument for this option, we pass it on.
          // If it isn't, then it'll simply be ignored
          if (argv[i+1] && '-' != argv[i+1][0]) {
            unknownOptions.push(argv[++i]);
          }
          continue;
        }
    
        // arg
        args.push(arg);
      }
    
      return { args: args, unknown: unknownOptions };
    };
    
    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     * @api public
     */
    Command.prototype.opts = function() {
      var result = {}
        , len = this.options.length;
    
      for (var i = 0 ; i < len; i++) {
        var key = camelcase(this.options[i].name());
        result[key] = key === 'version' ? this._version : this[key];
      }
      return result;
    };
    
    /**
     * Argument `name` is missing.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.missingArgument = function(name) {
      console.error();
      console.error("  error: missing required argument `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * `Option` is missing an argument, but received `flag` or nothing.
     *
     * @param {String} option
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.optionMissingArgument = function(option, flag) {
      console.error();
      if (flag) {
        console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
      } else {
        console.error("  error: option `%s' argument missing", option.flags);
      }
      console.error();
      process.exit(1);
    };
    
    /**
     * Unknown option `flag`.
     *
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.unknownOption = function(flag) {
      if (this._allowUnknownOption) return;
      console.error();
      console.error("  error: unknown option `%s'", flag);
      console.error();
      process.exit(1);
    };
    
    /**
     * Variadic argument with `name` is not the last argument as required.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.variadicArgNotLast = function(name) {
      console.error();
      console.error("  error: variadic arguments must be last `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * @param {String} str
     * @param {String} flags
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.version = function(str, flags) {
      if (0 == arguments.length) return this._version;
      this._version = str;
      flags = flags || '-V, --version';
      this.option(flags, 'output the version number');
      this.on('version', function() {
        process.stdout.write(str + '\n');
        process.exit(0);
      });
      return this;
    };
    
    /**
     * Set the description to `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.description = function(str) {
      if (0 == arguments.length) return this._description;
      this._description = str;
      return this;
    };
    
    /**
     * Set an alias for the command
     *
     * @param {String} alias
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.alias = function(alias) {
      if (0 == arguments.length) return this._alias;
      this._alias = alias;
      return this;
    };
    
    /**
     * Set / get the command usage `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      });
    
      var usage = '[options]'
        + (this.commands.length ? ' [command]' : '')
        + (this._args.length ? ' ' + args.join(' ') : '');
    
      if (0 == arguments.length) return this._usage || usage;
      this._usage = str;
    
      return this;
    };
    
    /**
     * Get the name of the command
     *
     * @param {String} name
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.name = function() {
      return this._name;
    };
    
    /**
     * Return the largest option length.
     *
     * @return {Number}
     * @api private
     */
    
    Command.prototype.largestOptionLength = function() {
      return this.options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    
    /**
     * Return help for options.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.optionHelp = function() {
      var width = this.largestOptionLength();
    
      // Prepend the help information
      return [pad('-h, --help', width) + '  ' + 'output usage information']
        .concat(this.options.map(function(option) {
          return pad(option.flags, width) + '  ' + option.description;
          }))
        .join('\n');
    };
    
    /**
     * Return command help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.commandHelp = function() {
      if (!this.commands.length) return '';
    
      var commands = this.commands.filter(function(cmd) {
        return !cmd._noHelp;
      }).map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(' ');
    
        return [
          cmd._name
            + (cmd._alias
              ? '|' + cmd._alias
              : '')
            + (cmd.options.length
              ? ' [options]'
              : '')
            + ' ' + args
        , cmd.description()
        ];
      });
    
      var width = commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    
      return [
          ''
        , '  Commands:'
        , ''
        , commands.map(function(cmd) {
          return pad(cmd[0], width) + '  ' + cmd[1];
        }).join('\n').replace(/^/gm, '    ')
        , ''
      ].join('\n');
    };
    
    /**
     * Return program help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.helpInformation = function() {
      var desc = [];
      if (this._description) {
        desc = [
          '  ' + this._description
          , ''
        ];
      }
    
      var cmdName = this._name;
      if (this._alias) {
        cmdName = cmdName + '|' + this._alias;
      }
      var usage = [
        ''
        ,'  Usage: ' + cmdName + ' ' + this.usage()
        , ''
      ];
    
      var cmds = [];
      var commandHelp = this.commandHelp();
      if (commandHelp) cmds = [commandHelp];
    
      var options = [
        '  Options:'
        , ''
        , '' + this.optionHelp().replace(/^/gm, '    ')
        , ''
        , ''
      ];
    
      return usage
        .concat(cmds)
        .concat(desc)
        .concat(options)
        .join('\n');
    };
    
    /**
     * Output help information for this command
     *
     * @api public
     */
    
    Command.prototype.outputHelp = function() {
      process.stdout.write(this.helpInformation());
      this.emit('--help');
    };
    
    /**
     * Output help information and exit.
     *
     * @api public
     */
    
    Command.prototype.help = function() {
      this.outputHelp();
      process.exit();
    };
    
    /**
     * Camel-case the given `flag`
     *
     * @param {String} flag
     * @return {String}
     * @api private
     */
    
    function camelcase(flag) {
      return flag.split('-').reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    
    /**
     * Pad `str` to `width`.
     *
     * @param {String} str
     * @param {Number} width
     * @return {String}
     * @api private
     */
    
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(' ');
    }
    
    /**
     * Output help information if necessary
     *
     * @param {Command} command to output help for
     * @param {Array} array of options to search for -h or --help
     * @api private
     */
    
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++) {
        if (options[i] == '--help' || options[i] == '-h') {
          cmd.outputHelp();
          process.exit(0);
        }
      }
    }
    
    /**
     * Takes an argument an returns its human readable equivalent for help usage.
     *
     * @param {Object} arg
     * @return {String}
     * @api private
     */
    
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === true ? '...' : '');
    
      return arg.required
        ? '<' + nameOutput + '>'
        : '[' + nameOutput + ']'
    }
    
    // for versions before node v0.8 when there weren't `fs.existsSync`
    function exists(file) {
      try {
        if (fs.statSync(file).isFile()) {
          return true;
        }
      } catch (e) {
        return false;
      }
    }
    
    
  provide("commander", module.exports);
}(global));

// pakmanager:interpret
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const extensions = {
      '.babel.js': {
        module: 'babel/register',
        register: function (module) {
          module({
            // register on .js extension due to https://github.com/joyent/node/blob/v0.12.0/lib/module.js#L353
            // which only captures the final extension (.babel.js -> .js)
            extensions: '.js'
          })
        }
      },
      '.cirru': 'cirru-script/lib/register',
      '.cjsx': 'node-cjsx/register',
      '.co': 'coco',
      '.coffee': ['coffee-script/register', 'coffee-script'],
      '.coffee.md': ['coffee-script/register', 'coffee-script'],
      '.csv': 'require-csv',
      '.iced': ['iced-coffee-script/register', 'iced-coffee-script'],
      '.iced.md': 'iced-coffee-script/register',
      '.ini': 'require-ini',
      '.js': null,
      '.json': null,
      '.json5': 'json5/lib/require',
      '.jsx': [
        {
          module: 'babel/register',
          register: function (module) {
            module({
              extensions: '.jsx'
            });
          },
        },
        {
          module: 'node-jsx',
          register: function (module) {
            module.install({
              extension: '.jsx',
              harmony: true
            });
          }
        }
      ],
      '.litcoffee': ['coffee-script/register', 'coffee-script'],
      '.liticed': 'iced-coffee-script/register',
      '.ls': ['livescript', 'LiveScript'],
      '.node': null,
      '.toml': {
        module: 'toml-require',
        register: function (module) {
          module.install();
        }
      },
      '.ts': ['typescript-register', 'typescript-require'],
      '.wisp': 'wisp/engine/node',
      '.xml': 'require-xml',
      '.yaml': 'require-yaml',
      '.yml': 'require-yaml'
    };
    
    const jsVariantExtensions = [
      '.js',
      '.babel.js',
      '.cirru',
      '.cjsx',
      '.co',
      '.coffee',
      '.coffee.md',
      '.iced',
      '.iced.md',
      '.jsx',
      '.litcoffee',
      '.liticed',
      '.ls',
      '.ts',
      '.wisp'
    ];
    
    module.exports = {
      extensions: extensions,
      jsVariants: jsVariantExtensions.reduce(function (result, ext) {
        result[ext] = extensions[ext];
        return result;
      }, {})
    };
    
  provide("interpret", module.exports);
}(global));

// pakmanager:liftoff/lib/file_search
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const findup = require('findup-sync');
    
    module.exports = function (search, paths) {
      var path;
      var len = paths.length;
      for (var i = 0; i < len; i++) {
        if (path) {
          break;
        } else {
          path = findup(search, {cwd: paths[i], nocase: true});
        }
      }
      return path;
    };
    
  provide("liftoff/lib/file_search", module.exports);
}(global));

// pakmanager:liftoff/lib/find_cwd
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const path = require('path');
    
    module.exports = function (opts) {
      if (!opts) {
        opts = {};
      }
      var cwd = opts.cwd;
      var configPath = opts.configPath;
      // if a path to the desired config was specified
      // but no cwd was provided, use configPath dir
      if (typeof configPath === 'string' && !cwd) {
        cwd = path.dirname(path.resolve(configPath));
      }
      if (typeof cwd === 'string') {
        return path.resolve(cwd);
      }
      return process.cwd();
    };
    
  provide("liftoff/lib/find_cwd", module.exports);
}(global));

// pakmanager:liftoff/lib/find_config
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const fs = require('fs');
    const path = require('path');
    const fileSearch =  require('liftoff/lib/file_search');
    
    module.exports = function (opts) {
      opts = opts || {};
      var configNameSearch = opts.configNameSearch;
      var configPath = opts.configPath;
      var searchPaths = opts.searchPaths;
      // only search for a config if a path to one wasn't explicitly provided
      if (!configPath) {
        if (!Array.isArray(searchPaths)) {
          throw new Error('Please provide an array of paths to search for config in.');
        }
        if (!configNameSearch) {
          throw new Error('Please provide a configNameSearch.');
        }
        configPath = fileSearch(configNameSearch, searchPaths);
      }
      // confirm the configPath exists and return an absolute path to it
      if (fs.existsSync(configPath)) {
        return path.resolve(configPath);
      }
      return null;
    };
    
  provide("liftoff/lib/find_config", module.exports);
}(global));

// pakmanager:liftoff/lib/parse_options
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const extend = require('extend');
    
    module.exports = function (opts) {
      var defaults = {
        extensions: {
          '.js': null,
          '.json': null
        },
        searchPaths: []
      };
      if (!opts) {
        opts = {};
      }
      if (opts.name) {
        if (!opts.processTitle) {
          opts.processTitle = opts.name;
        }
        if (!opts.configName) {
          opts.configName = opts.name + 'file';
        }
        if (!opts.moduleName) {
          opts.moduleName = opts.name;
        }
      }
      if (!opts.processTitle) {
        throw new Error('You must specify a processTitle.');
      }
      if (!opts.configName) {
        throw new Error('You must specify a configName.');
      }
      if (!opts.moduleName) {
        throw new Error('You must specify a moduleName.');
      }
      return extend(defaults, opts);
    };
    
  provide("liftoff/lib/parse_options", module.exports);
}(global));

// pakmanager:liftoff/lib/silent_require
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (path) {
      try {
        return require(path);
      } catch (e) {}
    };
    
  provide("liftoff/lib/silent_require", module.exports);
}(global));

// pakmanager:liftoff/lib/build_config_name
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (opts) {
      opts = opts || {};
      var configName = opts.configName;
      var extensions = opts.extensions;
      if (!configName) {
        throw new Error('Please specify a configName.');
      }
      if (configName instanceof RegExp) {
        return [configName];
      }
      if (!Array.isArray(extensions)) {
        throw new Error('Please provide an array of valid extensions.');
      }
      return extensions.map(function (ext) {
        return configName + ext;
      });
    };
    
  provide("liftoff/lib/build_config_name", module.exports);
}(global));

// pakmanager:liftoff
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  const fs = require('fs');
    const util = require('util');
    const path = require('path');
    const EE = require('events').EventEmitter;
    
    const extend = require('extend');
    const resolve = require('resolve');
    const flaggedRespawn = require('flagged-respawn');
    const rechoir = require('rechoir');
    
    const findCwd =  require('liftoff/lib/find_cwd');
    const findConfig =  require('liftoff/lib/find_config');
    const fileSearch =  require('liftoff/lib/file_search');
    const parseOptions =  require('liftoff/lib/parse_options');
    const silentRequire =  require('liftoff/lib/silent_require');
    const buildConfigName =  require('liftoff/lib/build_config_name');
    
    
    function Liftoff (opts) {
      EE.call(this);
      extend(this, parseOptions(opts));
    }
    util.inherits(Liftoff, EE);
    
    Liftoff.prototype.requireLocal = function (module, basedir) {
      try {
        var result = require(resolve.sync(module, {basedir: basedir}));
        this.emit('require', module, result);
        return result;
      } catch (e) {
        this.emit('requireFail', module, e);
      }
    };
    
    Liftoff.prototype.buildEnvironment = function (opts) {
      opts = opts || {};
    
      // get modules we want to preload
      var preload = opts.require || [];
    
      // ensure items to preload is an array
      if (!Array.isArray(preload)) {
        preload = [preload];
      }
    
      // make a copy of search paths that can be mutated for this run
      var searchPaths = this.searchPaths.slice();
    
      // calculate current cwd
      var cwd = findCwd(opts);
    
      // if cwd was provided explicitly, only use it for searching config
      if (opts.cwd) {
        searchPaths = [cwd];
      } else {
        // otherwise just search in cwd first
        searchPaths.unshift(cwd);
      }
    
      // calculate the regex to use for finding the config file
      var configNameSearch = buildConfigName({
        configName: this.configName,
        extensions: Object.keys(this.extensions)
      });
    
      // calculate configPath
      var configPath = findConfig({
        configNameSearch: configNameSearch,
        searchPaths: searchPaths,
        configPath: opts.configPath
      });
    
      // if we have a config path, save the directory it resides in.
      var configBase;
      if (configPath) {
        configBase = path.dirname(configPath);
        // if cwd wasn't provided explicitly, it should match configBase
        if (!opts.cwd) {
          cwd = configBase;
        }
        // resolve symlink if needed
        if (fs.lstatSync(configPath).isSymbolicLink()) {
          configPath = fs.realpathSync(configPath);
        }
      }
    
      // TODO: break this out into lib/
      // locate local module and package next to config or explicitly provided cwd
      var modulePath, modulePackage;
      try {
        var delim = (process.platform === 'win32' ? ';' : ':'),
            paths = (process.env.NODE_PATH ? process.env.NODE_PATH.split(delim) : []);
        modulePath = resolve.sync(this.moduleName, {basedir: configBase || cwd, paths: paths});
        modulePackage = silentRequire(fileSearch('package.json', [modulePath]));
      } catch (e) {}
    
      // if we have a configuration but we failed to find a local module, maybe
      // we are developing against ourselves?
      if (!modulePath && configPath) {
        // check the package.json sibling to our config to see if its `name`
        // matches the module we're looking for
        var modulePackagePath = fileSearch('package.json', [configBase]);
        modulePackage = silentRequire(modulePackagePath);
        if (modulePackage && modulePackage.name === this.moduleName) {
          // if it does, our module path is `main` inside package.json
          modulePath = path.join(path.dirname(modulePackagePath), modulePackage.main || 'index.js');
          cwd = configBase;
        } else {
          // clear if we just required a package for some other project
          modulePackage = {};
        }
      }
    
      // load any modules which were requested to be required
      if (preload.length) {
        // unique results first
        preload.filter(function (value, index, self) {
          return self.indexOf(value) === index;
        }).forEach(function (dep) {
          this.requireLocal(dep, findCwd(opts));
        }, this);
      }
    
      // use rechoir to autoload any required modules
      var autoloads;
      if (configPath) {
        autoloads = rechoir.prepare(this.extensions, configPath, cwd, true);
        if (autoloads instanceof Error) {
          autoloads = autoloads.failures;
        }
        if (Array.isArray(autoloads)) {
          autoloads.forEach(function (attempt) {
            if (attempt.error) {
              this.emit('requireFail', attempt.moduleName, attempt.error);
            } else {
              this.emit('require', attempt.moduleName, attempt.module);
            }
          }, this);
        }
      }
    
      return {
        cwd: cwd,
        require: preload,
        configNameSearch: configNameSearch,
        configPath: configPath,
        configBase: configBase,
        modulePath: modulePath,
        modulePackage: modulePackage || {}
      };
    };
    
    Liftoff.prototype.handleFlags = function (cb) {
      if (typeof this.v8flags === 'function') {
        this.v8flags(function (err, flags) {
          if (err) {
            cb(err);
          } else {
            cb(null, flags);
          }
        });
      } else {
        process.nextTick(function () {
          cb(null, this.v8flags);
        }.bind(this));
      }
    };
    
    Liftoff.prototype.launch = function (opts, fn) {
      if (typeof fn !== 'function') {
        throw new Error('You must provide a callback function.');
      }
      process.title = this.processTitle;
    
      var completion = opts.completion;
      if (completion && this.completions) {
        return this.completions(completion);
      }
    
      this.handleFlags(function (err, flags) {
        if (err) {
          throw err;
        } else {
          if (flags) {
            flaggedRespawn(flags, process.argv, function (ready, child) {
              if (child !== process) {
                this.emit('respawn', process.argv.filter(function (flag) {
                  return flags.indexOf(flag) !== -1;
                }.bind(this)), child);
              }
              if (ready) {
                fn.call(this, this.buildEnvironment(opts));
              }
            }.bind(this));
          } else {
            fn.call(this, this.buildEnvironment(opts));
          }
        }
      }.bind(this));
    };
    
    
    
    module.exports = Liftoff;
    
  provide("liftoff", module.exports);
}(global));

// pakmanager:mkdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    var _0777 = parseInt('0777', 8);
    
    module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    
    function mkdirP (p, opts, f, made) {
        if (typeof opts === 'function') {
            f = opts;
            opts = {};
        }
        else if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
        
        var cb = f || function () {};
        p = path.resolve(p);
        
        xfs.mkdir(p, mode, function (er) {
            if (!er) {
                made = made || p;
                return cb(null, made);
            }
            switch (er.code) {
                case 'ENOENT':
                    mkdirP(path.dirname(p), opts, function (er, made) {
                        if (er) cb(er, made);
                        else mkdirP(p, opts, cb, made);
                    });
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    xfs.stat(p, function (er2, stat) {
                        // if the stat fails, then that's super weird.
                        // let the original error be the failure reason.
                        if (er2 || !stat.isDirectory()) cb(er, made)
                        else cb(null, made);
                    });
                    break;
            }
        });
    }
    
    mkdirP.sync = function sync (p, opts, made) {
        if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
    
        p = path.resolve(p);
    
        try {
            xfs.mkdirSync(p, mode);
            made = made || p;
        }
        catch (err0) {
            switch (err0.code) {
                case 'ENOENT' :
                    made = sync(path.dirname(p), opts, made);
                    sync(p, opts, made);
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    var stat;
                    try {
                        stat = xfs.statSync(p);
                    }
                    catch (err1) {
                        throw err0;
                    }
                    if (!stat.isDirectory()) throw err0;
                    break;
            }
        }
    
        return made;
    };
    
  provide("mkdirp", module.exports);
}(global));

// pakmanager:pool2/lib/pool
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Deque = require('double-ended-queue'),
        HashMap = require('hashmap');
    
    var inherits = require('util').inherits,
        EventEmitter = require('events').EventEmitter,
        debug = require('debug')('pool2');
    
    var assert = require('assert');
    
    function deprecate(old, current) {
        if (process.env.NODE_ENV === 'testing') { return; }
        console.log('Pool2: ' + old + ' is deprecated, please use ' + current);
    }
    
    /* Object tagging for debugging. I don't want to modify objects when not debugging, so I only tag them
     * if debugging is enabled (setId); however, since I have to access the property of the object in the debug()
     * calls, and this may cause accesses on undefined properties of an object, which may cause deoptimization
     * of the object, I have to create a helper function to avoid this (getId)
     */
    var SEQ = 0;
    
    function getId(res) {
        if (!debug.enabled) { return -1; }
        return res.__pool2__id;
    }
    function setId(res) {
        if (!debug.enabled) { return; }
        if (res && typeof res === 'object') {
            Object.defineProperty(res, '__pool2__id', {
                configurable: false,
                enumerable: false,
                value: SEQ++
            });
        }
    }
    
    function validNum(opts, val, standard, allowZero) { // jshint maxcomplexity: 8
        if (!opts || !opts.hasOwnProperty(val)) {
            return standard;
        }
        var num = parseInt(opts[val], 10);
        if (isNaN(num) || num !== +opts[val] || !isFinite(num) || num < 0) {
            throw new RangeError('Pool2: ' + val + ' must be a positive integer, ' + opts[val] + ' given.');
        }
        if (!allowZero && num === 0) {
            throw new RangeError('Pool2: ' + val + ' cannot be 0.');
        }
        return num;
    }
    function HOP(a, b) { return a && hasOwnProperty.call(a, b); }
    
    function Pool(opts) { // jshint maxcomplexity: 12, maxstatements: 42
        EventEmitter.call(this);
        
        opts = opts || { };
    
        if (HOP(opts, 'release')) {
            deprecate('opts.release', 'opts.dispose');
            opts.dispose = opts.release;
        }
    
        if (HOP(opts, 'releaseTimeout')) {
            deprecate('opts.releaseTimeout', 'opts.disposeTimeout');
            opts.disposeTimeout = opts.releaseTimeout;
        }
    
        assert(HOP(opts, 'acquire'), 'new Pool(): opts.acquire is required');
        assert(HOP(opts, 'dispose'), 'new Pool(): opts.dispose is required');
        assert(typeof opts.acquire === 'function', 'new Pool(): opts.acquire must be a function');
        assert(typeof opts.dispose === 'function', 'new Pool(): opts.dispose must be a function');
        assert(!HOP(opts, 'destroy') || typeof opts.destroy === 'function', 'new Pool(): opts.destroy must be a function');
        assert(!HOP(opts, 'ping') || typeof opts.ping === 'function', 'new Pool(): opts.ping must be a function');
        
        this._acquire = opts.acquire;
        this._dispose = opts.dispose;
        this._destroy = opts.destroy || function () { };
        this._ping = opts.ping || function (res, cb) { setImmediate(cb); };
        
        this.max = validNum(opts, 'max', Pool.defaults.max);
        this.min = validNum(opts, 'min', Pool.defaults.min, true);
    
        assert(this.max >= this.min, 'new Pool(): opts.min cannot be greater than opts.max');
        
        this.maxRequests = validNum(opts, 'maxRequests', Infinity);
        this.acquireTimeout = validNum(opts, 'acquireTimeout', Pool.defaults.acquireTimeout, true);
        this.disposeTimeout = validNum(opts, 'disposeTimeout', Pool.defaults.disposeTimeout, true);
        this.pingTimeout = validNum(opts, 'pingTimeout', Pool.defaults.pingTimeout);
        this.idleTimeout = validNum(opts, 'idleTimeout', Pool.defaults.idleTimeout);
        this.syncInterval = validNum(opts, 'syncInterval', Pool.defaults.syncInterval, true);
    
        assert(this.syncInterval > 0 || !HOP(opts, 'idleTimeout'), 'new Pool(): Cannot specify opts.idleTimeout when opts.syncInterval is 0');
    
        this.capabilities = Array.isArray(opts.capabilities) ? opts.capabilities.slice() : [ ];
        
        if (this.syncInterval !== 0) {
            this.syncTimer = setInterval(function () {
                this._ensureMinimum();
                this._reap();
                this._maybeAllocateResource();
            }.bind(this), this.syncInterval);        
        }
        
        this.live = false;
        this.ending = false;
        this.destroyed = false;
        
        this.acquiring = 0;
        
        this.pool = new HashMap();
        this.available = [ ];
        this.requests = new Deque();
        
        if (debug.enabled) {
            this._seq = 0;
        }
        
        process.nextTick(this._ensureMinimum.bind(this));
    }
    inherits(Pool, EventEmitter);
    
    Pool.defaults = {
        min: 0,
        max: 10,
        acquireTimeout: 30 * 1000,
        disposeTimeout: 30 * 1000,
        pingTimeout: 10 * 1000,
        idleTimeout: 60 * 1000,
        syncInterval: 10 * 1000
    };
    
    // return stats on the pool
    Pool.prototype.stats = function () {
        var allocated = this.pool.count();
        return {
            min: this.min,
            max: this.max,
            allocated: allocated,
            available: this.max - (allocated - this.available.length),
            queued: this.requests.length,
            maxRequests: this.maxRequests
        };
    };
    
    // request a resource from the pool
    Pool.prototype.acquire = function (cb) {
        if (this.destroyed || this.ending) {
            cb(new Error('Pool is ' + (this.ending ? 'ending' : 'destroyed')));
            return;
        }
        
        if (this.requests.length >= this.maxRequests) {
            cb(new Error('Pool is full'));
            return;
        }
        
        this.requests.push({ ts: new Date(), cb: cb });
        process.nextTick(this._maybeAllocateResource.bind(this));
    };
    
    // release the resource back into the pool
    Pool.prototype.release = function (res) { // jshint maxstatements: 17
        var err;
        
        if (!this.pool.has(res)) {
            err = new Error('Pool.release(): Resource not member of pool');
            err.res = res;
            this.emit('error', err);
            return;
        }
        
        if (this.available.indexOf(res) > -1) {
            err = new Error('Pool.release(): Resource already released (id=' + getId(res) + ')');
            err.res = res;
            this.emit('error', err);
            return;
        }
        
        
        this.pool.set(res, new Date());
        this.available.unshift(res);
        
        if (this.requests.length === 0 && this.pool.count() === this.available.length) {
            this.emit('drain');
        }
        
        this._maybeAllocateResource();
    };
    
    // destroy the resource -- should be called only on error conditions and the like
    Pool.prototype.destroy = function (res) {
        debug('Ungracefully destroying resource (id=%s)', getId(res));
        // make sure resource is not in our available resources array
        var idx = this.available.indexOf(res);
        if (idx > -1) { this.available.splice(idx, 1); }
    
        // remove from pool if present
        if (this.pool.has(res)) {
            this.pool.remove(res);
        }
        
        // destroy is fire-and-forget
        try { this._destroy(res); }
        catch (e) { this.emit('warn', e); }
        
        this._ensureMinimum();
    };
    
    // attempt to tear down the resource nicely -- should be called when the resource is still valid
    // (that is, the dispose callback is expected to behave correctly)
    Pool.prototype.remove = function (res, cb) { // jshint maxcomplexity: 7
        // called sometimes internally for the timeout logic, but don't want to emit an error in those cases
        var timer, skipError = false;
        if (typeof cb === 'boolean') {
            skipError = cb;
            cb = null;
        }
        
        // ensure resource is not in our available resources array
        var idx = this.available.indexOf(res);
        if (idx > -1) { this.available.splice(idx, 1); }
        
        if (this.pool.has(res)) {
            this.pool.remove(res);
        } else if (!skipError) {
            // object isn't in our pool -- emit an error
            this.emit('error', new Error('Pool.remove() called on non-member'));
        }
    
        // if we don't get a response from the dispose callback
        // within the timeout period, attempt to destroy the resource
        if (this.disposeTimeout !== 0) {
            timer = setTimeout(this.destroy.bind(this, res), this.disposeTimeout);    
        }
    
        try {
            debug('Attempting to gracefully remove resource (id=%s)', getId(res));
            this._dispose(res, function (e) {
                clearTimeout(timer);
                if (e) { this.emit('warn', e); }
                else { this._ensureMinimum(); }
                
                if (typeof cb === 'function') { cb(e); }
            }.bind(this));
        } catch (e) {
            clearTimeout(timer);
            this.emit('warn', e);
            if (typeof cb === 'function') { cb(e); }
        }
    };
    
    // attempt to gracefully close the pool
    Pool.prototype.end = function (cb) {
        cb = cb || function () { };
        
        this.ending = true;
        
        var closeResources = function () {
            debug('Closing resources');
            clearInterval(this.syncTimer);
            
            var count = this.pool.count(),
                errors = [ ];
            
            if (count === 0) {
                cb();
                return;
            }
            
            this.pool.forEach(function (value, key) {
                this.remove(key, function (err, res) {
                    if (err) { errors.push(err); }
                    
                    count--;
                    if (count === 0) {
                        debug('Resources closed');
                        if (errors.length) { cb(errors); }
                        else { cb(); }
                    }
                });
            }.bind(this));
        }.bind(this);
        
        // begin now, or wait until there are no pending requests
        if (this.available.length === this.pool.count() && this.requests.length === 0 && this.acquiring === 0) {
            closeResources();
        } else {
            debug('Waiting for active requests to conclude before closing resources');
            this.once('drain', closeResources);
        }
    };
    
    // close idle resources
    Pool.prototype._reap = function () {
        var n = this.pool.count(),
            i, c = 0, res, idleTimestamp,
            idleThreshold = (new Date()) - this.idleTimeout;
        
        debug('reap (cur=%d, av=%d)', n, this.available.length);
        
        for (i = this.available.length; n > this.min && i >= 0; i--) {
            res = this.available[i];
            idleTimestamp = this.pool.get(res);
            
            if (idleTimestamp < idleThreshold) {
                n--; c++;
                this.remove(res);
            }
        }
        
        if (c) { debug('Shrinking pool: destroying %d idle connections', c); }
    };
    
    // attempt to acquire at least the minimum quantity of resources
    Pool.prototype._ensureMinimum = function () {
        if (this.ending || this.destroyed) { return; }
        
        var n = this.min - (this.pool.count() + this.acquiring);
        if (n <= 0) { return; }
        
        debug('Attempting to acquire minimum resources (cur=%d, min=%d)', this.pool.count(), this.min);
        while (n--) { this._allocateResource(); }
    };
    
    // allocate a resource to a waiting request, if possible
    Pool.prototype._maybeAllocateResource = function () { // jshint maxstatements: 18
        // do nothing if there are no requests to serve
        if (this.requests.length === 0) { return; }
    
        // call callback if there is a request and a resource to give it
        if (this.available.length) {
            var res = this.available.shift(),
                req = this.requests.shift();
            
            debug('Reserving request for resource (id=%s)', getId(res));
            
            var abort = function () {
                debug('Releasing request to request list');
                this.requests.unshift(req);
                this.remove(res);
                this._maybeAllocateResource();
            }.bind(this);
            
            var timer = setTimeout(function () {
                debug('Ping timeout, removing resource (id=%s)', getId(res));
                abort();
            }, this.pingTimeout);
    
            try {
                debug('Pinging resource (id=%s)', getId(res));
                
                this._ping(res, function (err) {
                    clearTimeout(timer);
                    if (err) {
                        debug('Ping errored, releasing resource (id=%s)', getId(res));
                        this.emit('warn', err);
                        abort();
                        return;
                    }
                    
                    debug('Allocating resource (id=%s) to request; waited %ds', getId(res), ((new Date()) - req.ts) / 1000);
                    req.cb(null, res);
                }.bind(this));
            } catch (err) {
                debug('Synchronous throw attempting to ping resource (id=%s): %s', getId(res), err.message);
                this.emit('error', err);
                abort();
            }
            
            return;
        }
        
        // allocate a new resource if there is a request but no resource to give it
        // and there's room in the pool
        var pending = this.requests.length,
            toBeAvailable = this.available.length + this.acquiring,
            toBeTotal = this.pool.count() + this.acquiring;
        
        if (pending > toBeAvailable && toBeTotal < this.max) {
            debug('Growing pool: no resource to serve request (p=%d, tba=%d, tbt=%d, max=%d)', pending, toBeAvailable, toBeTotal, this.max);
            this._allocateResource();
        } else {
            debug('Not growing pool: pending=%d, to be available=%d', pending, toBeAvailable);
        }
    };
    
    // create a new resource
    Pool.prototype._allocateResource = function () {
        if (this.destroyed) {
            debug('Not allocating resource: destroyed');
            return;
        }
        
        debug('Attempting to acquire resource (cur=%d, ac=%d)', this.pool.count(), this.acquiring);
        
        // acquiring is asynchronous, don't over-allocate due to in-progress resource allocation
        this.acquiring++;
        
        var onError, timer;
        
        onError = function (err) {
            clearTimeout(timer);
            
            debug('Couldn\'t allocate new resource: %s', err.message);
            
            // throw an error if we haven't successfully allocated a resource yet
            if (this.live === false) {
                debug('Destroying pool: unable to acquire first resource');
                this._destroyPool();
                this.emit('error', err);
            }
        }.bind(this);
        
        if (this.acquireTimeout !== 0) {
            timer = setTimeout(function () {
                debug('Timed out acquiring resource');
                timer = null;
                this.acquiring--;
                
                onError(new Error('Timed out acquiring resource'));
                
                // timed out allocations are dropped; this could leave us below the
                // minimum threshold; try to bring us up to the minimum, but don't spam
                setTimeout(this._ensureMinimum.bind(this), 2 * 1000);
            }.bind(this), this.acquireTimeout);        
        }
        
        try {
            this._acquire(function (err, res) { // jshint maxstatements: 20
                setId(res);
                
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                    this.acquiring--;
                } else if (!err) {
                    debug('Attempting to gracefully clean up late-arrived resource (id=%s)', getId(res));
                    this.remove(res, true);
                    return;
                }
                
                if (err) {
                    onError(err);
                    return;
                }
                
                this.live = true;
                
                debug('Successfully allocated new resource (cur=%d, ac=%d, id=%s)', this.pool.count(), this.acquiring, getId(res));
                
                this.pool.set(res, new Date());
                this.available.unshift(res);
                
                // normally 'drain' is emitted when the pending requests queue is empty; pending requests
                // are the primary source of acquiring new resources. the pool minimum can cause resources
                // to be acquired with no pending requests, however. if pool.end() is called while resources
                // are being acquired to fill the minimum, the 'drain' event will never get triggered because
                // there were no requests pending. in this case, we want to trigger the cleanup routine that
                // normally binds to 'drain'
                if (this.ending && this.requests.length === 0 && this.acquiring === 0) {
                    this.emit('drain');
                    return;
                }            
                
                // we've successfully acquired a resource, and we only get
                // here if something wants it, so... do that
                this._maybeAllocateResource();
            }.bind(this));
        } catch (e) {
            onError(e);
        }
    };
    
    // destroy the pool itself
    Pool.prototype._destroyPool = function () {
        this.destroyed = true;
        clearInterval(this.syncTimer);
        this.pool.forEach(function (value, key) {
            this.destroy(key);
        }.bind(this));
        this.pool.clear();
        
        // requests is a deque, no forEach
        var req;
        while (( req = this.requests.shift() )) {
            req.cb(new Error('Pool was destroyed'));
        }
        
        this.acquiring = 0;
        this.available.length = 0;
    };
    
    Pool._validNum = validNum;
    
    module.exports = Pool;
    
  provide("pool2/lib/pool", module.exports);
}(global));

// pakmanager:pool2/lib/cluster
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var HashMap = require('hashmap'),
        Pool =  require('pool2/lib/pool');
        
    var inherits = require('util').inherits,
        EventEmitter = require('events').EventEmitter;
    
    function Cluster(pools) {
        EventEmitter.call(this);
        
        if (!pools) { pools = [ ]; }
        else if (!Array.isArray(pools)) { pools = [ pools ]; }
        
        this.pools = [ ];
        this.caps = { };
        this.removeListeners = new HashMap();
        this.sources = new HashMap();
    
        this.ended = false;
        
        pools.forEach(this.addPool, this);
    }
    inherits(Cluster, EventEmitter);
    
    Cluster.prototype.addPool = function (pool) {
        if (this.ended) {
            throw new Error('Cluster.addPool(): Cluster is ended');
        }
        if (!(pool instanceof Pool)) {
            throw new Error('Cluster.addPool(): Not a valid pool');
        }
        if (this.pools.indexOf(pool) > -1) {
            throw new Error('Cluster.addPool(): Pool already in cluster');
        }
        
        this.pools.push(pool);
        this._bindListeners(pool);
        this._addCapabilities(pool);
    };
    Cluster.prototype.removePool = function (pool) {
        if (!(pool instanceof Pool)) {
            throw new Error('Cluster.removePool(): Not a valid pool');
        }
        var idx = this.pools.indexOf(pool);
        if (idx === -1) {
            throw new Error('Cluster.removePool(): Pool not in cluster');
        }
        
        this.pools.splice(idx, 1);
        this._unbindListeners(pool);
        this._removeCapabilities(pool);
    };
    Cluster.prototype.acquire = function (cap, cb) { // jshint maxstatements: 20, maxcomplexity: 8
        if (typeof cap === 'function') {
            cb = cap;
            cap = void 0;
        }
        if (typeof cb !== 'function') {
            this.emit('error', new Error('Cluster.acquire(): Callback is required'));
            return;
        }
        if (this.ended) {
            cb(new Error('Cluster.acquire(): Cluster is ended'));
            return;
        }
        
        var sources = this.pools;
        if (cap) {
            if (!this.caps[cap] || !this.caps[cap].length) {
                cb(new Error('Cluster.acquire(): No pools can fulfil capability: ' + cap));
                return;
            }
            sources = this.caps[cap];
        }
        
        var pool = sources.filter(function (pool) {
            var stats = pool.stats();
            return stats.queued < stats.maxRequests;
        }).sort(function (a, b) {
            var statsA = a.stats(),
                statsB = b.stats();
    
            return (statsB.available - statsB.queued) - (statsA.available - statsA.queued);
        })[0];
        
        if (!pool) {
            cb(new Error('Cluster.acquire(): No pools available'));
            return;
        }
        
        pool.acquire(function (err, res) {
            if (err) { cb(err); return; }
            this.sources.set(res, pool);
            process.nextTick(cb.bind(null, null, res));
        }.bind(this));
    };
    Cluster.prototype.release = function (res) {
        if (!this.sources.has(res)) {
            var err = new Error('Cluster.release(): Unknown resource');
            err.res = res;
            this.emit('error', err);
            return;
        }
        var pool = this.sources.get(res);
        this.sources.remove(res);
        pool.release(res);
    };
    Cluster.prototype.end = function (cb) {
        if (this.ended) {
            if (typeof cb === 'function') {
                cb(new Error('Cluster.end(): Cluster is already ended'));
            }
            return;
        }
    
        this.ended = true;
        
        var count = this.pools.length,
            errs = [ ];
        
        this.pools.forEach(function (pool) {
            pool.end(function (err, res) {
                this.removePool(pool);
                if (err) { errs.concat(err); }
                count--;
                if (count === 0 && typeof cb === 'function') {
                    cb(errs.length ? errs : null);
                }
            }.bind(this));
        }, this);
    };
    
    Cluster.prototype._addCapabilities = function (pool) {
        if (!pool.capabilities || !Array.isArray(pool.capabilities)) { return; }
        pool.capabilities.forEach(function (cap) {
            if (typeof cap !== 'string') { return; }
            this.caps[cap] = this.caps[cap] || [ ];
            this.caps[cap].push(pool);
        }, this);
    };
    Cluster.prototype._removeCapabilities = function (pool) {
        if (!pool.capabilities || !Array.isArray(pool.capabilities)) { return; }
        pool.capabilities.forEach(function (cap) {
            if (typeof cap !== 'string' || !Array.isArray(this.caps[cap])) { return; }
            var idx = this.caps[cap].indexOf(pool);
            if (idx > -1) { this.caps[cap].splice(idx, 1); }
        }, this);
    };
    Cluster.prototype._bindListeners = function (pool) {
        var onError, onWarn;
    
        onError = function (err) {
            err.source = pool;
            this.emit('error', err);
        }.bind(this);
        
        onWarn = function (err) {
            err.source = pool;
            this.emit('warn', err);
        }.bind(this);
        
        pool.on('error', onError);
        pool.on('warn', onWarn);
        
        this.removeListeners.set(pool, function () {
            pool.removeListener('error', onError);
            pool.removeListener('warn', onWarn);
        });
    };
    Cluster.prototype._unbindListeners = function (pool) {
        this.removeListeners.get(pool)();
        this.removeListeners.remove(pool);
    };
    
    
    module.exports = Cluster;
    
  provide("pool2/lib/cluster", module.exports);
}(global));

// pakmanager:pool2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Pool =  require('pool2/lib/pool'),
        Cluster =  require('pool2/lib/cluster');
    
    Pool.Cluster = Cluster;
    module.exports = Pool;
    
  provide("pool2", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    module.exports = Readable;
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    var Stream = require('stream');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      options = options || {};
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // In streams that never have any data, and do push(null) right away,
      // the consumer can miss the 'end' event if they do some I/O before
      // consuming the stream.  So, we don't emit('end') until some reading
      // happens.
      this.calledRead = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (typeof chunk === 'string' && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null || chunk === undefined) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
    
          if (state.needReadable)
            emitReadable(stream);
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        ret = null;
    
        // In cases where the decoder did not receive enough data
        // to produce a full chunk, then immediately received an
        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
        // howMuchToRead will see this and coerce the amount to
        // read to zero (because it's looking at the length of the
        // first <Buffer > in state.buffer), and we'll end up here.
        //
        // This can only happen via state.decoder -- no other venue
        // exists for pushing a zero-length chunk into state.buffer
        // and triggering this behavior. In this case, we return our
        // remaining data and end the stream, if appropriate.
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
    
        if (state.length === 0)
          endReadable(this);
    
        return ret;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length - n <= state.highWaterMark)
        doRead = true;
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading)
        doRead = false;
    
      if (doRead) {
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read called its callback synchronously, then `reading`
      // will be false, and we need to re-evaluate how much data we
      // can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we happened to read() exactly the remaining amount in the
      // buffer, and the EOF has been seen at this point, then make sure
      // that we emit 'end' on the very next tick.
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // if we've ended and we have some data left, then emit
      // 'readable' now to make sure it gets picked up.
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
    
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    
    function emitReadable_(stream) {
      stream.emit('readable');
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        if (readable !== src) return;
        cleanup();
      }
    
      function onend() {
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        // the handler that waits for readable events after all
        // the data gets sucked out in flow.
        // This would be easier to follow with a .once() handler
        // in flow(), but that is too slow.
        this.on('readable', pipeOnReadable);
    
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
    
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
    
      while (state.pipesCount && null !== (chunk = src.read())) {
    
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
    
        src.emit('data', chunk);
    
        // if anyone needs a drain, then we have to wait for that.
        if (state.awaitDrain > 0)
          return;
      }
    
      // if every destination was unpiped, either before entering this
      // function, or in the while loop, then stop flowing.
      //
      // NB: This is a pretty rare edge case.
      if (state.pipesCount === 0) {
        state.flowing = false;
    
        // if there were data event listeners added, then switch to old mode.
        if (EE.listenerCount(src, 'data') > 0)
          emitDataEvents(src);
        return;
      }
    
      // at this point, no one needed a drain, so we just ran out of data
      // on the next readable event, start it over again.
      state.ranOut = true;
    }
    
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      if (ev === 'data' && !this._readableState.flowing)
        emitDataEvents(this);
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit('resume');
    };
    
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit('pause');
    };
    
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
    
      if (state.flowing) {
        // https://github.com/isaacs/readable-stream/issues/16
        throw new Error('Cannot switch to old mode now.');
      }
    
      var paused = startPaused || false;
      var readable = false;
    
      // convert to an old-style stream.
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
    
      stream.on('readable', function() {
        readable = true;
    
        var c;
        while (!paused && (null !== (c = stream.read())))
          stream.emit('data', c);
    
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
    
      stream.pause = function() {
        paused = true;
        this.emit('pause');
      };
    
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit('readable');
          });
        else
          this.read(0);
        this.emit('resume');
      };
    
      // now make it start, just in case it hadn't already.
      stream.emit('readable');
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        //if (state.objectMode && util.isNullOrUndefined(chunk))
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (typeof stream[i] === 'function' &&
            typeof this[i] === 'undefined') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }}(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          // Check that we didn't get one last unshift.
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    module.exports = Writable;
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Stream = require('stream');
    
    util.inherits(Writable, Stream);
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    
    function WritableState(options, stream) {
      options = options || {};
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.buffer = [];
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = function() {};
    
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
    
      return ret;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
    
      return ret;
    }
    
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(stream, state);
    
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
    
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
    
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
    
        doWrite(stream, state, len, chunk, encoding, cb);
    
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          c++;
          break;
        }
      }
    
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (typeof chunk !== 'undefined' && chunk !== null)
        this.write(chunk, encoding);
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(stream, state) {
      return (state.ending &&
              state.length === 0 &&
              !state.finished &&
              !state.writing);
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit('finish');
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      process.nextTick(this.end.bind(this));
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      var ts = this._transformState = new TransformState(options, this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      this.once('finish', function() {
        if ('function' === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_readable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    module.exports = Readable;
    
    /*<replacement>*/
    var isArray = require('isarray');
    /*</replacement>*/
    
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Readable.ReadableState = ReadableState;
    
    var EE = require('events').EventEmitter;
    
    /*<replacement>*/
    if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    /*</replacement>*/
    
    var Stream = require('stream');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var StringDecoder;
    
    util.inherits(Readable, Stream);
    
    function ReadableState(options, stream) {
      options = options || {};
    
      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
    
      // In streams that never have any data, and do push(null) right away,
      // the consumer can miss the 'end' event if they do some I/O before
      // consuming the stream.  So, we don't emit('end') until some reading
      // happens.
      this.calledRead = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
    
    
      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;
    
      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;
    
      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;
    
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
    
      this._readableState = new ReadableState(options, this);
    
      // legacy
      this.readable = true;
    
      Stream.call(this);
    }
    
    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
    
      if (typeof chunk === 'string' && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
    
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    
    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null || chunk === undefined) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
    
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
    
          if (state.needReadable)
            emitReadable(stream);
    
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    
      return needMoreData(state);
    }
    
    
    
    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended &&
             (state.needReadable ||
              state.length < state.highWaterMark ||
              state.length === 0);
    }
    
    // backwards compatibility.
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require('string_decoder/').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    
    // Don't raise the hwm > 128MB
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
    
      if (state.objectMode)
        return n === 0 ? 0 : 1;
    
      if (n === null || isNaN(n)) {
        // only flow one buffer at a time
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
    
      if (n <= 0)
        return 0;
    
      // If we're asking for more than the target buffer level,
      // then raise the water mark.  Bump up to the next highest
      // power of 2, to prevent increasing it excessively in tiny
      // amounts.
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
    
      // don't have that much.  return null, unless we've ended.
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
    
      return n;
    }
    
    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
    
      if (typeof n !== 'number' || n > 0)
        state.emittedReadable = false;
    
      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 &&
          state.needReadable &&
          (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
    
      n = howMuchToRead(n, state);
    
      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        ret = null;
    
        // In cases where the decoder did not receive enough data
        // to produce a full chunk, then immediately received an
        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
        // howMuchToRead will see this and coerce the amount to
        // read to zero (because it's looking at the length of the
        // first <Buffer > in state.buffer), and we'll end up here.
        //
        // This can only happen via state.decoder -- no other venue
        // exists for pushing a zero-length chunk into state.buffer
        // and triggering this behavior. In this case, we return our
        // remaining data and end the stream, if appropriate.
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
    
        if (state.length === 0)
          endReadable(this);
    
        return ret;
      }
    
      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
    
      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
    
      // if we currently have less than the highWaterMark, then also read some
      if (state.length - n <= state.highWaterMark)
        doRead = true;
    
      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading)
        doRead = false;
    
      if (doRead) {
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
          state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
      }
    
      // If _read called its callback synchronously, then `reading`
      // will be false, and we need to re-evaluate how much data we
      // can return to the user.
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
    
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
    
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
    
      state.length -= n;
    
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
    
      // If we happened to read() exactly the remaining amount in the
      // buffer, and the EOF has been seen at this point, then make sure
      // that we emit 'end' on the very next tick.
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
    
      return ret;
    };
    
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    
    
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
    
      // if we've ended and we have some data left, then emit
      // 'readable' now to make sure it gets picked up.
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    
    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
    
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    
    function emitReadable_(stream) {
      stream.emit('readable');
    }
    
    
    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended &&
             state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    
    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function(n) {
      this.emit('error', new Error('not implemented'));
    };
    
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
    
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
    
      var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr;
    
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once('end', endFn);
    
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        if (readable !== src) return;
        cleanup();
      }
    
      function onend() {
        dest.end();
      }
    
      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
    
      function cleanup() {
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
    
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
    
      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0)
          dest.emit('error', er);
      }
      // This is a brutally ugly hack to make sure that our error handler
      // is attached before any userland ones.  NEVER DO THIS.
      if (!dest._events || !dest._events.error)
        dest.on('error', onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
    
    
    
      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
    
      function unpipe() {
        src.unpipe(dest);
      }
    
      // tell the dest that it's being piped to
      dest.emit('pipe', src);
    
      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        // the handler that waits for readable events after all
        // the data gets sucked out in flow.
        // This would be easier to follow with a .once() handler
        // in flow(), but that is too slow.
        this.on('readable', pipeOnReadable);
    
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
    
      return dest;
    };
    
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
    
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
    
      while (state.pipesCount && null !== (chunk = src.read())) {
    
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
    
        src.emit('data', chunk);
    
        // if anyone needs a drain, then we have to wait for that.
        if (state.awaitDrain > 0)
          return;
      }
    
      // if every destination was unpiped, either before entering this
      // function, or in the while loop, then stop flowing.
      //
      // NB: This is a pretty rare edge case.
      if (state.pipesCount === 0) {
        state.flowing = false;
    
        // if there were data event listeners added, then switch to old mode.
        if (EE.listenerCount(src, 'data') > 0)
          emitDataEvents(src);
        return;
      }
    
      // at this point, no one needed a drain, so we just ran out of data
      // on the next readable event, start it over again.
      state.ranOut = true;
    }
    
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    
    
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
    
      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0)
        return this;
    
      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
          return this;
    
        if (!dest)
          dest = state.pipes;
    
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit('unpipe', this);
        return this;
      }
    
      // slow case. multiple pipe destinations.
    
      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener('readable', pipeOnReadable);
        state.flowing = false;
    
        for (var i = 0; i < len; i++)
          dests[i].emit('unpipe', this);
        return this;
      }
    
      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
    
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    
      dest.emit('unpipe', this);
    
      return this;
    };
    
    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
    
      if (ev === 'data' && !this._readableState.flowing)
        emitDataEvents(this);
    
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
    
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    
    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit('resume');
    };
    
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit('pause');
    };
    
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
    
      if (state.flowing) {
        // https://github.com/isaacs/readable-stream/issues/16
        throw new Error('Cannot switch to old mode now.');
      }
    
      var paused = startPaused || false;
      var readable = false;
    
      // convert to an old-style stream.
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
    
      stream.on('readable', function() {
        readable = true;
    
        var c;
        while (!paused && (null !== (c = stream.read())))
          stream.emit('data', c);
    
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
    
      stream.pause = function() {
        paused = true;
        this.emit('pause');
      };
    
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit('readable');
          });
        else
          this.read(0);
        this.emit('resume');
      };
    
      // now make it start, just in case it hadn't already.
      stream.emit('readable');
    }
    
    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
    
      var self = this;
      stream.on('end', function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self.push(chunk);
        }
    
        self.push(null);
      });
    
      stream.on('data', function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
    
        // don't skip over falsy values in objectMode
        //if (state.objectMode && util.isNullOrUndefined(chunk))
        if (state.objectMode && (chunk === null || chunk === undefined))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
    
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
    
      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (typeof stream[i] === 'function' &&
            typeof this[i] === 'undefined') {
          this[i] = function(method) { return function() {
            return stream[method].apply(stream, arguments);
          }}(i);
        }
      }
    
      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
    
      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
    
      return self;
    };
    
    
    
    // exposed for testing purposes only.
    Readable._fromList = fromList;
    
    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
    
      // nothing in the list, definitely empty.
      if (list.length === 0)
        return null;
    
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        // read it all, truncate the array.
        if (stringMode)
          ret = list.join('');
        else
          ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        // read just some of it.
        if (n < list[0].length) {
          // just take a part of the first list item.
          // slice is the same for buffers and strings.
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          // first list is a perfect match
          ret = list.shift();
        } else {
          // complex case.
          // we have enough to cover it, but it spans past the first buffer.
          if (stringMode)
            ret = '';
          else
            ret = new Buffer(n);
    
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
    
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
    
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
    
            c += cpy;
          }
        }
      }
    
      return ret;
    }
    
    function endReadable(stream) {
      var state = stream._readableState;
    
      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0)
        throw new Error('endReadable called on non-empty stream');
    
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          // Check that we didn't get one last unshift.
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
    function indexOf (xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    
  provide("readable-stream/lib/_stream_readable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_writable.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // A bit simpler than readable streams.
    // Implement an async ._write(chunk, cb), and it'll handle all
    // the drain event emission and buffering.
    
    module.exports = Writable;
    
    /*<replacement>*/
    var Buffer = require('buffer').Buffer;
    /*</replacement>*/
    
    Writable.WritableState = WritableState;
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Stream = require('stream');
    
    util.inherits(Writable, Stream);
    
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    
    function WritableState(options, stream) {
      options = options || {};
    
      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;
    
      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;
    
      // cast to ints.
      this.highWaterMark = ~~this.highWaterMark;
    
      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;
    
      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
    
      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';
    
      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;
    
      // a flag to see when we're in the middle of a write.
      this.writing = false;
    
      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, becuase any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;
    
      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;
    
      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
    
      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;
    
      // the amount that is being written when _write is called.
      this.writelen = 0;
    
      this.buffer = [];
    
      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;
    }
    
    function Writable(options) {
      var Duplex =  require('readable-stream/lib/_stream_duplex');
    
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
    
      this._writableState = new WritableState(options, this);
    
      // legacy.
      this.writable = true;
    
      Stream.call(this);
    }
    
    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    
    
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      process.nextTick(function() {
        cb(er);
      });
    }
    
    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer.isBuffer(chunk) &&
          'string' !== typeof chunk &&
          chunk !== null &&
          chunk !== undefined &&
          !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
    
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
    
      if (typeof cb !== 'function')
        cb = function() {};
    
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
    
      return ret;
    };
    
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode &&
          state.decodeStrings !== false &&
          typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    
    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
    
      state.length += len;
    
      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret)
        state.needDrain = true;
    
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
    
      return ret;
    }
    
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
    
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
    
      onwriteStateUpdate(state);
    
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(stream, state);
    
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
    
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    
    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    
    
    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
    
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
    
        doWrite(stream, state, len, chunk, encoding, cb);
    
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          c++;
          break;
        }
      }
    
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
    
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
    
      if (typeof chunk !== 'undefined' && chunk !== null)
        this.write(chunk, encoding);
    
      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    
    
    function needFinish(stream, state) {
      return (state.ending &&
              state.length === 0 &&
              !state.finished &&
              !state.writing);
    }
    
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit('finish');
      }
      return need;
    }
    
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
    
  provide("readable-stream/lib/_stream_writable.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_duplex.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a duplex stream is just a stream that is both readable and writable.
    // Since JS doesn't have multiple prototypal inheritance, this class
    // prototypally inherits from Readable, and then parasitically from
    // Writable.
    
    module.exports = Duplex;
    
    /*<replacement>*/
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    /*</replacement>*/
    
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    var Readable =  require('readable-stream/lib/_stream_readable');
    var Writable =  require('readable-stream/lib/_stream_writable');
    
    util.inherits(Duplex, Readable);
    
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
    
      Readable.call(this, options);
      Writable.call(this, options);
    
      if (options && options.readable === false)
        this.readable = false;
    
      if (options && options.writable === false)
        this.writable = false;
    
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    
      this.once('end', onend);
    }
    
    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended)
        return;
    
      // no more data can be written.
      // But allow more writes to happen in this tick.
      process.nextTick(this.end.bind(this));
    }
    
    function forEach (xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    
  provide("readable-stream/lib/_stream_duplex.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_transform.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    
    module.exports = Transform;
    
    var Duplex =  require('readable-stream/lib/_stream_duplex');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(Transform, Duplex);
    
    
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
    
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
    
      var cb = ts.writecb;
    
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    
      ts.writechunk = null;
      ts.writecb = null;
    
      if (data !== null && data !== undefined)
        stream.push(data);
    
      if (cb)
        cb(er);
    
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    
    
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
    
      Duplex.call(this, options);
    
      var ts = this._transformState = new TransformState(options, this);
    
      // when the writable side finishes, then flush out anything remaining.
      var stream = this;
    
      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;
    
      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
    
      this.once('finish', function() {
        if ('function' === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    
    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform ||
            rs.needReadable ||
            rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    
    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
    
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    
    
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
    
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
    
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
    
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
    
      return stream.push(null);
    }
    
  provide("readable-stream/lib/_stream_transform.js", module.exports);
}(global));

// pakmanager:readable-stream/lib/_stream_passthrough.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // a passthrough stream.
    // basically just the most minimal sort of Transform stream.
    // Every written chunk gets output as-is.
    
    module.exports = PassThrough;
    
    var Transform =  require('readable-stream/lib/_stream_transform');
    
    /*<replacement>*/
    var util = require('core-util-is');
    util.inherits = require('inherits');
    /*</replacement>*/
    
    util.inherits(PassThrough, Transform);
    
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
    
      Transform.call(this, options);
    }
    
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    
  provide("readable-stream/lib/_stream_passthrough.js", module.exports);
}(global));

// pakmanager:readable-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
    exports = module.exports =  require('readable-stream/lib/_stream_readable.js');
    exports.Stream = Stream;
    exports.Readable = exports;
    exports.Writable =  require('readable-stream/lib/_stream_writable.js');
    exports.Duplex =  require('readable-stream/lib/_stream_duplex.js');
    exports.Transform =  require('readable-stream/lib/_stream_transform.js');
    exports.PassThrough =  require('readable-stream/lib/_stream_passthrough.js');
    
  provide("readable-stream", module.exports);
}(global));

// pakmanager:tildify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var userHome = require('user-home');
    
    module.exports = function (str) {
    	return str.replace(userHome, '~');
    };
    
  provide("tildify", module.exports);
}(global));

// pakmanager:v8flags
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // this entire module is depressing. i should have spent my time learning
    // how to patch v8 so that these options would just be available on the
    // process object.
    
    const os = require('os');
    const fs = require('fs');
    const path = require('path');
    const execFile = require('child_process').execFile;
    const env = process.env;
    const user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
    const configfile = '.v8flags.'+process.versions.v8+'.'+user+'.json';
    const exclusions = ['--help'];
    
    const failureMessage = [
      'Unable to cache a config file for v8flags to a your home directory',
      'or a temporary folder. To fix this problem, please correct your',
      'environment by setting HOME=/path/to/home or TEMP=/path/to/temp.',
      'NOTE: the user running this must be able to access provided path.',
      'If all else fails, please open an issue here:',
      'http://github.com/tkellen/js-v8flags'
    ].join('\n');
    
    function fail (err) {
      err.message += '\n\n' + failureMessage;
      return err;
    }
    
    function openConfig (cb) {
      var userHome = require('user-home');
      var configpath = path.join(userHome || os.tmpdir(), configfile);
      var content;
      try {
        content = require(configpath);
        process.nextTick(function () {
          cb(null, content);
        });
      } catch (e) {
        fs.open(configpath, 'w+', function (err, fd) {
          if (err) {
            return cb(fail(err));
          }
          return cb(null, fd);
        });
      }
    }
    
    function writeConfig (fd, cb) {
      execFile(process.execPath, ['--v8-options'], function (execErr, result) {
        var flags;
        if (execErr) {
          return cb(execErr);
        }
        flags = result.match(/\s\s--(\w+)/gm).map(function (match) {
          return match.substring(2);
        }).filter(function (name) {
          return exclusions.indexOf(name) === -1;
        });
        var buf = new Buffer(JSON.stringify(flags));
        fs.write(fd, buf, 0, buf.length, 0, function (writeErr, bytesWritten, buffer) {
          fs.close(fd, function (closeErr) {
            var err = writeErr || closeErr;
            if (err) {
              return cb(fail(err));
            }
            return cb(null, JSON.parse(buffer.toString()));
          });
        });
      });
    }
    
    module.exports = function (cb) {
      openConfig(function (err, result) {
        if (err) {
          return cb(fail(err));
        }
        if (typeof result === 'number') {
          return writeConfig(result, cb);
        }
        return cb(null, result);
      });
    };
    
    module.exports.configfile = configfile;
    
  provide("v8flags", module.exports);
}(global));

// pakmanager:bookshelf/lib/helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Helpers
    // ---------------
    var _     = require('lodash');
    var chalk = require('chalk')
    
    var helpers = {
    
      // Sets the constraints necessary during a `model.save` call.
      saveConstraints: function(model, relatedData) {
        var data = {};
        if (relatedData && relatedData.type && relatedData.type !== 'belongsToMany' && relatedData.type !== 'belongsTo') {
          data[relatedData.key('foreignKey')] = relatedData.parentFk || model.get(relatedData.key('foreignKey'));
          if (relatedData.isMorph()) data[relatedData.key('morphKey')] = relatedData.key('morphValue');
        }
        return model.set(data);
      },
    
      // Finds the specific `morphTo` table we should be working with, or throws
      // an error if none is matched.
      morphCandidate: function(candidates, foreignTable) {
        var Target = _.find(candidates, function(Candidate) {
          return (_.result(Candidate.prototype, 'tableName') === foreignTable);
        });
        if (!Target) {
          throw new Error('The target polymorphic model was not found');
        }
        return Target;
      },
    
      // If there are no arguments, return the current object's
      // query builder (or create and return a new one). If there are arguments,
      // call the query builder with the first argument, applying the rest.
      // If the first argument is an object, assume the keys are query builder
      // methods, and the values are the arguments for the query.
      query: function(obj, args) {
        obj._knex = obj._knex || obj._builder(_.result(obj, 'tableName'));
        if (args.length === 0) return obj._knex;
        var method = args[0];
        if (_.isFunction(method)) {
          method.call(obj._knex, obj._knex);
        } else if (_.isObject(method)) {
          for (var key in method) {
            var target = _.isArray(method[key]) ?  method[key] : [method[key]];
            obj._knex[key].apply(obj._knex, target);
          }
        } else {
          obj._knex[method].apply(obj._knex, args.slice(1));
        }
        return obj;
      },
    
      error: function(msg) {
        console.log(chalk.red(msg))
      },
    
      warn: function(msg) {
        console.log(chalk.yellow(msg))
      },
    
      deprecate: function(a, b) {
        helpers.warn(a + ' has been deprecated, please use ' + b + ' instead')
      }
    
    };
    
    
    module.exports = helpers
  provide("bookshelf/lib/helpers", module.exports);
}(global));

// pakmanager:bookshelf/lib/base/promise
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Promise = require('bluebird/js/main/promise')();
    var helpers =  require('bookshelf/lib/helpers')
    
    Promise.prototype.yield = function() {
      helpers.deprecate('.yield', '.return')
      return this.return.apply(this, arguments);
    }
    Promise.prototype.ensure = function() {
      helpers.deprecate('.ensure', '.finally')
      return this.finally.apply(this, arguments);
    }
    Promise.prototype.otherwise = function() {
      helpers.deprecate('.otherwise', '.catch')
      return this.catch.apply(this, arguments);
    }
    Promise.prototype.exec = function() {
      helpers.deprecate('bookshelf.exec', 'bookshelf.asCallback')
      return this.nodeify.apply(this, arguments);
    };
    
    module.exports = Promise;
  provide("bookshelf/lib/base/promise", module.exports);
}(global));

// pakmanager:bookshelf/lib/base/events
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Events
    // ---------------
    
    var Promise      =  require('bookshelf/lib/base/promise');
    var inherits     = require('inherits');
    var EventEmitter = require('events').EventEmitter;
    var _            = require('lodash');
    
    function Events() {
      EventEmitter.apply(this, arguments);
    }
    inherits(Events, EventEmitter);
    
    // Regular expression used to split event strings.
    var eventSplitter = /\s+/;
    Events.prototype.on = function(name, handler) {
      // Handle space separated event names.
      if (eventSplitter.test(name)) {
        var names = name.split(eventSplitter);
        for (var i = 0, l = names.length; i < l; i++) {
          this.on(names[i], handler);
        }
        return this;
      }
      return EventEmitter.prototype.on.apply(this, arguments);
    };
    
    // Add "off", "trigger", and "" method, for parity with Backbone.Events
    Events.prototype.off = function(event, listener) {
      if (arguments.length === 0) {
        return this.removeAllListeners();
      }
      if (arguments.length === 1) {
        return this.removeAllListeners(event);
      }
      return this.removeListener(event, listener);
    };
    Events.prototype.trigger = function(name) {
      // Handle space separated event names.
      if (eventSplitter.test(name)) {
        var len  = arguments.length;
        var rest = new Array(len - 1);
        for (i = 1; i < len; i++) rest[i - 1] = arguments[i];
        var names = name.split(eventSplitter);
        for (var i = 0, l = names.length; i < l; i++) {
          EventEmitter.prototype.emit.apply(this, [names[i]].concat(rest));
        }
        return this;
      }
      EventEmitter.prototype.emit.apply(this, arguments);
      return this;
    };
    
    Events.prototype.triggerThen = function(name) {
      var i, l, rest, listeners = [];
      // Handle space separated event names.
      if (eventSplitter.test(name)) {
        var names = name.split(eventSplitter);
        for (i = 0, l = names.length; i < l; i++) {
          listeners = listeners.concat(this.listeners(names[i]));
        }
      } else {
        listeners = this.listeners(name);
      }
      var len = arguments.length;
      switch (len) {
        case 1: rest = []; break;
        case 2: rest = [arguments[1]]; break;
        case 3: rest = [arguments[1], arguments[2]]; break;
        default: rest = new Array(len - 1); for (i = 1; i < len; i++) rest[i - 1] = arguments[i];
      }
      var events = this
      return Promise.try(function() {
        var pending = [];
        for (i = 0, l = listeners.length; i < l; i++) {
          pending[i] = listeners[i].apply(events, rest);
        }
        return Promise.all(pending);
      })
    };
    Events.prototype.emitThen = Events.prototype.triggerThen;
    
    Events.prototype.once = function(name, callback, context) {
      var self = this;
      var once = _.once(function() {
          self.off(name, once);
          return callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    };
    
    module.exports = Events;
  provide("bookshelf/lib/base/events", module.exports);
}(global));

// pakmanager:bookshelf/lib/errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var createError = require('create-error');
    
    module.exports = {
    
      // Thrown when the model is not found and {require: true} is passed in the fetch options
      NotFoundError: createError('NotFoundError'),
    
      // Thrown when the collection is empty and {require: true} is passed in model.fetchAll or
      // collection.fetch
      EmptyError: createError('EmptyError'),
    
      // Thrown when an update affects no rows and {require: true} is passed in model.save.
      NoRowsUpdatedError: createError('NoRowsUpdatedError'),
    
      // Thrown when a delete affects no rows and {require: true} is passed in model.destroy.
      NoRowsDeletedError: createError('NoRowsDeletedError')
    
    };
    
  provide("bookshelf/lib/errors", module.exports);
}(global));

// pakmanager:bookshelf/lib/extend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Uses a hash of prototype properties and class properties to be extended.
    module.exports = function(protoProps, staticProps) {
      var parent = this;
      var child;
    
      // The constructor function for the new subclass is either defined by you
      // (the "constructor" property in your `extend` definition), or defaulted
      // by us to simply call the parent's constructor.
      if (protoProps && protoProps.hasOwnProperty('constructor')) {
        child = protoProps.constructor;
      } else {
        child = function(){ parent.apply(this, arguments); };
      }
    
      // Set the prototype chain to inherit from `Parent`
      child.prototype = Object.create(parent.prototype)
    
      if (protoProps) {
        var i = -1, keys = Object.keys(protoProps)
        while (++i < keys.length) {
          var key = keys[i]
          child.prototype[key] = protoProps[key]
        }    
      }
    
      if (staticProps) {
        keys = Object.keys(staticProps)
        i = -1
        while (++i < keys.length) {
          var key = keys[i]
          child[key] = staticProps[key]
        }
      }
    
      // Correctly set child's `prototype.constructor`.
      child.prototype.constructor = child;
    
      // Add static properties to the constructor function, if supplied.
      child.__proto__ = parent
    
      // If there is an "extended" function set on the parent,
      // call it with the extended child object.
      if (typeof parent.extended === "function") parent.extended(child);
    
      return child;
    };
    
  provide("bookshelf/lib/extend", module.exports);
}(global));

// pakmanager:bookshelf/lib/base/model
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Base Model
    // ---------------
    var _        = require('lodash');
    var inherits = require('inherits');
    
    var Events   =  require('bookshelf/lib/base/events');
    var Promise  =  require('bookshelf/lib/base/promise');
    var Errors   =  require('bookshelf/lib/errors');
    var slice    = Array.prototype.slice
    
    // List of attributes attached directly from the `options` passed to the constructor.
    var modelProps = ['tableName', 'hasTimestamps'];
    
    // The "ModelBase" is similar to the 'Active Model' in Rails,
    // it defines a standard interface from which other objects may inherit.
    function ModelBase(attributes, options) {
      var attrs = attributes || {};
      options   = options    || {};
      this.attributes = Object.create(null);
      this._reset();
      this.relations = {};
      this.cid  = _.uniqueId('c');
      if (options) {
        _.extend(this, _.pick(options, modelProps));
        if (options.parse) attrs = this.parse(attrs, options) || {};
      }
      this.set(attrs, options);
      this.initialize.apply(this, arguments);
    }
    inherits(ModelBase, Events);
    
    ModelBase.prototype.initialize = function() {};
    
    // The default value for the "id" attribute.
    ModelBase.prototype.idAttribute = 'id';
    
    // Get the value of an attribute.
    ModelBase.prototype.get = function(attr) {
      return this.attributes[attr];
    };
    
    // Set a property.
    ModelBase.prototype.set = function(key, val, options) {
      if (key == null) return this;
      var attrs;
    
      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }
      options = _.clone(options) || {};
    
      // Extract attributes and options.
      var hasChanged = false;
      var unset   = options.unset;
      var current = this.attributes;
      var prev    = this._previousAttributes;
    
      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
    
      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
          if (!_.isEqual(current[attr], val)) hasChanged = true;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }
      return this;
    };
    
    // A model is new if it has never been persisted, which we assume if it lacks an id.
    ModelBase.prototype.isNew = function() {
      return this.id == null;
    };
    
    ModelBase.prototype.serialize = function(options) {
      var attrs = _.clone(this.attributes);
      if (options && options.shallow) return attrs;
      var relations = this.relations;
      for (var key in relations) {
        var relation = relations[key];
        attrs[key] = relation.toJSON ? relation.toJSON(options) : relation;
      }
      if (options && options.omitPivot) return attrs;
      if (this.pivot) {
        var pivot = this.pivot.attributes;
        for (key in pivot) {
          attrs['_pivot_' + key] = pivot[key];
        }
      }
      return attrs;  
    }
    
    // Returns an object containing a shallow copy of the model attributes,
    // along with the `toJSON` value of any relations,
    // unless `{shallow: true}` is passed in the `options`.
    // Also includes _pivot_ keys for relations unless `{omitPivot: true}`
    // is passed in `options`.
    ModelBase.prototype.toJSON = function(options) {
      return this.serialize(options)
    };
    
    // Returns the string representation of the object.
    ModelBase.prototype.toString = function() {
      return '[Object Model]';
    };
    
    // Get the HTML-escaped value of an attribute.
    ModelBase.prototype.escape = function(key) {
      return _.escape(this.get(key));
    };
    
    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    ModelBase.prototype.has = function(attr) {
      return this.get(attr) != null;
    };
    
    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    ModelBase.prototype.parse = function(resp, options) {
      return resp;
    };
    
    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    ModelBase.prototype.unset = function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    };
    
    // Clear all attributes on the model, firing `"change"`.
    ModelBase.prototype.clear = function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    };
    
    // **format** converts a model into the values that should be saved into
    // the database table. The default implementation is just to pass the data along.
    ModelBase.prototype.format = function(attrs, options) {
      return attrs;
    };
    
    // Returns the related item, or creates a new
    // related item by creating a new model or collection.
    ModelBase.prototype.related = function(name) {
      return this.relations[name] || (this[name] ? this.relations[name] = this[name]() : void 0);
    };
    
    // Create a new model with identical attributes to this one,
    // including any relations on the current model.
    ModelBase.prototype.clone = function(options) {
      var model = new this.constructor(this.attributes);
      var relations = this.relations;
      for (var key in relations) {
        model.relations[key] = relations[key].clone();
      }
      model._previousAttributes = _.clone(this._previousAttributes);
      model.changed = setProps(Object.create(null), this.changed);
      return model;
    };
    
    // Sets the timestamps before saving the model.
    ModelBase.prototype.timestamp = function(options) {
      var d = new Date();
      var keys = (_.isArray(this.hasTimestamps) ? this.hasTimestamps : ['created_at', 'updated_at']);
      var vals = {};
      if (keys[1]) vals[keys[1]] = d;
      if (this.isNew(options) && keys[0] && (!options || options.method !== 'update')) vals[keys[0]] = d;
      return vals;
    };
    
    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    ModelBase.prototype.hasChanged = function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    };
    
    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    ModelBase.prototype.previous = function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    };
    
    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    ModelBase.prototype.previousAttributes = function() {
      return _.clone(this._previousAttributes);
    };
    
    // Resets the `_previousAttributes` and `changed` hash for the model.
    // Typically called after a `sync` action (save, fetch, delete) -
    ModelBase.prototype._reset = function() {
      this._previousAttributes = _.clone(this.attributes);
      this.changed = Object.create(null);
      return this;
    };
    
    // Set the changed properties on the object.
    function setProps(obj, hash) {
      var i = -1, keys = Object.keys(hash);
      while (++i < hash.length) {
        var key = hash[i]
        obj[key] = hash[key];
      }
    }
    
    // "_" methods that we want to implement on the Model.
    var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];
    
    // Mix in each "_" method as a proxy to `Model#attributes`.
    _.each(modelMethods, function(method) {
      ModelBase.prototype[method] = function() {
        var args = slice.call(arguments);
        args.unshift(this.attributes);
        return _[method].apply(_, args);
      };
    });
    
    ModelBase.extend =  require('bookshelf/lib/extend');
    
    module.exports = ModelBase;
    
  provide("bookshelf/lib/base/model", module.exports);
}(global));

// pakmanager:bookshelf/lib/base/eager
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Eager Base
    // ---------------
    
    // The EagerBase provides a scaffold for handling with eager relation
    // pairing, by queueing the appropriate related method calls with
    // a database specific `eagerFetch` method, which then may utilize
    // `pushModels` for pairing the models depending on the database need.
    
    var _         = require('lodash');
    var Promise   =  require('bookshelf/lib/base/promise');
    
    function EagerBase(parent, parentResponse, target) {
      this.parent = parent;
      this.parentResponse = parentResponse;
      this.target = target;
    }
    
    _.extend(EagerBase.prototype, {
    
      // This helper function is used internally to determine which relations
      // are necessary for fetching based on the `model.load` or `withRelated` option.
      fetch: Promise.method(function(options) {
        var relationName, related, relation;
        var target      = this.target;
        var handled     = this.handled = {};
        var withRelated = this.prepWithRelated(options.withRelated);
        var subRelated  = {};
    
        // Internal flag to determine whether to set the ctor(s) on the `Relation` object.
        target._isEager = true;
    
        // Eager load each of the `withRelated` relation item, splitting on '.'
        // which indicates a nested eager load.
        for (var key in withRelated) {
    
          related = key.split('.');
          relationName = related[0];
    
          // Add additional eager items to an array, to load at the next level in the query.
          if (related.length > 1) {
            var relatedObj = {};
            subRelated[relationName] || (subRelated[relationName] = []);
            relatedObj[related.slice(1).join('.')] = withRelated[key];
            subRelated[relationName].push(relatedObj);
          }
    
          // Only allow one of a certain nested type per-level.
          if (handled[relationName]) continue;
    
          relation = target[relationName]();
    
          if (!relation) throw new Error(relationName + ' is not defined on the model.');
    
          handled[relationName] = relation;
        }
    
        // Delete the internal flag from the model.
        delete target._isEager;
    
        // Fetch all eager loaded models, loading them onto
        // an array of pending deferred objects, which will handle
        // all necessary pairing with parent objects, etc.
        var pendingDeferred = [];
        for (relationName in handled) {
          pendingDeferred.push(this.eagerFetch(relationName, handled[relationName], _.extend({}, options, {
            isEager: true,
            withRelated: subRelated[relationName],
            _beforeFn: withRelated[relationName] || noop
          })));
        }
    
        // Return a deferred handler for all of the nested object sync
        // returning the original response when these syncs & pairings are complete.
        return Promise.all(pendingDeferred).return(this.parentResponse);
      }),
    
      // Prep the `withRelated` object, to normalize into an object where each
      // has a function that is called when running the query.
      prepWithRelated: function(withRelated) {
        if (!_.isArray(withRelated)) withRelated = [withRelated];
        var obj = {};
        for (var i = 0, l = withRelated.length; i < l; i++) {
          var related = withRelated[i];
          _.isString(related) ? obj[related] = noop : _.extend(obj, related);
        }
        return obj;
      },
    
      // Pushes each of the incoming models onto a new `related` array,
      // which is used to correcly pair additional nested relations.
      pushModels: function(relationName, handled, resp) {
        var models      = this.parent;
        var relatedData = handled.relatedData;
        var related     = [];
        for (var i = 0, l = resp.length; i < l; i++) {
          related.push(relatedData.createModel(resp[i]));
        }
        return relatedData.eagerPair(relationName, related, models);
      }
    
    });
    
    var noop = function() {};
    
    module.exports = EagerBase;
  provide("bookshelf/lib/base/eager", module.exports);
}(global));

// pakmanager:bookshelf/lib/base/collection
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Base Collection
    // ---------------
    
    // All exernal dependencies required in this scope.
    var _         = require('lodash');
    var inherits  = require('inherits');
    
    // All components that need to be referenced in this scope.
    var Events    =  require('bookshelf/lib/base/events');
    var Promise   =  require('bookshelf/lib/base/promise');
    var ModelBase =  require('bookshelf/lib/base/model');
    
    var array  = [];
    var push   = array.push;
    var slice  = array.slice;
    var splice = array.splice;
    
    function CollectionBase(models, options) {
      if (options) _.extend(this, _.pick(options, collectionProps));
      this._reset();
      this.initialize.apply(this, arguments)
      if (!_.isFunction(this.model)) {
        throw new Error('A valid `model` constructor must be defined for all collections.');
      }
      if (models) this.reset(models, _.extend({silent: true}, options));
    }
    inherits(CollectionBase, Events);
    
    // List of attributes attached directly from the constructor's options object.
    var collectionProps = ['model', 'Model', 'comparator'];
    
    // Copied over from Backbone.
    var setOptions = {add: true, remove: true, merge: true};
    var addOptions = {add: true, remove: false};
    
    CollectionBase.prototype.initialize = function() {};
    
    // The `tableName` on the associated Model, used in relation building.
    CollectionBase.prototype.tableName = function() {
      return _.result(this.model.prototype, 'tableName');
    };
    
    // The `idAttribute` on the associated Model, used in relation building.
    CollectionBase.prototype.idAttribute = function() {
      return this.model.prototype.idAttribute;
    };
    
    CollectionBase.prototype.toString = function() {
      return '[Object Collection]';
    };
    
    CollectionBase.prototype.serialize = function(options) {
      return this.map(function(model){ 
        return model.toJSON(options); 
      });
    }
    
    // The JSON representation of a Collection is an array of the
    // models' attributes.
    CollectionBase.prototype.toJSON = function(options) {
      return this.serialize(options)
    };
    
    // A simplified version of Backbone's `Collection#set` method,
    // removing the comparator, and getting rid of the temporary model creation,
    // since there's *no way* we'll be getting the data in an inconsistent
    // form from the database.
    CollectionBase.prototype.set = function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      if (!_.isArray(models)) models = models ? [models] : [];
      var i, l, id, model, attrs, existing;
      var at = options.at;
      var targetModel = this.model;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = add && remove ? [] : false;
    
      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i];
        if (attrs instanceof ModelBase) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute];
        }
    
        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) {
            modelMap[existing.cid] = true;
          }
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
          }
    
          // This is a new model, push it to the `toAdd` list.
        } else if (add) {
          if (!(model = this._prepareModel(attrs, options))) continue;
          toAdd.push(model);
    
          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
        if (order) order.push(existing || model);
      }
    
      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }
    
      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        this.length += toAdd.length;
        if (at != null) {
          splice.apply(this.models, [at, 0].concat(toAdd));
        } else {
          if (order) {
            this.models.length = 0;
          } else {
            order = toAdd;
          }
          for (i = 0, l = order.length; i < l; ++i) {
            this.models.push(order[i]);
          }
        }
      }
    
      if (options.silent) return this;
    
      // Trigger `add` events.
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }
      return this;
    };
    
    // Prepare a model or hash of attributes to be added to this collection.
    CollectionBase.prototype._prepareModel = function(attrs, options) {
      if (attrs instanceof ModelBase) return attrs;
      return new this.model(attrs, options);
    };
    
    // Run "Promise.map" over the models
    CollectionBase.prototype.mapThen = function(iterator, context) {
      return Promise.bind(context).thenReturn(this.models).map(iterator);
    };
    
    // Convenience method for invoke, returning a `Promise.all` promise.
    CollectionBase.prototype.invokeThen = function() {
      return Promise.all(this.invoke.apply(this, arguments));
    };
    
    // Run "reduce" over the models in the collection.
    CollectionBase.prototype.reduceThen = function(iterator, initialValue, context) {
      return Promise.bind(context).thenReturn(this.models).reduce(iterator, initialValue).bind();
    };
    
    CollectionBase.prototype.fetch = function() {
      return Promise.rejected('The fetch method has not been implemented');
    };
    
    // Add a model, or list of models to the set.
    CollectionBase.prototype.add = function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    };
    
    // Remove a model, or a list of models from the set.
    CollectionBase.prototype.remove = function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return singular ? models[0] : models;
    };
    
    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    CollectionBase.prototype.reset = function(models, options) {
      options = options || {};
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    };
    
    // Add a model to the end of the collection.
    CollectionBase.prototype.push = function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    };
    
    // Remove a model from the end of the collection.
    CollectionBase.prototype.pop = function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    };
    
    // Add a model to the beginning of the collection.
    CollectionBase.prototype.unshift = function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    };
    
    // Remove a model from the beginning of the collection.
    CollectionBase.prototype.shift = function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    };
    
    // Slice out a sub-array of models from the collection.
    CollectionBase.prototype.slice = function() {
      return slice.apply(this.models, arguments);
    };
    
    // Get a model from the set by id.
    CollectionBase.prototype.get = function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
    };
    
    // Get the model at the given index.
    CollectionBase.prototype.at = function(index) {
      return this.models[index];
    };
    
    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    CollectionBase.prototype.where = function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    };
    
    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    CollectionBase.prototype.findWhere = function(attrs) {
      return this.where(attrs, true);
    };
    
    // Force the collection to re-sort itself, based on a comporator defined on the model.
    CollectionBase.prototype.sort = function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});
    
      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }
    
      if (!options.silent) this.trigger('sort', this, options);
      return this;
    };
    
    // Pluck an attribute from each model in the collection.
    CollectionBase.prototype.pluck = function(attr) {
      return this.invoke('get', attr);
    };
    
    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    CollectionBase.prototype.create = function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp, options) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    };
    
    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    CollectionBase.prototype.parse = function(resp, options) {
      return resp;
    };
    
    // Create a new collection with an identical list of models as this one.
    CollectionBase.prototype.clone = function() {
      return new this.constructor(this.models);
    };
    
    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    CollectionBase.prototype._reset = function() {
      this.length = 0;
      this.models = [];
      this._byId  = Object.create(null);
    };
    
    // Internal method to sever a model's ties to a collection.
    CollectionBase.prototype._removeReference = function(model) {
      // TODO: Sever from the internal model cache.
    };
    
    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    CollectionBase.prototype._onModelEvent = function(event, model, collection, options) {
      // TOOD: See if we need anything here.
    };
    
    // Underscore methods that we want to implement on the Collection.
    // 90% of the core usefulness of Backbone Collections is actually implemented
    // right here:
    var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
      'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
      'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
      'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
      'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
      'lastIndexOf', 'isEmpty', 'chain'];
    
    // Mix in each Underscore method as a proxy to `Collection#models`.
    _.each(methods, function(method) {
      CollectionBase.prototype[method] = function() {
        var args = slice.call(arguments);
        args.unshift(this.models);
        return _[method].apply(_, args);
      };
    });
    
    // Underscore methods that take a property name as an argument.
    var attributeMethods = ['groupBy', 'countBy', 'sortBy'];
    
    // Use attributes instead of properties.
    _.each(attributeMethods, function(method) {
      CollectionBase.prototype[method] = function(value, context) {
        var iterator = _.isFunction(value) ? value : function(model) {
          return model.get(value);
        };
        return _[method](this.models, iterator, context);
      };
    });
    
    
    // List of attributes attached directly from the `options` passed to the constructor.
    var modelProps = ['tableName', 'hasTimestamps'];
    
    CollectionBase.extend =  require('bookshelf/lib/extend');
    
    module.exports = CollectionBase;
    
  provide("bookshelf/lib/base/collection", module.exports);
}(global));

// pakmanager:bookshelf/lib/sync
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Sync
    // ---------------
    var _       = require('lodash');
    var Promise =  require('bookshelf/lib/base/promise');
    
    // Sync is the dispatcher for any database queries,
    // taking the "syncing" `model` or `collection` being queried, along with
    // a hash of options that are used in the various query methods.
    // If the `transacting` option is set, the query is assumed to be
    // part of a transaction, and this information is passed along to `Knex`.
    var Sync = function(syncing, options) {
      options = options || {};
      this.query   = syncing.query();
      this.syncing = syncing.resetQuery();
      this.options = options;
      if (options.debug) this.query.debug();
      if (options.transacting) this.query.transacting(options.transacting);
    };
    
    _.extend(Sync.prototype, {
    
      // Prefix all keys of the passed in object with the
      // current table name
      prefixFields: function(fields) {
        var tableName = this.syncing.tableName;
        var prefixed = {};
        for (var key in fields) {
          prefixed[tableName + '.' + key] = fields[key];
        }
        return prefixed;
      },
    
      // Select the first item from the database - only used by models.
      first: Promise.method(function() {
        this.query.where(this.prefixFields(this.syncing.format(
          _.extend(Object.create(null), this.syncing.attributes)
        ))).limit(1);
        return this.select();
      }),
    
      // Runs a `select` query on the database, adding any necessary relational
      // constraints, resetting the query when complete. If there are results and
      // eager loaded relations, those are fetched and returned on the model before
      // the promise is resolved. Any `success` handler passed in the
      // options will be called - used by both models & collections.
      select: Promise.method(function() {
        var knex           = this.query
          , options        = this.options
          , relatedData    = this.syncing.relatedData
          , columnsInQuery = _.some(knex._statements, {grouping:'columns'})
          , columns;
    
        if (!relatedData) {
          columns = options.columns;
          // Call the function, if one exists, to constrain the eager loaded query.
          if (options._beforeFn) options._beforeFn.call(knex, knex);
          if (!_.isArray(columns)) {
            columns = columns ? [columns] :
              // if columns have been selected in a query closure, use them.
              // any user who does this is responsible for prefixing each
              // selected column with the correct table name. this will also
              // break withRelated queries if the dependent fkey fields are not
              // manually included. this is a temporary hack which will be
              // replaced by an upcoming rewrite.
              columnsInQuery ? [] : [_.result(this.syncing, 'tableName') + '.*'];
          }
        }
    
        // Set the query builder on the options, in-case we need to
        // access in the `fetching` event handlers.
        options.query = knex;
    
        return Promise.bind(this).then(function () {
          var fks = {}
            , through;
    
          // Inject all appropriate select costraints dealing with the relation
          // into the `knex` query builder for the current instance.
          if (relatedData) {
            if (relatedData.throughTarget) {
              fks[relatedData.key('foreignKey')] = relatedData.parentFk;
              through = new relatedData.throughTarget(fks);
              return through.triggerThen('fetching', through, relatedData.pivotColumns, options)
                .then(function () {
                  relatedData.pivotColumns = through.parse(relatedData.pivotColumns);
                  relatedData.selectConstraints(knex, options);
                });
            } else {
              relatedData.selectConstraints(knex, options);
            }
          }
        }).then(function () {
          return this.syncing.triggerThen('fetching', this.syncing, columns, options);
        }).then(function() {
          return knex.select(columns);
        });
      }),
    
      // Issues an `insert` command on the query - only used by models.
      insert: Promise.method(function() {
        var syncing = this.syncing;
        return this.query.insert(syncing.format(_.extend(Object.create(null), syncing.attributes)), syncing.idAttribute);
      }),
    
      // Issues an `update` command on the query - only used by models.
      update: Promise.method(function(attrs) {
        var syncing = this.syncing, query = this.query;
        if (syncing.id != null) query.where(syncing.idAttribute, syncing.id);
        if (_.where(query._statements, {grouping: 'where'}).length === 0) {
          throw new Error('A model cannot be updated without a "where" clause or an idAttribute.');
        }
        return query.update(syncing.format(_.extend(Object.create(null), attrs)));
      }),
    
      // Issues a `delete` command on the query.
      del: Promise.method(function() {
        var query = this.query, syncing = this.syncing;
        if (syncing.id != null) query.where(syncing.idAttribute, syncing.id);
        if (_.where(query._statements, {grouping: 'where'}).length === 0) {
          throw new Error('A model cannot be destroyed without a "where" clause or an idAttribute.');
        }
        return this.query.del();
      })
    
    });
    
    module.exports = Sync;
    
  provide("bookshelf/lib/sync", module.exports);
}(global));

// pakmanager:bookshelf/lib/eager
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // EagerRelation
    // ---------------
    var _         = require('lodash');
    var inherits  = require('inherits');
    
    var Helpers   =  require('bookshelf/lib/helpers');
    var Promise   =  require('bookshelf/lib/base/promise');
    var EagerBase =  require('bookshelf/lib/base/eager');
    
    // An `EagerRelation` object temporarily stores the models from an eager load,
    // and handles matching eager loaded objects with their parent(s). The `tempModel`
    // is only used to retrieve the value of the relation method, to know the constrains
    // for the eager query.
    function EagerRelation() {
      EagerBase.apply(this, arguments);
    }
    inherits(EagerRelation, EagerBase);
    
    _.extend(EagerRelation.prototype, {
    
      // Handles an eager loaded fetch, passing the name of the item we're fetching for,
      // and any options needed for the current fetch.
      eagerFetch: Promise.method(function(relationName, handled, options) {
        var relatedData = handled.relatedData;
    
        // skip eager loading for rows where the foreign key isn't set
        if (relatedData.parentFk === null) return;
    
        if (relatedData.type === 'morphTo') return this.morphToFetch(relationName, relatedData, options);
    
        return handled
          .sync(_.extend(options, {parentResponse: this.parentResponse}))
          .select()
          .bind(this)
          .tap(function(response) {
            return this._eagerLoadHelper(response, relationName, handled, _.omit(options, 'parentResponse'));
          });
      }),
    
      // Special handler for the eager loaded morph-to relations, this handles
      // the fact that there are several potential models that we need to be fetching against.
      // pairing them up onto a single response for the eager loading.
      morphToFetch: Promise.method(function(relationName, relatedData, options) {
        var groups = _.groupBy(this.parent, function(m) {
          var typeKeyName = relatedData.columnNames && relatedData.columnNames[0] ? relatedData.columnNames[0] : relatedData.morphName + '_type';
          return m.get(typeKeyName);
        });
        var pending = _.reduce(groups, function(memo, val, group) {
          var Target = Helpers.morphCandidate(relatedData.candidates, group);
          var target = new Target();
          var idKeyName = relatedData.columnNames && relatedData.columnNames[1] ? relatedData.columnNames[1] : relatedData.morphName + '_id';
          memo.push(target
            .query('whereIn',
              _.result(target, 'idAttribute'),
              _.uniq(_.invoke(groups[group], 'get', idKeyName))
            )
            .sync(options)
            .select()
            .bind(this)
            .tap(function(response) {
              return this._eagerLoadHelper(response, relationName, {
                relatedData: relatedData.instance('morphTo', Target, {morphName: relatedData.morphName, columnNames: relatedData.columnNames})
              }, options);
            }));
            return memo;
        }, [], this);
        return Promise.all(pending).then(function(resps) {
          return _.flatten(resps);
        });
      }),
    
      // Handles the eager load for both the `morphTo` and regular cases.
      _eagerLoadHelper: function(response, relationName, handled, options) {
        var relatedModels = this.pushModels(relationName, handled, response);
        var relatedData   = handled.relatedData;
    
        // If there is a response, fetch additional nested eager relations, if any.
        if (response.length > 0 && options.withRelated) {
          var relatedModel = relatedData.createModel();
    
          // If this is a `morphTo` relation, we need to do additional processing
          // to ensure we don't try to load any relations that don't look to exist.
          if (relatedData.type === 'morphTo') {
            var withRelated = this._filterRelated(relatedModel, options);
            if (withRelated.length === 0) return;
            options = _.extend({}, options, {withRelated: withRelated});
          }
          return new EagerRelation(relatedModels, response, relatedModel).fetch(options).return(response);
        }
      },
    
      // Filters the `withRelated` on a `morphTo` relation, to ensure that only valid
      // relations are attempted for loading.
      _filterRelated: function(relatedModel, options) {
    
        // By this point, all withRelated should be turned into a hash, so it should
        // be fairly simple to process by splitting on the dots.
        return _.reduce(options.withRelated, function(memo, val) {
          for (var key in val) {
            var seg = key.split('.')[0];
            if (_.isFunction(relatedModel[seg])) memo.push(val);
          }
          return memo;
        }, []);
      }
    
    });
    
    module.exports = EagerRelation;
    
  provide("bookshelf/lib/eager", module.exports);
}(global));

// pakmanager:bookshelf/lib/base/relation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Base Relation
    // ---------------
    
    var _              = require('lodash');
    var CollectionBase =  require('bookshelf/lib/base/collection');
    
    // Used internally, the `Relation` helps in simplifying the relationship building,
    // centralizing all logic dealing with type & option handling.
    function RelationBase(type, Target, options) {
      this.type = type;
      if (this.target = Target) {
        this.targetTableName   = _.result(Target.prototype, 'tableName');
        this.targetIdAttribute = _.result(Target.prototype, 'idAttribute');
      }
      _.extend(this, options);
    }
    
    _.extend(RelationBase.prototype, {
    
      // Creates a new relation instance, used by the `Eager` relation in
      // dealing with `morphTo` cases, where the same relation is targeting multiple models.
      instance: function(type, Target, options) {
        return new this.constructor(type, Target, options);
      },
    
      // Creates a new, unparsed model, used internally in the eager fetch helper
      // methods. (Parsing may mutate information necessary for eager pairing.)
      createModel: function(data) {
        if (this.target.prototype instanceof CollectionBase) {
          return new this.target.prototype.model(data)._reset();
        }
        return new this.target(data)._reset();
      },
    
      // Eager pair the models.
      eagerPair: function() {}
    
    });
    
    RelationBase.extend =  require('bookshelf/lib/extend');
    
    module.exports = RelationBase;
  provide("bookshelf/lib/base/relation", module.exports);
}(global));

// pakmanager:bookshelf/lib/model
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Model
    // ---------------
    var _              = require('lodash');
    var createError    = require('create-error')
    
    var Sync           =  require('bookshelf/lib/sync');
    var Helpers        =  require('bookshelf/lib/helpers');
    var EagerRelation  =  require('bookshelf/lib/eager');
    var Errors         =  require('bookshelf/lib/errors');
    
    var ModelBase      =  require('bookshelf/lib/base/model');
    var Promise        =  require('bookshelf/lib/base/promise');
    
    var BookshelfModel = ModelBase.extend({
    
      // The `hasOne` relation specifies that this table has exactly one of another type of object,
      // specified by a foreign key in the other table. The foreign key is assumed to be the singular of this
      // object's `tableName` with an `_id` suffix, but a custom `foreignKey` attribute may also be specified.
      hasOne: function(Target, foreignKey) {
        return this._relation('hasOne', Target, {foreignKey: foreignKey}).init(this);
      },
    
      // The `hasMany` relation specifies that this object has one or more rows in another table which
      // match on this object's primary key. The foreign key is assumed to be the singular of this object's
      // `tableName` with an `_id` suffix, but a custom `foreignKey` attribute may also be specified.
      hasMany: function(Target, foreignKey) {
        return this._relation('hasMany', Target, {foreignKey: foreignKey}).init(this);
      },
    
      // A reverse `hasOne` relation, the `belongsTo`, where the specified key in this table
      // matches the primary `idAttribute` of another table.
      belongsTo: function(Target, foreignKey) {
        return this._relation('belongsTo', Target, {foreignKey: foreignKey}).init(this);
      },
    
      // A `belongsToMany` relation is when there are many-to-many relation
      // between two models, with a joining table.
      belongsToMany: function(Target, joinTableName, foreignKey, otherKey) {
        return this._relation('belongsToMany', Target, {
          joinTableName: joinTableName, foreignKey: foreignKey, otherKey: otherKey
        }).init(this);
      },
    
      // A `morphOne` relation is a one-to-one polymorphic association from this model
      // to another model.
      morphOne: function(Target, name, columnNames, morphValue) {
        return this._morphOneOrMany(Target, name, columnNames, morphValue, 'morphOne');
      },
    
      // A `morphMany` relation is a polymorphic many-to-one relation from this model
      // to many another models.
      morphMany: function(Target, name, columnNames, morphValue) {
        return this._morphOneOrMany(Target, name, columnNames, morphValue, 'morphMany');
      },
    
      // Defines the opposite end of a `morphOne` or `morphMany` relationship, where
      // the alternate end of the polymorphic model is defined.
      morphTo: function(morphName) {
        var columnNames, remainder;
        if (!_.isString(morphName)) throw new Error('The `morphTo` name must be specified.');
        if (_.isArray(arguments[1])) {
          columnNames = arguments[1];
          remainder = _.rest(arguments, 2);
        } else {
          columnNames = null;
          remainder = _.rest(arguments);
        }
        return this._relation('morphTo', null, {morphName: morphName, columnNames: columnNames, candidates: remainder}).init(this);
      },
    
      // Used to define passthrough relationships - `hasOne`, `hasMany`,
      // `belongsTo` or `belongsToMany`, "through" a `Interim` model or collection.
      through: function(Interim, foreignKey, otherKey) {
        return this.relatedData.through(this, Interim, {throughForeignKey: foreignKey, otherKey: otherKey});
      },
    
      // Fetch a model based on the currently set attributes,
      // returning a model to the callback, along with any options.
      // Returns a deferred promise through the `Bookshelf.Sync`.
      // If `{require: true}` is set as an option, the fetch is considered
      // a failure if the model comes up blank.
      fetch: Promise.method(function(options) {
        options = options ? _.clone(options) : {};
    
        // Run the `first` call on the `sync` object to fetch a single model.
        return this.sync(options)
          .first()
          .bind(this)
    
          // Jump the rest of the chain if the response doesn't exist...
          .tap(function(response) {
            if (!response || response.length === 0) {
              if (options.require) throw new this.constructor.NotFoundError('EmptyResponse');
              return Promise.reject(null);
            }
          })
    
          // Now, load all of the data into the model as necessary.
          .tap(this._handleResponse)
    
          // If the "withRelated" is specified, we also need to eager load all of the
          // data on the model, as a side-effect, before we ultimately jump into the
          // next step of the model. Since the `columns` are only relevant to the current
          // level, ensure those are omitted from the options.
          .tap(function(response) {
            if (options.withRelated) {
              return this._handleEager(response, _.omit(options, 'columns'));
            }
          })
    
          .tap(function(response) {
            return this.triggerThen('fetched', this, response, options);
          })
          .return(this)
          .catch(function(err) {
            if (err === null) return err;
            throw err;
          });
      }),
    
      // Shortcut for creating a collection and fetching the associated models.
      fetchAll: function(options) {
        var collection = this.constructor.collection();
        collection._knex = this.query().clone();
        this.resetQuery();
        if (this.relatedData) collection.relatedData = this.relatedData;
        var model = this;
        return collection
          .on('fetching', function(collection, columns, options) {
            return model.triggerThen('fetching:collection', collection, columns, options);
          })
          .on('fetched', function(collection, resp, options) {
            return model.triggerThen('fetched:collection', collection, resp, options);
          })
          .fetch(options);
      },
    
      // Eager loads relationships onto an already populated `Model` instance.
      load: Promise.method(function(relations, options) {
        return Promise.bind(this)
          .then(function() {
            return [this.format(_.extend(Object.create(null), this.attributes))];
          })
          .then(function(response) {
            return this._handleEager(response, _.extend({}, options, {
              shallow: true,
              withRelated: _.isArray(relations) ? relations : [relations]
            }));
          })
          .return(this);
      }),
    
      // Sets and saves the hash of model attributes, triggering
      // a "creating" or "updating" event on the model, as well as a "saving" event,
      // to bind listeners for any necessary validation, logging, etc.
      // If an error is thrown during these events, the model will not be saved.
      save: Promise.method(function(key, val, options) {
        var attrs;
    
        // Handle both `"key", value` and `{key: value}` -style arguments.
        if (key == null || typeof key === "object") {
          attrs = key || {};
          options = _.clone(val) || {};
        } else {
          (attrs = {})[key] = val;
          options = options ? _.clone(options) : {};
        }
    
        return Promise.bind(this).then(function() {
          return this.isNew(options);
        }).then(function(isNew) {
    
          // If the model has timestamp columns,
          // set them as attributes on the model, even
          // if the "patch" option is specified.
          if (this.hasTimestamps) _.extend(attrs, this.timestamp(options));
    
          // Determine whether the model is new, based on whether the model has an `idAttribute` or not.
          options.method = (options.method || (isNew ? 'insert' : 'update')).toLowerCase();
          var method = options.method;
          var vals = attrs;
    
          // If the object is being created, we merge any defaults here
          // rather than during object creation.
          if (method === 'insert' || options.defaults) {
            var defaults = _.result(this, 'defaults');
            if (defaults) {
              vals = _.extend({}, defaults, this.attributes, vals);
            }
          }
    
          // Set the attributes on the model.
          this.set(vals, {silent: true});
    
          // If there are any save constraints, set them on the model.
          if (this.relatedData && this.relatedData.type !== 'morphTo') {
            Helpers.saveConstraints(this, this.relatedData);
          }
    
          // Gives access to the `query` object in the `options`, in case we need it
          // in any event handlers.
          var sync = this.sync(options);
          options.query = sync.query;
    
          return this.triggerThen((method === 'insert' ? 'creating saving' : 'updating saving'), this, attrs, options)
          .bind(this)
          .then(function() {
            return sync[options.method](method === 'update' && options.patch ? attrs : this.attributes);
          })
          .then(function(resp) {
    
            // After a successful database save, the id is updated if the model was created
            if (method === 'insert' && this.id == null) {
              this.attributes[this.idAttribute] = this.id = resp[0];
            } else if (method === 'update' && resp === 0) {
              if (options.require !== false) {
                throw new this.constructor.NoRowsUpdatedError('No Rows Updated');
              }
            }
    
            // In case we need to reference the `previousAttributes` for the this
            // in the following event handlers.
            options.previousAttributes = this._previousAttributes;
    
            this._reset();
    
            return this.triggerThen((method === 'insert' ? 'created saved' : 'updated saved'), this, resp, options);
          });
        })
        .return(this);
      }),
    
      // Destroy a model, calling a "delete" based on its `idAttribute`.
      // A "destroying" and "destroyed" are triggered on the model before
      // and after the model is destroyed, respectively. If an error is thrown
      // during the "destroying" event, the model will not be destroyed.
      destroy: Promise.method(function(options) {
        options = options ? _.clone(options) : {};
        var sync = this.sync(options);
        options.query = sync.query;
        return Promise.bind(this).then(function() {
          return this.triggerThen('destroying', this, options);
        }).then(function() {
          return sync.del();
        }).then(function(resp) {
          if (options.require && resp === 0) {
            throw new this.constructor.NoRowsDeletedError('No Rows Deleted');
          }
          this.clear();
          return this.triggerThen('destroyed', this, resp, options);
        }).then(this._reset);
      }),
    
      // Reset the query builder, called internally
      // each time a query is run.
      resetQuery: function() {
        this._knex = null;
        return this;
      },
    
      // Tap into the "query chain" for this model.
      query: function() {
        return Helpers.query(this, _.toArray(arguments));
      },
    
      // Add the most common conditional directly to the model, everything else
      // can be accessed with the `query` method.
      where: function() {
        var args = _.toArray(arguments);
        return this.query.apply(this, ['where'].concat(args));
      },
    
      // Creates and returns a new `Sync` instance.
      sync: function(options) {
        return new Sync(this, options);
      },
    
      // Helper for setting up the `morphOne` or `morphMany` relations.
      _morphOneOrMany: function(Target, morphName, columnNames, morphValue, type) {
        if (!_.isArray(columnNames)) {
          // Shift by one place
          morphValue = columnNames;
          columnNames = null;
        }
        if (!morphName || !Target) throw new Error('The polymorphic `name` and `Target` are required.');
        return this._relation(type, Target, {morphName: morphName, morphValue: morphValue, columnNames: columnNames}).init(this);
      },
    
      // Handles the response data for the model, returning from the model's fetch call.
      // Todo: {silent: true, parse: true}, for parity with collection#set
      // need to check on Backbone's status there, ticket #2636
      _handleResponse: function(response) {
        var relatedData = this.relatedData;
        this.set(this.parse(response[0]), {silent: true})._reset();
        if (relatedData && relatedData.isJoined()) {
          relatedData.parsePivot([this]);
        }
      },
    
      // Handle the related data loading on the model.
      _handleEager: function(response, options) {
        return new EagerRelation([this], response, this).fetch(options);
      }
    
    }, {
    
      extended: function(child) {
        child.NotFoundError      = createError(this.NotFoundError)
        child.NoRowsUpdatedError = createError(this.NoRowsUpdatedError)
        child.NoRowsDeletedError = createError(this.NoRowsDeletedError)
      }
    
    });
    
    BookshelfModel.NotFoundError      = Errors.NotFoundError,
    BookshelfModel.NoRowsUpdatedError = Errors.NoRowsUpdatedError,
    BookshelfModel.NoRowsDeletedError = Errors.NoRowsDeletedError
    
    module.exports = BookshelfModel;
    
  provide("bookshelf/lib/model", module.exports);
}(global));

// pakmanager:bookshelf/lib/collection
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Collection
    // ---------------
    var _              = require('lodash');
    
    var Sync           =  require('bookshelf/lib/sync');
    var Helpers        =  require('bookshelf/lib/helpers');
    var EagerRelation  =  require('bookshelf/lib/eager');
    var Errors         =  require('bookshelf/lib/errors');
    
    var CollectionBase =  require('bookshelf/lib/base/collection');
    var Promise        =  require('bookshelf/lib/base/promise');
    var createError    = require('create-error');
    
    var BookshelfCollection = CollectionBase.extend({
    
      // Used to define passthrough relationships - `hasOne`, `hasMany`,
      // `belongsTo` or `belongsToMany`, "through" a `Interim` model or collection.
      through: function(Interim, foreignKey, otherKey) {
        return this.relatedData.through(this, Interim, {throughForeignKey: foreignKey, otherKey: otherKey});
      },
    
      // Fetch the models for this collection, resetting the models
      // for the query when they arrive.
      fetch: Promise.method(function(options) {
        options = options ? _.clone(options) : {};
        return this.sync(options)
          .select()
          .bind(this)
          .tap(function(response) {
            if (!response || response.length === 0) {
              if (options.require) throw new this.constructor.EmptyError('EmptyResponse');
              return Promise.reject(null);
            }
          })
    
          // Now, load all of the data onto the collection as necessary.
          .tap(this._handleResponse)
    
          // If the "withRelated" is specified, we also need to eager load all of the
          // data on the collection, as a side-effect, before we ultimately jump into the
          // next step of the collection. Since the `columns` are only relevant to the current
          // level, ensure those are omitted from the options.
          .tap(function(response) {
            if (options.withRelated) {
              return this._handleEager(response, _.omit(options, 'columns'));
            }
          })
          .tap(function(response) {
            return this.triggerThen('fetched', this, response, options);
          })
          .catch(function(err) {
            if (err !== null) throw err;
            this.reset([], {silent: true});
          })
          .return(this);
      }),
    
      // Fetches a single model from the collection, useful on related collections.
      fetchOne: Promise.method(function(options) {
        var model = new this.model;
        model._knex = this.query().clone();
        this.resetQuery();
        if (this.relatedData) model.relatedData = this.relatedData;
        return model.fetch(options);
      }),
    
      // Eager loads relationships onto an already populated `Collection` instance.
      load: Promise.method(function(relations, options) {
        _.isArray(relations) || (relations = [relations]);
        options = _.extend({}, options, {shallow: true, withRelated: relations});
        return new EagerRelation(this.models, this.toJSON(options), new this.model())
          .fetch(options)
          .return(this);
      }),
    
      // Shortcut for creating a new model, saving, and adding to the collection.
      // Returns a promise which will resolve with the model added to the collection.
      // If the model is a relation, put the `foreignKey` and `fkValue` from the `relatedData`
      // hash into the inserted model. Also, if the model is a `manyToMany` relation,
      // automatically create the joining model upon insertion.
      create: Promise.method(function(model, options) {
        options = options ? _.clone(options) : {};
        var relatedData = this.relatedData;
        model = this._prepareModel(model, options);
    
        // If we've already added things on the query chain,
        // these are likely intended for the model.
        if (this._knex) {
          model._knex = this._knex;
          this.resetQuery();
        }
        return Helpers
          .saveConstraints(model, relatedData)
          .save(null, options)
          .bind(this)
          .then(function() {
            if (relatedData && (relatedData.type === 'belongsToMany' || relatedData.isThrough())) {
              return this.attach(model, _.omit(options, 'query'));
            }
          })
          .then(function() { this.add(model, options); })
          .return(model);
      }),
    
      // Reset the query builder, called internally
      // each time a query is run.
      resetQuery: function() {
        this._knex = null;
        return this;
      },
    
      // Returns an instance of the query builder.
      query: function() {
        return Helpers.query(this, _.toArray(arguments));
      },
    
      // Creates and returns a new `Bookshelf.Sync` instance.
      sync: function(options) {
        return new Sync(this, options);
      },
    
      // Handles the response data for the collection, returning from the collection's fetch call.
      _handleResponse: function(response) {
        var relatedData = this.relatedData;
        this.set(response, {silent: true, parse: true}).invoke('_reset');
        if (relatedData && relatedData.isJoined()) {
          relatedData.parsePivot(this.models);
        }
      },
    
      // Handle the related data loading on the collection.
      _handleEager: function(response, options) {
        return new EagerRelation(this.models, response, new this.model()).fetch(options);
      }
    
    }, {
    
      extended: function(child) {
        child.EmptyError = createError(this.EmptyError)
      }
    
    });
    
    BookshelfCollection.EmptyError = Errors.EmptyError
    
    module.exports = BookshelfCollection;
  provide("bookshelf/lib/collection", module.exports);
}(global));

// pakmanager:bookshelf/lib/relation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Relation
    // ---------------
    var _          = require('lodash');
    var inherits   = require('inherits');
    var inflection = require('inflection');
    
    var Helpers      =  require('bookshelf/lib/helpers');
    var ModelBase    =  require('bookshelf/lib/base/model');
    var RelationBase =  require('bookshelf/lib/base/relation');
    var Promise      =  require('bookshelf/lib/base/promise');
    
    var push         = [].push;
    
    var BookshelfRelation = RelationBase.extend({
    
      // Assembles the new model or collection we're creating an instance of,
      // gathering any relevant primitives from the parent object,
      // without keeping any hard references.
      init: function(parent) {
        this.parentId          = parent.id;
        this.parentTableName   = _.result(parent, 'tableName');
        this.parentIdAttribute = _.result(parent, 'idAttribute');
    
        if (this.isInverse()) {
          // use formatted attributes so that morphKey and foreignKey will match
          // attribute keys
          var attributes = parent.format(_.clone(parent.attributes));
    
          // If the parent object is eager loading, and it's a polymorphic `morphTo` relation,
          // we can't know what the target will be until the models are sorted and matched.
          if (this.type === 'morphTo' && !parent._isEager) {
            this.target = Helpers.morphCandidate(this.candidates, attributes[this.key('morphKey')]);
            this.targetTableName   = _.result(this.target.prototype, 'tableName');
            this.targetIdAttribute = _.result(this.target.prototype, 'idAttribute');
          }
          this.parentFk = attributes[this.key('foreignKey')];
        } else {
          this.parentFk = parent.id;
        }
    
        var target = this.target ? this.relatedInstance() : {};
            target.relatedData = this;
    
        if (this.type === 'belongsToMany') {
          _.extend(target, pivotHelpers);
        }
    
        return target;
      },
    
      // Initializes a `through` relation, setting the `Target` model and `options`,
      // which includes any additional keys for the relation.
      through: function(source, Target, options) {
        var type = this.type;
        if (type !== 'hasOne' && type !== 'hasMany' && type !== 'belongsToMany' && type !== 'belongsTo') {
          throw new Error('`through` is only chainable from `hasOne`, `belongsTo`, `hasMany`, or `belongsToMany`');
        }
    
        this.throughTarget = Target;
        this.throughTableName = _.result(Target.prototype, 'tableName');
        this.throughIdAttribute = _.result(Target.prototype, 'idAttribute');
    
        // Set the parentFk as appropriate now.
        if (this.type === 'belongsTo') {
          this.parentFk = this.parentId;
        }
    
        _.extend(this, options);
        _.extend(source, pivotHelpers);
    
        // Set the appropriate foreign key if we're doing a belongsToMany, for convenience.
        if (this.type === 'belongsToMany') {
          this.foreignKey = this.throughForeignKey;
        }
    
        return source;
      },
    
      // Generates and returns a specified key, for convenience... one of
      // `foreignKey`, `otherKey`, `throughForeignKey`.
      key: function(keyName) {
        var idKeyName;
        if (this[keyName]) return this[keyName];
        if (keyName === 'otherKey') {
          return this[keyName] = singularMemo(this.targetTableName) + '_' + this.targetIdAttribute;
        }
        if (keyName === 'throughForeignKey') {
          return this[keyName] = singularMemo(this.joinTable()) + '_' + this.throughIdAttribute;
        }
        if (keyName === 'foreignKey') {
          if (this.type === 'morphTo') {
            idKeyName = this.columnNames && this.columnNames[1] ? this.columnNames[1] : this.morphName + '_id';
            return this[keyName] = idKeyName;
          }
          if (this.type === 'belongsTo') return this[keyName] = singularMemo(this.targetTableName) + '_' + this.targetIdAttribute;
          if (this.isMorph()) {
            idKeyName = this.columnNames && this.columnNames[1] ? this.columnNames[1] : this.morphName + '_id';
            return this[keyName] = idKeyName;
          }
          return this[keyName] = singularMemo(this.parentTableName) + '_' + this.parentIdAttribute;
        }
        if (keyName === 'morphKey') {
          var typeKeyName = this.columnNames && this.columnNames[0] ? this.columnNames[0] : this.morphName + '_type';
          return this[keyName] = typeKeyName;
        }
        if (keyName === 'morphValue') return this[keyName] = this.parentTableName || this.targetTableName;
      },
    
      // Injects the necessary `select` constraints into a `knex` query builder.
      selectConstraints: function(knex, options) {
        var resp = options.parentResponse;
    
        // The `belongsToMany` and `through` relations have joins & pivot columns.
        if (this.isJoined()) this.joinClauses(knex);
    
        // Call the function, if one exists, to constrain the eager loaded query.
        if (options._beforeFn) options._beforeFn.call(knex, knex);
    
        // The base select column
        if (_.isArray(options.columns)) {
          knex.columns(options.columns);
        }
    
        var currentColumns = _.findWhere(knex._statements, {grouping: 'columns'});
    
        if (!currentColumns || currentColumns.length === 0) {
          knex.column(this.targetTableName + '.*');
        }
    
        if (this.isJoined()) this.joinColumns(knex);
    
        // If this is a single relation and we're not eager loading,
        // limit the query to a single item.
        if (this.isSingle() && !resp) knex.limit(1);
    
        // Finally, add (and validate) the where conditions, necessary for constraining the relation.
        this.whereClauses(knex, resp);
      },
    
      // Inject & validates necessary `through` constraints for the current model.
      joinColumns: function(knex) {
        var columns = [];
        var joinTable = this.joinTable();
        if (this.isThrough()) columns.push(this.throughIdAttribute);
        columns.push(this.key('foreignKey'));
        if (this.type === 'belongsToMany') columns.push(this.key('otherKey'));
        push.apply(columns, this.pivotColumns);
        knex.columns(_.map(columns, function(col) {
          return joinTable + '.' + col + ' as _pivot_' + col;
        }));
      },
    
      // Generates the join clauses necessary for the current relation.
      joinClauses: function(knex) {
        var joinTable = this.joinTable();
    
        if (this.type === 'belongsTo' || this.type === 'belongsToMany') {
    
          var targetKey = (this.type === 'belongsTo' ? this.key('foreignKey') : this.key('otherKey'));
    
          knex.join(
            joinTable,
            joinTable + '.' + targetKey, '=',
            this.targetTableName + '.' + this.targetIdAttribute
          );
    
          // A `belongsTo` -> `through` is currently the only relation with two joins.
          if (this.type === 'belongsTo') {
            knex.join(
              this.parentTableName,
              joinTable + '.' + this.throughIdAttribute, '=',
              this.parentTableName + '.' + this.key('throughForeignKey')
            );
          }
    
        } else {
          knex.join(
            joinTable,
            joinTable + '.' + this.throughIdAttribute, '=',
            this.targetTableName + '.' + this.key('throughForeignKey')
          );
        }
      },
    
      // Check that there isn't an incorrect foreign key set, vs. the one
      // passed in when the relation was formed.
      whereClauses: function(knex, resp) {
        var key;
    
        if (this.isJoined()) {
          var targetTable = this.type === 'belongsTo' ? this.parentTableName : this.joinTable();
          key = targetTable + '.' + (this.type === 'belongsTo' ? this.parentIdAttribute : this.key('foreignKey'));
        } else {
          key = this.targetTableName + '.' +
            (this.isInverse() ? this.targetIdAttribute : this.key('foreignKey'));
        }
    
        knex[resp ? 'whereIn' : 'where'](key, resp ? this.eagerKeys(resp) : this.parentFk);
    
        if (this.isMorph()) {
          knex.where(this.targetTableName + '.' + this.key('morphKey'), this.key('morphValue'));
        }
      },
    
      // Fetches all `eagerKeys` from the current relation.
      eagerKeys: function(resp) {
        var key = this.isInverse() && !this.isThrough() ? this.key('foreignKey') : this.parentIdAttribute;
        return _.uniq(_.pluck(resp, key));
      },
    
      // Generates the appropriate standard join table.
      joinTable: function() {
        if (this.isThrough()) return this.throughTableName;
        return this.joinTableName || [
          this.parentTableName,
          this.targetTableName
        ].sort().join('_');
      },
    
      // Creates a new model or collection instance, depending on
      // the `relatedData` settings and the models passed in.
      relatedInstance: function(models) {
        models = models || [];
    
        var Target = this.target;
    
        // If it's a single model, check whether there's already a model
        // we can pick from... otherwise create a new instance.
        if (this.isSingle()) {
          if (!(Target.prototype instanceof ModelBase)) {
            throw new Error('The `'+this.type+'` related object must be a Bookshelf.Model');
          }
          return models[0] || new Target();
        }
    
        // Allows us to just use a model, but create a temporary
        // collection for a "*-many" relation.
        if (Target.prototype instanceof ModelBase) {
          Target = this.Collection.extend({
            model: Target
          });
        }
        return new Target(models, {parse: true});
      },
    
      // Groups the related response according to the type of relationship
      // we're handling, for easy attachment to the parent models.
      eagerPair: function(relationName, related, parentModels) {
        var model;
    
        // If this is a morphTo, we only want to pair on the morphValue for the current relation.
        if (this.type === 'morphTo') {
          parentModels = _.filter(parentModels, function(model) {
            return model.get(this.key('morphKey')) === this.key('morphValue');
          }, this);
        }
    
        // If this is a `through` or `belongsToMany` relation, we need to cleanup & setup the `interim` model.
        if (this.isJoined()) related = this.parsePivot(related);
    
        // Group all of the related models for easier association with their parent models.
        var grouped = _.groupBy(related, function(model) {
          if (model.pivot) {
            return this.isInverse() && this.isThrough() ? model.pivot.id :
              model.pivot.get(this.key('foreignKey'));
          } else {
            return this.isInverse() ? model.id : model.get(this.key('foreignKey'));
          }
        }, this);
    
        // Loop over the `parentModels` and attach the grouped sub-models,
        // keeping the `relatedData` on the new related instance.
        for (var i = 0, l = parentModels.length; i < l; i++) {
          model = parentModels[i];
          var groupedKey;
          if (!this.isInverse()) {
            groupedKey = model.id;
          } else {
            var formatted = model.format(_.extend(Object.create(null), model.attributes));
            groupedKey = this.isThrough() ? formatted[this.key('throughForeignKey')] : formatted[this.key('foreignKey')];
          }
          var relation = model.relations[relationName] = this.relatedInstance(grouped[groupedKey]);
          relation.relatedData = this;
          if (this.isJoined()) _.extend(relation, pivotHelpers);
        }
    
        // Now that related models have been successfully paired, update each with
        // its parsed attributes
        for (i = 0, l = related.length; i < l; i++) {
          model = related[i];
          model.attributes = model.parse(model.attributes);
        }
    
        return related;
      },
    
      // The `models` is an array of models returned from the fetch,
      // after they're `set`... parsing out any of the `_pivot_` items from the
      // join table and assigning them on the pivot model or object as appropriate.
      parsePivot: function(models) {
        var Through = this.throughTarget;
        return _.map(models, function(model) {
          var data = {}, keep = {}, attrs = model.attributes, through;
          if (Through) through = new Through();
          for (var key in attrs) {
            if (key.indexOf('_pivot_') === 0) {
              data[key.slice(7)] = attrs[key];
            } else {
              keep[key] = attrs[key];
            }
          }
          model.attributes = keep;
          if (!_.isEmpty(data)) {
            model.pivot = through ? through.set(data, {silent: true}) : new this.Model(data, {
              tableName: this.joinTable()
            });
          }
          return model;
        }, this);
      },
    
      // A few predicates to help clarify some of the logic above.
      isThrough: function() {
        return (this.throughTarget != null);
      },
      isJoined: function() {
        return (this.type === 'belongsToMany' || this.isThrough());
      },
      isMorph: function() {
        return (this.type === 'morphOne' || this.type === 'morphMany');
      },
      isSingle: function() {
        var type = this.type;
        return (type === 'hasOne' || type === 'belongsTo' || type === 'morphOne' || type === 'morphTo');
      },
      isInverse: function() {
        return (this.type === 'belongsTo' || this.type === 'morphTo');
      },
    
      // Sets the `pivotColumns` to be retrieved along with the current model.
      withPivot: function(columns) {
        if (!_.isArray(columns)) columns = [columns];
        this.pivotColumns || (this.pivotColumns = []);
        push.apply(this.pivotColumns, columns);
      }
    
    });
    
    // Simple memoization of the singularize call.
    var singularMemo = (function() {
      var cache = Object.create(null);
      return function(arg) {
        if (arg in cache) {
          return cache[arg];
        } else {
          return cache[arg] = inflection.singularize(arg);
        }
      };
    }());
    
    // Specific to many-to-many relationships, these methods are mixed
    // into the `belongsToMany` relationships when they are created,
    // providing helpers for attaching and detaching related models.
    var pivotHelpers = {
    
      // Attach one or more "ids" from a foreign
      // table to the current. Creates & saves a new model
      // and attaches the model with a join table entry.
      attach: function(ids, options) {
        return Promise.bind(this).then(function(){
          return this.triggerThen('attaching', this, ids, options);
        }).then(function() {
          return this._handler('insert', ids, options);
        }).then(function(resp) {
          return this.triggerThen('attached', this, resp, options);
        }).then(function() {
          return this;
        });
      },
    
      // Detach related object from their pivot tables.
      // If a model or id is passed, it attempts to remove the
      // pivot table based on that foreign key. If a hash is passed,
      // it attempts to remove the item based on a where clause with
      // these parameters. If no parameters are specified, we assume we will
      // detach all related associations.
      detach: function(ids, options) {
        return Promise.bind(this).then(function(){
          return this.triggerThen('detaching', this, ids, options);
        }).then(function() {
          return this._handler('delete', ids, options);
        }).then(function(resp) {
          return this.triggerThen('detached', this, resp, options);
        });
      },
    
      // Update an existing relation's pivot table entry.
      updatePivot: function(data, options) {
        return this._handler('update', data, options);
      },
    
      // Selects any additional columns on the pivot table,
      // taking a hash of columns which specifies the pivot
      // column name, and the value the column should take on the
      // output to the model attributes.
      withPivot: function(columns) {
        this.relatedData.withPivot(columns);
        return this;
      },
    
      // Helper for handling either the `attach` or `detach` call on
      // the `belongsToMany` or `hasOne` / `hasMany` :through relationship.
      _handler: Promise.method(function(method, ids, options) {
        var pending = [];
        if (ids == void 0) {
          if (method === 'insert') return Promise.resolve(this);
          if (method === 'delete') pending.push(this._processPivot(method, null, options));
        }
        if (!_.isArray(ids)) ids = ids ? [ids] : [];
        for (var i = 0, l = ids.length; i < l; i++) {
          pending.push(this._processPivot(method, ids[i], options));
        }
        return Promise.all(pending).return(this);
      }),
    
      // Handles preparing the appropriate constraints and then delegates
      // the database interaction to _processPlainPivot for non-.through()
      // pivot definitions, or _processModelPivot for .through() models.
      // Returns a promise.
      _processPivot: Promise.method(function(method, item, options) {
        var relatedData = this.relatedData
          , args        = Array.prototype.slice.call(arguments)
          , fks         = {}
          , data        = {};
    
        fks[relatedData.key('foreignKey')] = relatedData.parentFk;
    
        // If the item is an object, it's either a model
        // that we're looking to attach to this model, or
        // a hash of attributes to set in the relation.
        if (_.isObject(item)) {
          if (item instanceof ModelBase) {
            fks[relatedData.key('otherKey')] = item.id;
          } else if (method !== 'update') {
            _.extend(data, item);
          }
        } else if (item) {
          fks[relatedData.key('otherKey')] = item;
        }
    
        args.push(_.extend(data, fks), fks);
    
        if (this.relatedData.throughTarget) {
          return this._processModelPivot.apply(this, args);
        }
    
        return this._processPlainPivot.apply(this, args);
      }),
    
      // Applies constraints to the knex builder and handles shelling out
      // to either the `insert` or `delete` call for the current model,
      // returning a promise.
      _processPlainPivot: Promise.method(function(method, item, options, data, fks) {
        var relatedData = this.relatedData;
    
        // Grab the `knex` query builder for the current model, and
        // check if we have any additional constraints for the query.
        var builder = this._builder(relatedData.joinTable());
        if (options && options.query) {
          Helpers.query.call(null, {_knex: builder}, [options.query]);
        }
    
        if (options) {
          if (options.transacting) builder.transacting(options.transacting);
          if (options.debug) builder.debug();
        }
    
        var collection = this;
        if (method === 'delete') {
          return builder.where(data).del().then(function() {
            var model;
            if (!item) return collection.reset();
            if (model = collection.get(data[relatedData.key('otherKey')])) {
              collection.remove(model);
            }
          });
        }
        if (method === 'update') {
          return builder.where(data).update(item).then(function (numUpdated) {
            if (options && options.require === true && numUpdated === 0) {
              throw new Error('No rows were updated');
            }
            return numUpdated;
          });
        }
    
        return builder.insert(data).then(function() {
          collection.add(item);
        });
      }),
    
      // Loads or prepares a pivot model based on the constraints and deals with
      // pivot model changes by calling the appropriate Bookshelf Model API
      // methods. Returns a promise.
      _processModelPivot: Promise.method(function(method, item, options, data, fks) {
        var relatedData = this.relatedData
          , JoinModel   = relatedData.throughTarget
          , instance    = new JoinModel;
    
        fks = instance.parse(fks);
        data = instance.parse(data);
    
        if (method === 'insert') {
          return instance.set(data).save(null, options);
        }
    
        return instance.set(fks).fetch({
          require: true
        }).then(function (instance) {
          if (method === 'delete') {
            return instance.destroy(options);
          }
    
          return instance.save(item, options);
        });
      })
    
    };
    
    module.exports = BookshelfRelation;
    
  provide("bookshelf/lib/relation", module.exports);
}(global));

// pakmanager:bookshelf/lib
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var _          = require('lodash');
    var inherits   = require('inherits');
    var semver     = require('semver');
    var helpers    =  require('bookshelf/lib/helpers')
    
    // We've supplemented `Events` with a `triggerThen`
    // method to allow for asynchronous event handling via promises. We also
    // mix this into the prototypes of the main objects in the library.
    var Events =  require('bookshelf/lib/base/events');
    
    // All core modules required for the bookshelf instance.
    var BookshelfModel      =  require('bookshelf/lib/base/model');
    var BookshelfCollection =  require('bookshelf/lib/base/collection');
    var BookshelfRelation   =  require('bookshelf/lib/relation');
    var Errors              =  require('bookshelf/lib/errors');
    
    function Bookshelf(knex) {
      var bookshelf  = {
        VERSION: '0.8.1'
      };
    
      var range = '>=0.6.10 <0.9.0';
      if (!semver.satisfies(knex.VERSION, range)) {
        throw new Error('The knex version is ' + knex.VERSION + ' which does not satisfy the Bookshelf\'s requirement ' + range);
      }
    
      var Model = bookshelf.Model = BookshelfModel.extend({
        
        _builder: builderFn,
    
        // The `Model` constructor is referenced as a property on the `Bookshelf` instance,
        // mixing in the correct `builder` method, as well as the `relation` method,
        // passing in the correct `Model` & `Collection` constructors for later reference.
        _relation: function(type, Target, options) {
          if (type !== 'morphTo' && !_.isFunction(Target)) {
            throw new Error('A valid target model must be defined for the ' +
              _.result(this, 'tableName') + ' ' + type + ' relation');
          }
          return new Relation(type, Target, options);
        }
    
      }, {
    
        forge: forge,
    
        collection: function(rows, options) {
          return new Collection((rows || []), _.extend({}, options, {model: this}));
        },
    
        fetchAll: function(options) {
          return this.forge().fetchAll(options); 
        }
      })
    
      var Collection = bookshelf.Collection = BookshelfCollection.extend({
        
        _builder: builderFn
      
      }, {
      
        forge: forge
      
      });
    
      // The collection also references the correct `Model`, specified above, for creating
      // new `Model` instances in the collection.
      Collection.prototype.model = Model;
      Model.prototype.Collection = Collection;
    
      var Relation = BookshelfRelation.extend({
        Model: Model,
        Collection: Collection
      })
    
      // A `Bookshelf` instance may be used as a top-level pub-sub bus, as it mixes in the
      // `Events` object. It also contains the version number, and a `Transaction` method
      // referencing the correct version of `knex` passed into the object.
      _.extend(bookshelf, Events, Errors, {
    
        // Helper method to wrap a series of Bookshelf actions in a `knex` transaction block;
        transaction: function() {
          return this.knex.transaction.apply(this, arguments);
        },
    
        // Provides a nice, tested, standardized way of adding plugins to a `Bookshelf` instance,
        // injecting the current instance into the plugin, which should be a module.exports.
        plugin: function(plugin, options) {
          if (_.isString(plugin)) {
            try {
              require('../plugins/' + plugin)(this, options);
            } catch (e) {
              if (!process.browser) {
                require(plugin)(this, options)  
              }
            }
          } else if (_.isArray(plugin)) {
            _.each(plugin, function (plugin) {
              this.plugin(plugin, options);
            }, this);
          } else {
            plugin(this, options);
          }
          return this;
        }
    
      });
    
      // Grab a reference to the `knex` instance passed (or created) in this constructor,
      // for convenience.
      bookshelf.knex = knex;
    
      // The `forge` function properly instantiates a new Model or Collection
      // without needing the `new` operator... to make object creation cleaner
      // and more chainable.
      function forge() {
        var inst = Object.create(this.prototype);
        var obj = this.apply(inst, arguments);
        return (Object(obj) === obj ? obj : inst);
      }
    
      function builderFn(tableName) {
        var builder  = knex(tableName);
        var instance = this;
        return builder.on('query', function(data) {
          instance.trigger('query', data);
        });
      }
    
      // Attach `where`, `query`, and `fetchAll` as static methods.
      ['where', 'query'].forEach(function(method) {
        Model[method] =
        Collection[method] = function() {
          var model = this.forge();
          return model[method].apply(model, arguments);
        };
      });
      
      return bookshelf;
    }
    
    // Constructor for a new `Bookshelf` object, it accepts
    // an active `knex` instance and initializes the appropriate
    // `Model` and `Collection` constructors for use in the current instance.
    Bookshelf.initialize = function(knex) {
      helpers.warn("Bookshelf.initialize is deprecated, pass knex directly:  require('bookshelf')(knex)")
      return new Bookshelf(knex)
    };
    
    // Finally, export `Bookshelf` to the world.
    module.exports = Bookshelf;
    
  provide("bookshelf/lib", module.exports);
}(global));

// pakmanager:bookshelf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Bookshelf.js 0.8.1
    // ---------------
    
    //     (c) 2014 Tim Griesser
    //     Bookshelf may be freely distributed under the MIT license.
    //     For all details and documentation:
    //     http://bookshelfjs.org
    module.exports =  require('bookshelf/lib')
  provide("bookshelf", module.exports);
}(global));

// pakmanager:knex/lib/helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _ = require('lodash');
    var chalk = require('chalk');
    
    var helpers = {
    
      // Pick off the attributes from only the current layer of the object.
      skim: function skim(data) {
        return _.map(data, function (obj) {
          return _.pick(obj, _.keys(obj));
        });
      },
    
      // Check if the first argument is an array, otherwise
      // uses all arguments as an array.
      normalizeArr: function normalizeArr() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        if (Array.isArray(args[0])) {
          return args[0];
        }
        return args;
      },
    
      error: function error(msg) {
        console.log(chalk.red('Knex:Error ' + msg));
      },
    
      // Used to signify deprecated functionality.
      deprecate: function deprecate(method, alternate) {
        helpers.warn(method + ' is deprecated, please use ' + alternate);
      },
    
      // Used to warn about incorrect use, without error'ing
      warn: function warn(msg) {
        console.log(chalk.yellow('Knex:warning - ' + msg));
      },
    
      exit: function exit(msg) {
        console.log(chalk.red(msg));
        process.exit();
      }
    
    };
    
    module.exports = helpers;
  provide("knex/lib/helpers", module.exports);
}(global));

// pakmanager:knex/lib/interface
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var helpers =  require('knex/lib/helpers');
    
    module.exports = function (Target) {
      var _ = require('lodash');
      var SqlString =  require('knex/lib/query/string');
    
      Target.prototype.toQuery = function (tz) {
        var data = this.toSQL(this._method);
        if (!_.isArray(data)) data = [data];
        return _.map(data, function (statement) {
          return this._formatQuery(statement.sql, statement.bindings, tz);
        }, this).join(';\n');
      };
    
      // Format the query as sql, prepping bindings as necessary.
      Target.prototype._formatQuery = function (sql, bindings, tz) {
        if (this.client && this.client.prepBindings) {
          bindings = this.client.prepBindings(bindings, tz);
        }
        return SqlString.format(sql, bindings, tz);
      };
    
      // Create a new instance of the `Runner`, passing in the current object.
      Target.prototype.then = function () {
        var result = this.client.runner(this).run();
        return result.then.apply(result, arguments);
      };
    
      // Add additional "options" to the builder. Typically used for client specific
      // items, like the `mysql` and `sqlite3` drivers.
      Target.prototype.options = function (opts) {
        this._options = this._options || [];
        this._options.push(_.clone(opts) || {});
        this._cached = undefined;
        return this;
      };
    
      // Sets an explicit "connnection" we wish to use for this query.
      Target.prototype.connection = function (connection) {
        this._connection = connection;
        return this;
      };
    
      // Set a debug flag for the current schema query stack.
      Target.prototype.debug = function (enabled) {
        this._debug = arguments.length ? enabled : true;
        return this;
      };
    
      // Set the transaction object for this query.
      Target.prototype.transacting = function (t) {
        if (t && t.client) {
          if (!t.client.transacting) {
            helpers.warn('Invalid transaction value: ' + t.client);
          } else {
            this.client = t.client;
          }
        }
        return this;
      };
    
      // Initializes a stream.
      Target.prototype.stream = function (options) {
        return this.client.runner(this).stream(options);
      };
    
      // Initialize a stream & pipe automatically.
      Target.prototype.pipe = function (writable, options) {
        return this.client.runner(this).pipe(writable, options);
      };
    
      // Creates a method which "coerces" to a promise, by calling a
      // "then" method on the current `Target`
      _.each(['bind', 'catch', 'finally', 'asCallback', 'spread', 'map', 'reduce', 'tap', 'thenReturn', 'return', 'yield', 'ensure', 'nodeify', 'exec'], function (method) {
        Target.prototype[method] = function () {
          var then = this.then();
          then = then[method].apply(then, arguments);
          return then;
        };
      });
    };
    /* onFulfilled, onRejected */
  provide("knex/lib/interface", module.exports);
}(global));

// pakmanager:knex/lib/query/string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var SqlString = exports;
    var helpers =  require('knex/lib/helpers');
    
    SqlString.escape = function (val, timeZone) {
      if (val == null) {
        return 'NULL';
      }
    
      switch (typeof val) {
        case 'boolean':
          return val ? 'true' : 'false';
        case 'number':
          return val + '';
      }
    
      if (val instanceof Date) {
        val = SqlString.dateToString(val, timeZone || 'local');
      }
    
      if (Buffer.isBuffer(val)) {
        return SqlString.bufferToString(val);
      }
    
      if (Array.isArray(val)) {
        return SqlString.arrayToList(val, timeZone);
      }
    
      if (typeof val === 'object') {
        try {
          val = JSON.stringify(val);
        } catch (e) {
          helpers.warn(e);
          val = val + '';
        }
      }
    
      val = val.replace(/[\0\n\r\b\t\\\'\"\x1a]/g, function (s) {
        switch (s) {
          case '\u0000':
            return '\\0';
          case '\n':
            return '\\n';
          case '\r':
            return '\\r';
          case '\b':
            return '\\b';
          case '\t':
            return '\\t';
          case '\u001a':
            return '\\Z';
          default:
            return '\\' + s;
        }
      });
      return '\'' + val + '\'';
    };
    
    SqlString.arrayToList = function (array, timeZone) {
      return array.map(function (v) {
        if (Array.isArray(v)) return '(' + SqlString.arrayToList(v, timeZone) + ')';
        return SqlString.escape(v, timeZone);
      }).join(', ');
    };
    
    SqlString.format = function (sql, values, timeZone) {
      values = values == null ? [] : [].concat(values);
      var index = 0;
      return sql.replace(/\?/g, function (match) {
        if (index === values.length) {
          return match;
        }
        var value = values[index++];
        return SqlString.escape(value, timeZone);
      });
    };
    
    SqlString.dateToString = function (date, timeZone) {
      var dt = new Date(date);
    
      if (timeZone !== 'local') {
        var tz = convertTimezone(timeZone);
    
        dt.setTime(dt.getTime() + dt.getTimezoneOffset() * 60000);
        if (tz !== false) {
          dt.setTime(dt.getTime() + tz * 60000);
        }
      }
    
      var year = dt.getFullYear();
      var month = zeroPad(dt.getMonth() + 1, 2);
      var day = zeroPad(dt.getDate(), 2);
      var hour = zeroPad(dt.getHours(), 2);
      var minute = zeroPad(dt.getMinutes(), 2);
      var second = zeroPad(dt.getSeconds(), 2);
      var millisecond = zeroPad(dt.getMilliseconds(), 3);
    
      return year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second + '.' + millisecond;
    };
    
    SqlString.bufferToString = function bufferToString(buffer) {
      return 'X\'' + buffer.toString('hex') + '\'';
    };
    
    function zeroPad(number, length) {
      number = number.toString();
      while (number.length < length) {
        number = '0' + number;
      }
    
      return number;
    }
    
    function convertTimezone(tz) {
      if (tz === 'Z') return 0;
    
      var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
      if (m) {
        return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
      }
      return false;
    }
  provide("knex/lib/query/string", module.exports);
}(global));

// pakmanager:knex/lib/promise
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Promise = require('bluebird/js/main/promise')();
    var deprecate =  require('knex/lib/helpers').deprecate;
    
    // Incase we're using an older version of bluebird
    Promise.prototype.asCallback = Promise.prototype.nodeify;
    
    Promise.prototype.exec = function (cb) {
      deprecate('.exec', '.nodeify or .asCallback');
      return this.nodeify(cb);
    };
    
    module.exports = Promise;
  provide("knex/lib/promise", module.exports);
}(global));

// pakmanager:knex/lib/raw
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Raw
    // -------
    'use strict';
    
    var inherits = require('inherits');
    var EventEmitter = require('events').EventEmitter;
    var assign = require('lodash/object/assign');
    var reduce = require('lodash/collection/reduce');
    
    function Raw(client) {
      this.client = client;
    
      this.sql = '';
      this.bindings = [];
      this._cached = undefined;
    
      // Todo: Deprecate
      this._wrappedBefore = undefined;
      this._wrappedAfter = undefined;
      this._debug = client && client.options && client.options.debug;
    }
    inherits(Raw, EventEmitter);
    
    assign(Raw.prototype, {
    
      set: function set(sql, bindings) {
        this._cached = undefined;
        this.sql = sql;
        this.bindings = bindings;
        return this;
      },
    
      // Wraps the current sql with `before` and `after`.
      wrap: function wrap(before, after) {
        this._cached = undefined;
        this._wrappedBefore = before;
        this._wrappedAfter = after;
        return this;
      },
    
      // Calls `toString` on the Knex object.
      toString: function toString() {
        return this.toQuery();
      },
    
      // Returns the raw sql for the query.
      toSQL: function toSQL() {
        if (this._cached) return this._cached;
        if (Array.isArray(this.bindings)) {
          this._cached = replaceRawArrBindings(this);
        } else if (this.bindings && typeof this.bindings === 'object') {
          this._cached = replaceKeyBindings(this);
        } else {
          this._cached = {
            method: 'raw',
            sql: this.sql,
            bindings: this.bindings
          };
        }
        if (this._wrappedBefore) {
          this._cached.sql = this._wrappedBefore + this._cached.sql;
        }
        if (this._wrappedAfter) {
          this._cached.sql = this._cached.sql + this._wrappedAfter;
        }
        this._cached.options = reduce(this._options, assign, {});
        return this._cached;
      }
    
    });
    
    function replaceRawArrBindings(raw) {
      var expectedBindings = raw.bindings.length;
      var values = raw.bindings;
      var client = raw.client;
      var index = 0;
      var bindings = [];
    
      var sql = raw.sql.replace(/\?\??/g, function (match) {
        var value = values[index++];
    
        if (value && typeof value.toSQL === 'function') {
          var bindingSQL = value.toSQL();
          bindings = bindings.concat(bindingSQL.bindings);
          return bindingSQL.sql;
        }
    
        if (match === '??') {
          return client.wrapIdentifier(value);
        }
        bindings.push(value);
        return '?';
      });
    
      if (expectedBindings !== index) {
        throw new Error('Expected ' + expectedBindings + ' bindings, saw ' + index);
      }
    
      return {
        method: 'raw',
        sql: sql,
        bindings: bindings
      };
    }
    
    function replaceKeyBindings(raw) {
      var values = raw.bindings;
      var client = raw.client;
      var sql = raw.sql,
          bindings = [];
    
      var regex = new RegExp('\\s(\\:\\w+\\:?)', 'g');
      sql = raw.sql.replace(regex, function (full, key) {
        var isIdentifier = key[key.length - 1] === ':';
        var value = isIdentifier ? values[key.slice(1, -1)] : values[key.slice(1)];
        if (value === undefined) return '';
        if (value && typeof value.toSQL === 'function') {
          var bindingSQL = value.toSQL();
          bindings = bindings.concat(bindingSQL.bindings);
          return full.replace(key, bindingSQL.sql);
        }
        if (isIdentifier) {
          return full.replace(key, client.wrapIdentifier(value));
        }
        bindings.push(value);
        return full.replace(key, '?');
      });
    
      return {
        method: 'raw',
        sql: sql,
        bindings: bindings
      };
    }
    
    // Allow the `Raw` object to be utilized with full access to the relevant
    // promise API.
     require('knex/lib/interface')(Raw);
    
    module.exports = Raw;
  provide("knex/lib/raw", module.exports);
}(global));

// pakmanager:knex/lib/query/joinclause
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var assign = require('lodash/object/assign');
    
    // JoinClause
    // -------
    
    // The "JoinClause" is an object holding any necessary info about a join,
    // including the type, and any associated tables & columns being joined.
    function JoinClause(table, type) {
      this.table = table;
      this.joinType = type;
      this.and = this;
      this.clauses = [];
    }
    
    assign(JoinClause.prototype, {
    
      grouping: 'join',
    
      // Adds an "on" clause to the current join object.
      on: function on(first, operator, second) {
        var data,
            bool = this._bool();
        switch (arguments.length) {
          case 1:
            {
              if (typeof first === 'object' && typeof first.toSQL !== 'function') {
                var i = -1,
                    keys = Object.keys(first);
                var method = bool === 'or' ? 'orOn' : 'on';
                while (++i < keys.length) {
                  this[method](keys[i], first[keys[i]]);
                }
                return this;
              } else {
                data = [bool, 'on', first];
              }
              break;
            }
          case 2:
            data = [bool, 'on', first, '=', operator];break;
          default:
            data = [bool, 'on', first, operator, second];
        }
        this.clauses.push(data);
        return this;
      },
    
      // Adds a "using" clause to the current join.
      using: function using(table) {
        return this.clauses.push([this._bool(), 'using', table]);
      },
    
      // Adds an "and on" clause to the current join object.
      andOn: function andOn() {
        return this.on.apply(this, arguments);
      },
    
      // Adds an "or on" clause to the current join object.
      orOn: function orOn(first, operator, second) {
        /*jshint unused: false*/
        return this._bool('or').on.apply(this, arguments);
      },
    
      // Explicitly set the type of join, useful within a function when creating a grouped join.
      type: function type(_type) {
        this.joinType = _type;
        return this;
      },
    
      _bool: function _bool(bool) {
        if (arguments.length === 1) {
          this._boolFlag = bool;
          return this;
        }
        var ret = this._boolFlag || 'and';
        this._boolFlag = 'and';
        return ret;
      }
    
    });
    
    Object.defineProperty(JoinClause.prototype, 'or', {
      get: function get() {
        return this._bool('or');
      }
    });
    
    module.exports = JoinClause;
  provide("knex/lib/query/joinclause", module.exports);
}(global));

// pakmanager:knex/lib/migrate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
    
    // Migrator
    // -------
    'use strict';
    
    var fs = require('fs');
    var path = require('path');
    var _ = require('lodash');
    var mkdirp = require('mkdirp');
    var Promise =  require('knex/lib/promise');
    var helpers =  require('knex/lib/helpers');
    var assign = require('lodash/object/assign');
    
    // The new migration we're performing, typically called from the `knex.migrate`
    // interface on the main `knex` object. Passes the `knex` instance performing
    // the migration.
    
    var Migrator = (function () {
      function Migrator(knex) {
        _classCallCheck(this, Migrator);
    
        this.knex = knex;
        this.config = this.setConfig(knex.client.config.migrations);
      }
    
      _createClass(Migrator, [{
        key: 'latest',
    
        // Migrators to the latest configuration.
        value: function latest(config) {
          var _this = this;
    
          this.config = this.setConfig(config);
          return this._migrationData().tap(validateMigrationList).spread(function (all, completed) {
            return _this._runBatch(_.difference(all, completed), 'up');
          });
        }
      }, {
        key: 'rollback',
    
        // Rollback the last "batch" of migrations that were run.
        value: function rollback(config) {
          var _this2 = this;
    
          return Promise['try'](function () {
            _this2.config = _this2.setConfig(config);
            return _this2._migrationData().tap(validateMigrationList).then(function (val) {
              return _this2._getLastBatch(val);
            }).then(function (migrations) {
              return _this2._runBatch(_.pluck(migrations, 'name'), 'down');
            });
          });
        }
      }, {
        key: 'currentVersion',
    
        // Retrieves and returns the current migration version
        // we're on, as a promise. If there aren't any migrations run yet,
        // return "none" as the value for the `currentVersion`.
        value: function currentVersion(config) {
          this.config = this.setConfig(config);
          return this._listCompleted(config).then(function (completed) {
            var val = _.chain(completed).map(function (value) {
              return value.split('_')[0];
            }).max().value();
            return val === -Infinity ? 'none' : val;
          });
        }
      }, {
        key: 'make',
    
        // Creates a new migration, with a given name.
        value: function make(name, config) {
          var _this3 = this;
    
          this.config = this.setConfig(config);
          if (!name) Promise.rejected(new Error('A name must be specified for the generated migration'));
          return this._ensureFolder(config).then(function (val) {
            return _this3._generateStubTemplate(val);
          }).then(function (val) {
            return _this3._writeNewMigration(name, val);
          });
        }
      }, {
        key: '_listAll',
    
        // Lists all available migration versions, as a sorted array.
        value: function _listAll(config) {
          this.config = this.setConfig(config);
          return Promise.promisify(fs.readdir, fs)(this._absoluteConfigDir()).then(function (migrations) {
            return _.filter(migrations, function (value) {
              var extension = path.extname(value);
              return _.contains(['.co', '.coffee', '.iced', '.js', '.litcoffee', '.ls'], extension);
            }).sort();
          });
        }
      }, {
        key: '_ensureFolder',
    
        // Ensures a folder for the migrations exist, dependent on the
        // migration config settings.
        value: function _ensureFolder() {
          var dir = this._absoluteConfigDir();
          return Promise.promisify(fs.stat, fs)(dir)['catch'](function () {
            return Promise.promisify(mkdirp)(dir);
          });
        }
      }, {
        key: '_ensureTable',
    
        // Ensures that the proper table has been created,
        // dependent on the migration config settings.
        value: function _ensureTable() {
          var _this4 = this;
    
          var table = this.config.tableName;
          return this.knex.schema.hasTable(table).then(function (exists) {
            if (!exists) return _this4._createMigrationTable(table);
          });
        }
      }, {
        key: '_createMigrationTable',
    
        // Create the migration table, if it doesn't already exist.
        value: function _createMigrationTable(tableName) {
          return this.knex.schema.createTable(tableName, function (t) {
            t.increments();
            t.string('name');
            t.integer('batch');
            t.timestamp('migration_time');
          });
        }
      }, {
        key: '_runBatch',
    
        // Run a batch of current migrations, in sequence.
        value: function _runBatch(migrations, direction) {
          var _this5 = this;
    
          return Promise.all(_.map(migrations, this._validateMigrationStructure, this)).then(function () {
            return _this5._latestBatchNumber();
          }).then(function (batchNo) {
            if (direction === 'up') batchNo++;
            return batchNo;
          }).then(function (batchNo) {
            return _this5._waterfallBatch(batchNo, migrations, direction);
          })['catch'](function (error) {
            helpers.warn('migrations failed with error: ' + error.message);
            throw error;
          });
        }
      }, {
        key: '_validateMigrationStructure',
    
        // Validates some migrations by requiring and checking for an `up` and `down` function.
        value: function _validateMigrationStructure(name) {
          var migration = require(path.join(this._absoluteConfigDir(), name));
          if (typeof migration.up !== 'function' || typeof migration.down !== 'function') {
            throw new Error('Invalid migration: ' + name + ' must have both an up and down function');
          }
          return name;
        }
      }, {
        key: '_listCompleted',
    
        // Lists all migrations that have been completed for the current db, as an array.
        value: function _listCompleted() {
          var _this6 = this;
    
          var tableName = this.config.tableName;
          return this._ensureTable(tableName).then(function () {
            return _this6.knex(tableName).orderBy('id').select('name');
          }).then(function (migrations) {
            return _.pluck(migrations, 'name');
          });
        }
      }, {
        key: '_migrationData',
    
        // Gets the migration list from the specified migration directory,
        // as well as the list of completed migrations to check what
        // should be run.
        value: function _migrationData() {
          return Promise.all([this._listAll(), this._listCompleted()]);
        }
      }, {
        key: '_generateStubTemplate',
    
        // Generates the stub template for the current migration, returning a compiled template.
        value: function _generateStubTemplate() {
          var stubPath = this.config.stub || path.join(__dirname, 'stub', this.config.extension + '.stub');
          return Promise.promisify(fs.readFile, fs)(stubPath).then(function (stub) {
            return _.template(stub.toString(), null, { variable: 'd' });
          });
        }
      }, {
        key: '_writeNewMigration',
    
        // Write a new migration to disk, using the config and generated filename,
        // passing any `variables` given in the config to the template.
        value: function _writeNewMigration(name, tmpl) {
          var config = this.config;
          var dir = this._absoluteConfigDir();
          if (name[0] === '-') name = name.slice(1);
          var filename = yyyymmddhhmmss() + '_' + name + '.' + config.extension;
          return Promise.promisify(fs.writeFile, fs)(path.join(dir, filename), tmpl(config.variables || {}))['return'](path.join(dir, filename));
        }
      }, {
        key: '_getLastBatch',
    
        // Get the last batch of migrations, by name, ordered by insert id
        // in reverse order.
        value: function _getLastBatch() {
          var tableName = this.config.tableName;
          return this.knex(tableName).where('batch', function (qb) {
            qb.max('batch').from(tableName);
          }).orderBy('id', 'desc');
        }
      }, {
        key: '_latestBatchNumber',
    
        // Returns the latest batch number.
        value: function _latestBatchNumber() {
          return this.knex(this.config.tableName).max('batch as max_batch').then(function (obj) {
            return obj[0].max_batch || 0;
          });
        }
      }, {
        key: '_waterfallBatch',
    
        // Runs a batch of `migrations` in a specified `direction`,
        // saving the appropriate database information as the migrations are run.
        value: function _waterfallBatch(batchNo, migrations, direction) {
          var _this7 = this;
    
          var knex = this.knex;
          var _config = this.config;
          var tableName = _config.tableName;
          var disableTransactions = _config.disableTransactions;
    
          var directory = this._absoluteConfigDir();
          var current = Promise.bind({ failed: false, failedOn: 0 });
          var log = [];
          _.each(migrations, function (migration) {
            var name = migration;
            migration = require(directory + '/' + name);
    
            // We're going to run each of the migrations in the current "up"
            current = current.then(function () {
              if (disableTransactions) {
                return warnPromise(migration[direction](knex, Promise), name);
              }
              return _this7._transaction(migration, direction, name);
            }).then(function () {
              log.push(path.join(directory, name));
              if (direction === 'up') {
                return knex(tableName).insert({
                  name: name,
                  batch: batchNo,
                  migration_time: new Date()
                });
              }
              if (direction === 'down') {
                return knex(tableName).where({ name: name }).del();
              }
            });
          });
    
          return current.thenReturn([batchNo, log]);
        }
      }, {
        key: '_transaction',
        value: function _transaction(migration, direction, name) {
          return this.knex.transaction(function (trx) {
            return warnPromise(migration[direction](trx, Promise), name, function () {
              trx.commit();
            });
          });
        }
      }, {
        key: '_absoluteConfigDir',
        value: function _absoluteConfigDir() {
          return path.resolve(process.cwd(), this.config.directory);
        }
      }, {
        key: 'setConfig',
        value: function setConfig(config) {
          return assign({
            extension: 'js',
            tableName: 'knex_migrations',
            directory: './migrations'
          }, this.config || {}, config);
        }
      }]);
    
      return Migrator;
    })();
    
    exports['default'] = Migrator;
    
    // Validates that migrations are present in the appropriate directories.
    function validateMigrationList(migrations) {
      var all = migrations[0];
      var completed = migrations[1];
      var diff = _.difference(completed, all);
      if (!_.isEmpty(diff)) {
        throw new Error('The migration directory is corrupt, the following files are missing: ' + diff.join(', '));
      }
    }
    
    function warnPromise(value, name, fn) {
      if (!value || typeof value.then !== 'function') {
        helpers.warn('migration ' + name + ' did not return a promise');
        if (fn && typeof fn === 'function') fn();
      }
      return value;
    }
    
    // Ensure that we have 2 places for each of the date segments
    function padDate(segment) {
      segment = segment.toString();
      return segment[1] ? segment : '0' + segment;
    }
    
    // Get a date object in the correct format, without requiring
    // a full out library like "moment.js".
    function yyyymmddhhmmss() {
      var d = new Date();
      return d.getFullYear().toString() + padDate(d.getMonth() + 1) + padDate(d.getDate()) + padDate(d.getHours()) + padDate(d.getMinutes()) + padDate(d.getSeconds());
    }
    module.exports = exports['default'];
  provide("knex/lib/migrate", module.exports);
}(global));

// pakmanager:knex/lib/seed
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Seeder
    // -------
    
    'use strict';
    
    var fs = require('fs');
    var path = require('path');
    var _ = require('lodash');
    var mkdirp = require('mkdirp');
    var Promise =  require('knex/lib/promise');
    
    // The new seeds we're performing, typically called from the `knex.seed`
    // interface on the main `knex` object. Passes the `knex` instance performing
    // the seeds.
    function Seeder(knex) {
      this.knex = knex;
      this.config = this.setConfig(knex.client.config.seeds);
    }
    
    // Runs all seed files for the given environment.
    Seeder.prototype.run = Promise.method(function (config) {
      this.config = this.setConfig(config);
      return this._seedData().bind(this).spread(function (all) {
        return this._runSeeds(all);
      });
    });
    
    // Creates a new seed file, with a given name.
    Seeder.prototype.make = function (name, config) {
      this.config = this.setConfig(config);
      if (!name) Promise.rejected(new Error('A name must be specified for the generated seed'));
      return this._ensureFolder(config).bind(this).then(this._generateStubTemplate).then(this._writeNewSeed(name));
    };
    
    // Lists all available seed files as a sorted array.
    Seeder.prototype._listAll = Promise.method(function (config) {
      this.config = this.setConfig(config);
      return Promise.promisify(fs.readdir, fs)(this._absoluteConfigDir()).bind(this).then(function (seeds) {
        return _.filter(seeds, function (value) {
          var extension = path.extname(value);
          return _.contains(['.co', '.coffee', '.iced', '.js', '.litcoffee', '.ls'], extension);
        }).sort();
      });
    });
    
    // Gets the seed file list from the specified seed directory.
    Seeder.prototype._seedData = function () {
      return Promise.join(this._listAll());
    };
    
    // Ensures a folder for the seeds exist, dependent on the
    // seed config settings.
    Seeder.prototype._ensureFolder = function () {
      var dir = this._absoluteConfigDir();
      return Promise.promisify(fs.stat, fs)(dir)['catch'](function () {
        return Promise.promisify(mkdirp)(dir);
      });
    };
    
    // Run seed files, in sequence.
    Seeder.prototype._runSeeds = function (seeds) {
      return Promise.all(_.map(seeds, this._validateSeedStructure, this)).bind(this).then(function (seeds) {
        return Promise.bind(this).then(function () {
          return this._waterfallBatch(seeds);
        });
      });
    };
    
    // Validates seed files by requiring and checking for a `seed` function.
    Seeder.prototype._validateSeedStructure = function (name) {
      var seed = require(path.join(this._absoluteConfigDir(), name));
      if (typeof seed.seed !== 'function') {
        throw new Error('Invalid seed file: ' + name + ' must have a seed function');
      }
      return name;
    };
    
    // Generates the stub template for the current seed file, returning a compiled template.
    Seeder.prototype._generateStubTemplate = function () {
      var stubPath = this.config.stub || path.join(__dirname, 'stub', this.config.extension + '.stub');
      return Promise.promisify(fs.readFile, fs)(stubPath).then(function (stub) {
        return _.template(stub.toString(), null, { variable: 'd' });
      });
    };
    
    // Write a new seed to disk, using the config and generated filename,
    // passing any `variables` given in the config to the template.
    Seeder.prototype._writeNewSeed = function (name) {
      var config = this.config;
      var dir = this._absoluteConfigDir();
      return function (tmpl) {
        if (name[0] === '-') name = name.slice(1);
        var filename = name + '.' + config.extension;
        return Promise.promisify(fs.writeFile, fs)(path.join(dir, filename), tmpl(config.variables || {}))['return'](path.join(dir, filename));
      };
    };
    
    // Runs a batch of seed files.
    Seeder.prototype._waterfallBatch = function (seeds) {
      var knex = this.knex;
      var seedDirectory = this._absoluteConfigDir();
      var current = Promise.bind({ failed: false, failedOn: 0 });
      var log = [];
      _.each(seeds, function (seed) {
        var name = path.join(seedDirectory, seed);
        seed = require(name);
    
        // Run each seed file.
        current = current.then(function () {
          return seed.seed(knex, Promise);
        }).then(function () {
          log.push(name);
        });
      });
    
      return current.thenReturn([log]);
    };
    
    Seeder.prototype._absoluteConfigDir = function () {
      return path.resolve(process.cwd(), this.config.directory);
    };
    
    Seeder.prototype.setConfig = function (config) {
      return _.extend({
        extension: 'js',
        directory: './seeds'
      }, this.config || {}, config);
    };
    
    module.exports = Seeder;
  provide("knex/lib/seed", module.exports);
}(global));

// pakmanager:knex/lib/functionhelper
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // FunctionHelper
    // -------
    'use strict';
    
    function FunctionHelper(client) {
      this.client = client;
    }
    
    FunctionHelper.prototype.now = function () {
      return this.client.raw('CURRENT_TIMESTAMP');
    };
    
    module.exports = FunctionHelper;
  provide("knex/lib/functionhelper", module.exports);
}(global));

// pakmanager:knex/lib/query/methods
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // All properties we can use to start a query chain
    // from the `knex` object, e.g. `knex.select('*').from(...`
    'use strict';
    
    module.exports = ['select', 'as', 'columns', 'column', 'from', 'fromJS', 'into', 'table', 'distinct', 'join', 'joinRaw', 'innerJoin', 'leftJoin', 'leftOuterJoin', 'rightJoin', 'rightOuterJoin', 'outerJoin', 'fullOuterJoin', 'crossJoin', 'where', 'andWhere', 'orWhere', 'whereNot', 'orWhereNot', 'whereRaw', 'whereWrapped', 'havingWrapped', 'orWhereRaw', 'whereExists', 'orWhereExists', 'whereNotExists', 'orWhereNotExists', 'whereIn', 'orWhereIn', 'whereNotIn', 'orWhereNotIn', 'whereNull', 'orWhereNull', 'whereNotNull', 'orWhereNotNull', 'whereBetween', 'whereNotBetween', 'orWhereBetween', 'orWhereNotBetween', 'groupBy', 'groupByRaw', 'orderBy', 'orderByRaw', 'union', 'unionAll', 'having', 'havingRaw', 'orHaving', 'orHavingRaw', 'offset', 'limit', 'count', 'min', 'max', 'sum', 'avg', 'increment', 'decrement', 'first', 'debug', 'pluck', 'insert', 'update', 'returning', 'del', 'delete', 'truncate', 'transacting', 'connection'];
  provide("knex/lib/query/methods", module.exports);
}(global));

// pakmanager:knex/lib/query/builder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Builder
    // -------
    'use strict';
    
    var _ = require('lodash');
    var assert = require('assert');
    var inherits = require('inherits');
    var EventEmitter = require('events').EventEmitter;
    
    var Raw =  require('knex/lib/raw');
    var helpers =  require('knex/lib/helpers');
    var JoinClause =  require('knex/lib/query/joinclause');
    var assign = require('lodash/object/assign');
    
    // Typically called from `knex.builder`,
    // start a new query building chain.
    function Builder(client) {
      this.client = client;
      this.and = this;
      this._single = {};
      this._statements = [];
    
      // Internal flags used in the builder.
      this._method = 'select';
      this._joinFlag = 'inner';
      this._boolFlag = 'and';
      this._notFlag = false;
      this._debug = client.config && client.config.debug;
    }
    inherits(Builder, EventEmitter);
    
    assign(Builder.prototype, {
    
      toString: function toString() {
        return this.toQuery();
      },
    
      // Convert the current query "toSQL"
      toSQL: function toSQL(method) {
        return this.client.queryCompiler(this).toSQL(method || this._method);
      },
    
      // Create a shallow clone of the current query builder.
      // TODO: Test this!!
      clone: function clone() {
        var cloned = new this.constructor(this.client);
        cloned._method = this._method;
        cloned._single = _.clone(this._single);
        cloned._options = _.clone(this._options);
        cloned._statements = this._statements.slice();
        return cloned;
      },
    
      // Select
      // ------
    
      // Adds a column or columns to the list of "columns"
      // being selected on the query.
      columns: function columns(column) {
        if (!column) return this;
        this._statements.push({
          grouping: 'columns',
          value: helpers.normalizeArr.apply(null, arguments)
        });
        return this;
      },
    
      // Allow for a sub-select to be explicitly aliased as a column,
      // without needing to compile the query in a where.
      as: function as(column) {
        this._single.as = column;
        return this;
      },
    
      // Sets the `tableName` on the query.
      // Alias to "from" for select and "into" for insert statements
      // e.g. builder.insert({a: value}).into('tableName')
      table: function table(tableName) {
        this._single.table = tableName;
        return this;
      },
    
      // Adds a `distinct` clause to the query.
      distinct: function distinct() {
        this._statements.push({
          grouping: 'columns',
          value: helpers.normalizeArr.apply(null, arguments),
          distinct: true
        });
        return this;
      },
    
      // Adds a join clause to the query, allowing for advanced joins
      // with an anonymous function as the second argument.
      // function(table, first, operator, second)
      join: function join(table, first) {
        var join;
        var joinType = this._joinType();
        if (typeof first === 'function') {
          join = new JoinClause(table, joinType);
          first.call(join, join);
        } else if (joinType === 'raw') {
          join = new JoinClause(this.client.raw(table, first), 'raw');
        } else {
          join = new JoinClause(table, joinType);
          if (arguments.length > 1) {
            join.on.apply(join, _.toArray(arguments).slice(1));
          }
        }
        this._statements.push(join);
        return this;
      },
    
      // JOIN blocks:
      innerJoin: function innerJoin() {
        return this._joinType('inner').join.apply(this, arguments);
      },
      leftJoin: function leftJoin() {
        return this._joinType('left').join.apply(this, arguments);
      },
      leftOuterJoin: function leftOuterJoin() {
        return this._joinType('left outer').join.apply(this, arguments);
      },
      rightJoin: function rightJoin() {
        return this._joinType('right').join.apply(this, arguments);
      },
      rightOuterJoin: function rightOuterJoin() {
        return this._joinType('right outer').join.apply(this, arguments);
      },
      outerJoin: function outerJoin() {
        return this._joinType('outer').join.apply(this, arguments);
      },
      fullOuterJoin: function fullOuterJoin() {
        return this._joinType('full outer').join.apply(this, arguments);
      },
      crossJoin: function crossJoin() {
        return this._joinType('cross').join.apply(this, arguments);
      },
      joinRaw: function joinRaw() {
        return this._joinType('raw').join.apply(this, arguments);
      },
    
      // The where function can be used in several ways:
      // The most basic is `where(key, value)`, which expands to
      // where key = value.
      where: function where(column, operator, value) {
    
        // Support "where true || where false"
        if (column === false || column === true) {
          return this.where(1, '=', column ? 1 : 0);
        }
    
        // Check if the column is a function, in which case it's
        // a where statement wrapped in parens.
        if (typeof column === 'function') {
          return this.whereWrapped(column);
        }
    
        // Allow a raw statement to be passed along to the query.
        if (column instanceof Raw && arguments.length === 1) return this.whereRaw(column);
    
        // Allows `where({id: 2})` syntax.
        if (_.isObject(column) && !(column instanceof Raw)) return this._objectWhere(column);
    
        // Enable the where('key', value) syntax, only when there
        // are explicitly two arguments passed, so it's not possible to
        // do where('key', '!=') and have that turn into where key != null
        if (arguments.length === 2) {
          value = operator;
          operator = '=';
    
          // If the value is null, and it's a two argument query,
          // we assume we're going for a `whereNull`.
          if (value === null) {
            return this.whereNull(column);
          }
        }
    
        // lower case the operator for comparison purposes
        var checkOperator = ('' + operator).toLowerCase().trim();
    
        // If there are 3 arguments, check whether 'in' is one of them.
        if (arguments.length === 3) {
          if (checkOperator === 'in' || checkOperator === 'not in') {
            return this._not(checkOperator === 'not in').whereIn(arguments[0], arguments[2]);
          }
          if (checkOperator === 'between' || checkOperator === 'not between') {
            return this._not(checkOperator === 'not between').whereBetween(arguments[0], arguments[2]);
          }
        }
    
        // If the value is still null, check whether they're meaning
        // where value is null
        if (value === null) {
    
          // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');
          if (checkOperator === 'is' || checkOperator === 'is not') {
            return this._not(checkOperator === 'is not').whereNull(column);
          }
        }
    
        // Push onto the where statement stack.
        this._statements.push({
          grouping: 'where',
          type: 'whereBasic',
          column: column,
          operator: operator,
          value: value,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      // Adds an `or where` clause to the query.
      orWhere: function orWhere() {
        return this._bool('or').where.apply(this, arguments);
      },
    
      // Adds an `not where` clause to the query.
      whereNot: function whereNot() {
        return this._not(true).where.apply(this, arguments);
      },
    
      // Adds an `or not where` clause to the query.
      orWhereNot: function orWhereNot() {
        return this._bool('or').whereNot.apply(this, arguments);
      },
    
      // Processes an object literal provided in a "where" clause.
      _objectWhere: function _objectWhere(obj) {
        var boolVal = this._bool();
        var notVal = this._not() ? 'Not' : '';
        for (var key in obj) {
          this[boolVal + 'Where' + notVal](key, obj[key]);
        }
        return this;
      },
    
      // Adds a raw `where` clause to the query.
      whereRaw: function whereRaw(sql, bindings) {
        var raw = sql instanceof Raw ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: 'where',
          type: 'whereRaw',
          value: raw,
          bool: this._bool()
        });
        return this;
      },
    
      orWhereRaw: function orWhereRaw(sql, bindings) {
        return this._bool('or').whereRaw(sql, bindings);
      },
    
      // Helper for compiling any advanced `where` queries.
      whereWrapped: function whereWrapped(callback) {
        this._statements.push({
          grouping: 'where',
          type: 'whereWrapped',
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
    
      // Helper for compiling any advanced `having` queries.
      havingWrapped: function havingWrapped(callback) {
        this._statements.push({
          grouping: 'having',
          type: 'whereWrapped',
          value: callback,
          bool: this._bool()
        });
        return this;
      },
    
      // Adds a `where exists` clause to the query.
      whereExists: function whereExists(callback) {
        this._statements.push({
          grouping: 'where',
          type: 'whereExists',
          value: callback,
          not: this._not(),
          bool: this._bool() });
        return this;
      },
    
      // Adds an `or where exists` clause to the query.
      orWhereExists: function orWhereExists(callback) {
        return this._bool('or').whereExists(callback);
      },
    
      // Adds a `where not exists` clause to the query.
      whereNotExists: function whereNotExists(callback) {
        return this._not(true).whereExists(callback);
      },
    
      // Adds a `or where not exists` clause to the query.
      orWhereNotExists: function orWhereNotExists(callback) {
        return this._bool('or').whereNotExists(callback);
      },
    
      // Adds a `where in` clause to the query.
      whereIn: function whereIn(column, values) {
        if (Array.isArray(values) && _.isEmpty(values)) return this.where(this._not());
        this._statements.push({
          grouping: 'where',
          type: 'whereIn',
          column: column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
    
      // Adds a `or where in` clause to the query.
      orWhereIn: function orWhereIn(column, values) {
        return this._bool('or').whereIn(column, values);
      },
    
      // Adds a `where not in` clause to the query.
      whereNotIn: function whereNotIn(column, values) {
        return this._not(true).whereIn(column, values);
      },
    
      // Adds a `or where not in` clause to the query.
      orWhereNotIn: function orWhereNotIn(column, values) {
        return this._bool('or')._not(true).whereIn(column, values);
      },
    
      // Adds a `where null` clause to the query.
      whereNull: function whereNull(column) {
        this._statements.push({
          grouping: 'where',
          type: 'whereNull',
          column: column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
    
      // Adds a `or where null` clause to the query.
      orWhereNull: function orWhereNull(column) {
        return this._bool('or').whereNull(column);
      },
    
      // Adds a `where not null` clause to the query.
      whereNotNull: function whereNotNull(column) {
        return this._not(true).whereNull(column);
      },
    
      // Adds a `or where not null` clause to the query.
      orWhereNotNull: function orWhereNotNull(column) {
        return this._bool('or').whereNotNull(column);
      },
    
      // Adds a `where between` clause to the query.
      whereBetween: function whereBetween(column, values) {
        assert(Array.isArray(values), 'The second argument to whereBetween must be an array.');
        assert(values.length === 2, 'You must specify 2 values for the whereBetween clause');
        this._statements.push({
          grouping: 'where',
          type: 'whereBetween',
          column: column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
    
      // Adds a `where not between` clause to the query.
      whereNotBetween: function whereNotBetween(column, values) {
        return this._not(true).whereBetween(column, values);
      },
    
      // Adds a `or where between` clause to the query.
      orWhereBetween: function orWhereBetween(column, values) {
        return this._bool('or').whereBetween(column, values);
      },
    
      // Adds a `or where not between` clause to the query.
      orWhereNotBetween: function orWhereNotBetween(column, values) {
        return this._bool('or').whereNotBetween(column, values);
      },
    
      // Adds a `group by` clause to the query.
      groupBy: function groupBy(item) {
        if (item instanceof Raw) {
          return this.groupByRaw.apply(this, arguments);
        }
        this._statements.push({
          grouping: 'group',
          type: 'groupByBasic',
          value: helpers.normalizeArr.apply(null, arguments)
        });
        return this;
      },
    
      // Adds a raw `group by` clause to the query.
      groupByRaw: function groupByRaw(sql, bindings) {
        var raw = sql instanceof Raw ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: 'group',
          type: 'groupByRaw',
          value: raw
        });
        return this;
      },
    
      // Adds a `order by` clause to the query.
      orderBy: function orderBy(column, direction) {
        this._statements.push({
          grouping: 'order',
          type: 'orderByBasic',
          value: column,
          direction: direction
        });
        return this;
      },
    
      // Add a raw `order by` clause to the query.
      orderByRaw: function orderByRaw(sql, bindings) {
        var raw = sql instanceof Raw ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: 'order',
          type: 'orderByRaw',
          value: raw
        });
        return this;
      },
    
      // Add a union statement to the query.
      union: function union(callbacks, wrap) {
        if (arguments.length === 1 || arguments.length === 2 && _.isBoolean(wrap)) {
          if (!Array.isArray(callbacks)) {
            callbacks = [callbacks];
          }
          for (var i = 0, l = callbacks.length; i < l; i++) {
            this._statements.push({
              grouping: 'union',
              clause: 'union',
              value: callbacks[i],
              wrap: wrap || false
            });
          }
        } else {
          callbacks = _.toArray(arguments).slice(0, arguments.length - 1);
          wrap = arguments[arguments.length - 1];
          if (!_.isBoolean(wrap)) {
            callbacks.push(wrap);
            wrap = false;
          }
          this.union(callbacks, wrap);
        }
        return this;
      },
    
      // Adds a union all statement to the query.
      unionAll: function unionAll(callback, wrap) {
        this._statements.push({
          grouping: 'union',
          clause: 'union all',
          value: callback,
          wrap: wrap || false
        });
        return this;
      },
    
      // Adds a `having` clause to the query.
      having: function having(column, operator, value) {
        if (column instanceof Raw && arguments.length === 1) {
          return this._havingRaw(column);
        }
    
        // Check if the column is a function, in which case it's
        // a having statement wrapped in parens.
        if (typeof column === 'function') {
          return this.havingWrapped(column);
        }
    
        this._statements.push({
          grouping: 'having',
          type: 'havingBasic',
          column: column,
          operator: operator,
          value: value,
          bool: this._bool()
        });
        return this;
      },
      // Adds an `or having` clause to the query.
      orHaving: function orHaving() {
        return this._bool('or').having.apply(this, arguments);
      },
      havingRaw: function havingRaw(sql, bindings) {
        return this._havingRaw(sql, bindings);
      },
      orHavingRaw: function orHavingRaw(sql, bindings) {
        return this._bool('or').havingRaw(sql, bindings);
      },
      // Adds a raw `having` clause to the query.
      _havingRaw: function _havingRaw(sql, bindings) {
        var raw = sql instanceof Raw ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: 'having',
          type: 'havingRaw',
          value: raw,
          bool: this._bool()
        });
        return this;
      },
    
      // Only allow a single "offset" to be set for the current query.
      offset: function offset(value) {
        this._single.offset = value;
        return this;
      },
    
      // Only allow a single "limit" to be set for the current query.
      limit: function limit(value) {
        var val = parseInt(value, 10);
        if (isNaN(val)) {
          helpers.warn('A valid integer must be provided to limit');
        } else {
          this._single.limit = val;
        }
        return this;
      },
    
      // Retrieve the "count" result of the query.
      count: function count(column) {
        return this._aggregate('count', column || '*');
      },
    
      // Retrieve the minimum value of a given column.
      min: function min(column) {
        return this._aggregate('min', column);
      },
    
      // Retrieve the maximum value of a given column.
      max: function max(column) {
        return this._aggregate('max', column);
      },
    
      // Retrieve the sum of the values of a given column.
      sum: function sum(column) {
        return this._aggregate('sum', column);
      },
    
      // Retrieve the average of the values of a given column.
      avg: function avg(column) {
        return this._aggregate('avg', column);
      },
    
      // Increments a column's value by the specified amount.
      increment: function increment(column, amount) {
        return this._counter(column, amount);
      },
    
      // Decrements a column's value by the specified amount.
      decrement: function decrement(column, amount) {
        return this._counter(column, amount, '-');
      },
    
      // Sets the values for a `select` query, informing that only the first
      // row should be returned (limit 1).
      first: function first() {
        var i,
            args = new Array(arguments.length);
        for (i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        this.select.apply(this, args);
        this._method = 'first';
        this.limit(1);
        return this;
      },
    
      // Pluck a column from a query.
      pluck: function pluck(column) {
        this._method = 'pluck';
        this._single.pluck = column;
        this._statements.push({
          grouping: 'columns',
          type: 'pluck',
          value: column
        });
        return this;
      },
    
      // Insert & Update
      // ------
    
      // Sets the values for an `insert` query.
      insert: function insert(values, returning) {
        this._method = 'insert';
        if (!_.isEmpty(returning)) this.returning(returning);
        this._single.insert = values;
        return this;
      },
    
      // Sets the values for an `update`, allowing for both
      // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.
      update: function update(values, returning) {
        var ret,
            obj = this._single.update || {};
        this._method = 'update';
        if (_.isString(values)) {
          obj[values] = returning;
          if (arguments.length > 2) {
            ret = arguments[2];
          }
        } else {
          var i = -1,
              keys = Object.keys(values);
          if (this._single.update) {
            helpers.warn('Update called multiple times with objects.');
          }
          while (++i < keys.length) {
            obj[keys[i]] = values[keys[i]];
          }
          ret = arguments[1];
        }
        if (!_.isEmpty(ret)) this.returning(ret);
        this._single.update = obj;
        return this;
      },
    
      // Sets the returning value for the query.
      returning: function returning(_returning) {
        this._single.returning = _returning;
        return this;
      },
    
      // Delete
      // ------
    
      // Executes a delete statement on the query;
      'delete': function _delete(ret) {
        this._method = 'del';
        if (!_.isEmpty(ret)) this.returning(ret);
        return this;
      },
    
      // Truncates a table, ends the query chain.
      truncate: function truncate(tableName) {
        this._method = 'truncate';
        if (tableName) {
          this._single.table = tableName;
        }
        return this;
      },
    
      // Retrieves columns for the table specified by `knex(tableName)`
      columnInfo: function columnInfo(column) {
        this._method = 'columnInfo';
        this._single.columnInfo = column;
        return this;
      },
    
      // Set a lock for update constraint.
      forUpdate: function forUpdate() {
        this._single.lock = 'forUpdate';
        return this;
      },
    
      // Set a lock for share constraint.
      forShare: function forShare() {
        this._single.lock = 'forShare';
        return this;
      },
    
      // Takes a JS object of methods to call and calls them
      fromJS: function fromJS(obj) {
        _.each(obj, function (val, key) {
          if (typeof this[key] !== 'function') {
            helpers.warn('Knex Error: unknown key ' + key);
          }
          if (Array.isArray(val)) {
            this[key].apply(this, val);
          } else {
            this[key](val);
          }
        }, this);
        return this;
      },
    
      // ----------------------------------------------------------------------
    
      // Helper for the incrementing/decrementing queries.
      _counter: function _counter(column, amount, symbol) {
        var amt = parseInt(amount, 10);
        if (isNaN(amt)) amt = 1;
        this._method = 'counter';
        this._single.counter = {
          column: column,
          amount: amt,
          symbol: symbol || '+'
        };
        return this;
      },
    
      // Helper to get or set the "boolFlag" value.
      _bool: function _bool(val) {
        if (arguments.length === 1) {
          this._boolFlag = val;
          return this;
        }
        var ret = this._boolFlag;
        this._boolFlag = 'and';
        return ret;
      },
    
      // Helper to get or set the "notFlag" value.
      _not: function _not(val) {
        if (arguments.length === 1) {
          this._notFlag = val;
          return this;
        }
        var ret = this._notFlag;
        this._notFlag = false;
        return ret;
      },
    
      // Helper to get or set the "joinFlag" value.
      _joinType: function _joinType(val) {
        if (arguments.length === 1) {
          this._joinFlag = val;
          return this;
        }
        var ret = this._joinFlag || 'inner';
        this._joinFlag = 'inner';
        return ret;
      },
    
      // Helper for compiling any aggregate queries.
      _aggregate: function _aggregate(method, column) {
        this._statements.push({
          grouping: 'columns',
          type: 'aggregate',
          method: method,
          value: column
        });
        return this;
      }
    
    });
    
    Object.defineProperty(Builder.prototype, 'or', {
      get: function get() {
        return this._bool('or');
      }
    });
    
    Object.defineProperty(Builder.prototype, 'not', {
      get: function get() {
        return this._not(true);
      }
    });
    
    Builder.prototype.select = Builder.prototype.columns;
    Builder.prototype.column = Builder.prototype.columns;
    Builder.prototype.andWhereNot = Builder.prototype.whereNot;
    Builder.prototype.andWhere = Builder.prototype.where;
    Builder.prototype.andWhereRaw = Builder.prototype.whereRaw;
    Builder.prototype.andHaving = Builder.prototype.having;
    Builder.prototype.from = Builder.prototype.table;
    Builder.prototype.into = Builder.prototype.table;
    Builder.prototype.del = Builder.prototype['delete'];
    
    // Attach all of the top level promise methods that should be chainable.
     require('knex/lib/interface')(Builder);
    
    module.exports = Builder;
  provide("knex/lib/query/builder", module.exports);
}(global));

// pakmanager:knex/lib/util/make-knex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var EventEmitter = require('events').EventEmitter;
    var assign = require('lodash/object/assign');
    
    var Migrator =  require('knex/lib/migrate');
    var Seeder =  require('knex/lib/seed');
    var FunctionHelper =  require('knex/lib/functionhelper');
    var QueryInterface =  require('knex/lib/query/methods');
    var helpers =  require('knex/lib/helpers');
    
    module.exports = function makeKnex(client) {
    
      // The object we're potentially using to kick off an initial chain.
      function knex(tableName) {
        var qb = knex.queryBuilder();
        if (!tableName) {
          helpers.warn('calling knex without a tableName is deprecated. Use knex.queryBuilder() instead.');
        }
        return tableName ? qb.table(tableName) : qb;
      }
    
      assign(knex, {
    
        Promise:  require('knex/lib/promise'),
    
        // A new query builder instance
        queryBuilder: function queryBuilder() {
          return client.queryBuilder();
        },
    
        raw: function raw() {
          return client.raw.apply(client, arguments);
        },
    
        // Runs a new transaction, taking a container and returning a promise
        // for when the transaction is resolved.
        transaction: function transaction(container, config) {
          return client.transaction(container, config);
        },
    
        // Typically never needed, initializes the pool for a knex client.
        initialize: function initialize(config) {
          return client.initialize(config);
        },
    
        // Convenience method for tearing down the pool.
        destroy: function destroy(callback) {
          return client.destroy(callback);
        }
    
      });
    
      // The `__knex__` is used if you need to duck-type check whether this
      // is a knex builder, without a full on `instanceof` check.
      knex.VERSION = knex.__knex__ = '0.8.6';
    
      // Hook up the "knex" object as an EventEmitter.
      var ee = new EventEmitter();
      for (var key in ee) {
        knex[key] = ee[key];
      }
    
      // Allow chaining methods from the root object, before
      // any other information is specified.
      QueryInterface.forEach(function (method) {
        knex[method] = function () {
          var builder = knex.queryBuilder();
          return builder[method].apply(builder, arguments);
        };
      });
    
      knex.client = client;
    
      Object.defineProperties(knex, {
    
        schema: {
          get: function get() {
            return client.schemaBuilder();
          }
        },
    
        migrate: {
          get: function get() {
            return new Migrator(knex);
          }
        },
    
        seed: {
          get: function get() {
            return new Seeder(knex);
          }
        },
    
        fn: {
          get: function get() {
            return new FunctionHelper(client);
          }
        }
    
      });
    
      // Passthrough all "start" and "query" events to the knex object.
      client.on('start', function (obj) {
        knex.emit('start', obj);
      });
    
      client.on('query', function (obj) {
        knex.emit('query', obj);
      });
    
      client.makeKnex = function (client) {
        return makeKnex(client);
      };
    
      return knex;
    };
  provide("knex/lib/util/make-knex", module.exports);
}(global));

// pakmanager:knex/lib/schema/helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _ = require('lodash');
    
    // Push a new query onto the compiled "sequence" stack,
    // creating a new formatter, returning the compiler.
    exports.pushQuery = function (query) {
      if (!query) return;
      if (_.isString(query)) {
        query = { sql: query };
      } else {
        query = query;
      }
      if (!query.bindings) {
        query.bindings = this.formatter.bindings;
      }
      this.sequence.push(query);
      this.formatter = this.client.formatter();
    };
    
    // Used in cases where we need to push some additional column specific statements.
    exports.pushAdditional = function (fn) {
      var child = new this.constructor(this.client, this.tableCompiler, this.columnBuilder);
      fn.call(child, _.rest(arguments));
      this.sequence.additional = (this.sequence.additional || []).concat(child.sequence);
    };
  provide("knex/lib/schema/helpers", module.exports);
}(global));

// pakmanager:knex/lib/runner
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _ = require('lodash');
    var Promise =  require('knex/lib/promise');
    var assign = require('lodash/object/assign');
    
    var PassThrough;
    
    // The "Runner" constructor takes a "builder" (query, schema, or raw)
    // and runs through each of the query statements, calling any additional
    // "output" method provided alongside the query and bindings.
    function Runner(client, builder) {
      this.client = client;
      this.builder = builder;
      this.queries = [];
    
      // The "connection" object is set on the runner when
      // "run" is called.
      this.connection = void 0;
    }
    
    assign(Runner.prototype, {
    
      // "Run" the target, calling "toSQL" on the builder, returning
      // an object or array of queries to run, each of which are run on
      // a single connection.
      run: function run() {
        var runner = this;
    
        return Promise.using(this.ensureConnection(), function (connection) {
          runner.connection = connection;
    
          runner.client.emit('start', runner.builder);
          runner.builder.emit('start', runner.builder);
          var sql = runner.builder.toSQL();
    
          if (runner.builder._debug) {
            console.log(sql);
          }
    
          if (_.isArray(sql)) {
            return runner.queryArray(sql);
          }
          return runner.query(sql);
        })
    
        // If there are any "error" listeners, we fire an error event
        // and then re-throw the error to be eventually handled by
        // the promise chain. Useful if you're wrapping in a custom `Promise`.
        ['catch'](function (err) {
          if (runner.builder._events && runner.builder._events.error) {
            runner.builder.emit('error', err);
          }
          throw err;
        })
    
        // Fire a single "end" event on the builder when
        // all queries have successfully completed.
        .tap(function () {
          runner.builder.emit('end');
        });
      },
    
      // Stream the result set, by passing through to the dialect's streaming
      // capabilities. If the options are
      stream: function stream(options, handler) {
    
        // If we specify stream(handler).then(...
        if (arguments.length === 1) {
          if (typeof options === 'function') {
            handler = options;
            options = {};
          }
        }
    
        // Determines whether we emit an error or throw here.
        var hasHandler = typeof handler === 'function';
    
        // Lazy-load the "PassThrough" dependency.
        PassThrough = PassThrough || require('readable-stream').PassThrough;
    
        var runner = this;
        var stream = new PassThrough({ objectMode: true });
        var promise = Promise.using(this.ensureConnection(), function (connection) {
          runner.connection = connection;
          var sql = runner.builder.toSQL();
          var err = new Error('The stream may only be used with a single query statement.');
          if (_.isArray(sql)) {
            if (hasHandler) throw err;
            stream.emit('error', err);
          }
          return sql;
        }).then(function (sql) {
          return runner.client.stream(runner.connection, sql, stream, options);
        });
    
        // If a function is passed to handle the stream, send the stream
        // there and return the promise, otherwise just return the stream
        // and the promise will take care of itsself.
        if (hasHandler) {
          handler(stream);
          return promise;
        }
        return stream;
      },
    
      // Allow you to pipe the stream to a writable stream.
      pipe: function pipe(writable, options) {
        return this.stream().pipe(writable, options);
      },
    
      // "Runs" a query, returning a promise. All queries specified by the builder are guaranteed
      // to run in sequence, and on the same connection, especially helpful when schema building
      // and dealing with foreign key constraints, etc.
      query: Promise.method(function (obj) {
        this.builder.emit('query', assign({ __knexUid: this.connection.__knexUid }, obj));
        var runner = this;
        return this.client.query(this.connection, obj).then(function (resp) {
          return runner.client.processResponse(resp, runner);
        });
      }),
    
      // In the case of the "schema builder" we call `queryArray`, which runs each
      // of the queries in sequence.
      queryArray: function queryArray(queries) {
        return queries.length === 1 ? this.query(queries[0]) : Promise.bind(this)['return'](queries).reduce(function (memo, query) {
          return this.query(query).then(function (resp) {
            memo.push(resp);
            return memo;
          });
        }, []);
      },
    
      // Check whether there's a transaction flag, and that it has a connection.
      ensureConnection: function ensureConnection() {
        var runner = this;
        return Promise['try'](function () {
          return runner.connection || runner.client.acquireConnection();
        }).disposer(function () {
          runner.client.releaseConnection(runner.connection);
        });
      }
    
    });
    
    module.exports = Runner;
  provide("knex/lib/runner", module.exports);
}(global));

// pakmanager:knex/lib/formatter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var QueryBuilder =  require('knex/lib/query/builder');
    var Raw =  require('knex/lib/raw');
    var assign = require('lodash/object/assign');
    var transform = require('lodash/object/transform');
    
    function Formatter(client) {
      this.client = client;
      this.bindings = [];
    }
    
    assign(Formatter.prototype, {
    
      // Accepts a string or array of columns to wrap as appropriate.
      columnize: function columnize(target) {
        var columns = typeof target === 'string' ? [target] : target;
        var str = '',
            i = -1;
        while (++i < columns.length) {
          if (i > 0) str += ', ';
          str += this.wrap(columns[i]);
        }
        return str;
      },
    
      // Turns a list of values into a list of ?'s, joining them with commas unless
      // a "joining" value is specified (e.g. ' and ')
      parameterize: function parameterize(values, notSetValue) {
        if (typeof values === 'function') return this.parameter(values);
        values = Array.isArray(values) ? values : [values];
        var str = '',
            i = -1;
        while (++i < values.length) {
          if (i > 0) str += ', ';
          str += this.parameter(values[i] === undefined ? notSetValue : values[i]);
        }
        return str;
      },
    
      // Checks whether a value is a function... if it is, we compile it
      // otherwise we check whether it's a raw
      parameter: function parameter(value) {
        if (typeof value === 'function') {
          return this.outputQuery(this.compileCallback(value), true);
        }
        return this.unwrapRaw(value, true) || '?';
      },
    
      unwrapRaw: function unwrapRaw(value, isParameter) {
        var query;
        if (value instanceof QueryBuilder) {
          query = this.client.queryCompiler(value).toSQL();
          if (query.bindings) {
            this.bindings = this.bindings.concat(query.bindings);
          }
          return this.outputQuery(query, isParameter);
        }
        if (value instanceof Raw) {
          query = value.toSQL();
          if (query.bindings) {
            this.bindings = this.bindings.concat(query.bindings);
          }
          return query.sql;
        }
        if (isParameter) {
          this.bindings.push(value);
        }
      },
    
      rawOrFn: function rawOrFn(value, method) {
        if (typeof value === 'function') {
          return this.outputQuery(this.compileCallback(value, method));
        }
        return this.unwrapRaw(value) || '';
      },
    
      // Puts the appropriate wrapper around a value depending on the database
      // engine, unless it's a knex.raw value, in which case it's left alone.
      wrap: function wrap(value) {
        var raw;
        if (typeof value === 'function') {
          return this.outputQuery(this.compileCallback(value), true);
        }
        raw = this.unwrapRaw(value);
        if (raw) return raw;
        if (typeof value === 'number') return value;
        return this._wrapString(value + '');
      },
    
      alias: function alias(first, second) {
        return first + ' as ' + second;
      },
    
      // The operator method takes a value and returns something or other.
      operator: function operator(value) {
        var raw = this.unwrapRaw(value);
        if (raw) return raw;
        if (operators[(value || '').toLowerCase()] !== true) {
          throw new TypeError('The operator "' + value + '" is not permitted');
        }
        return value;
      },
    
      // Specify the direction of the ordering.
      direction: function direction(value) {
        var raw = this.unwrapRaw(value);
        if (raw) return raw;
        return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';
      },
    
      // Compiles a callback using the query builder.
      compileCallback: function compileCallback(callback, method) {
        var client = this.client;
    
        // Build the callback
        var builder = client.queryBuilder();
        callback.call(builder, builder);
    
        // Compile the callback, using the current formatter (to track all bindings).
        var compiler = client.queryCompiler(builder);
        compiler.formatter = this;
    
        // Return the compiled & parameterized sql.
        return compiler.toSQL(method || 'select');
      },
    
      // Ensures the query is aliased if necessary.
      outputQuery: function outputQuery(compiled, isParameter) {
        var sql = compiled.sql || '';
        if (sql) {
          if (compiled.method === 'select' && (isParameter || compiled.as)) {
            sql = '(' + sql + ')';
            if (compiled.as) return this.alias(sql, this.wrap(compiled.as));
          }
        }
        return sql;
      },
    
      // Coerce to string to prevent strange errors when it's not a string.
      _wrapString: function _wrapString(value) {
        var segments,
            asIndex = value.toLowerCase().indexOf(' as ');
        if (asIndex !== -1) {
          var first = value.slice(0, asIndex);
          var second = value.slice(asIndex + 4);
          return this.alias(this.wrap(first), this.wrap(second));
        }
        var i = -1,
            wrapped = [];
        segments = value.split('.');
        while (++i < segments.length) {
          value = segments[i];
          if (i === 0 && segments.length > 1) {
            wrapped.push(this.wrap((value || '').trim()));
          } else {
            wrapped.push(this.client.wrapIdentifier((value || '').trim()));
          }
        }
        return wrapped.join('.');
      }
    
    });
    
    // Valid values for the `order by` clause generation.
    var orderBys = ['asc', 'desc'];
    
    // Turn this into a lookup map
    var operators = transform(['=', '<', '>', '<=', '>=', '<>', '!=', 'like', 'not like', 'between', 'ilike', '&', '|', '^', '<<', '>>', 'rlike', 'regexp', 'not regexp', '~', '~*', '!~', '!~*', '#', '&&', '@>', '<@', '||'], function (obj, key) {
      obj[key] = true;
    }, Object.create(null));
    
    module.exports = Formatter;
  provide("knex/lib/formatter", module.exports);
}(global));

// pakmanager:knex/lib/transaction
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Transaction
    // -------
    'use strict';
    
    var Promise =  require('knex/lib/promise');
    var EventEmitter = require('events').EventEmitter;
    var inherits = require('inherits');
    
    var makeKnex =  require('knex/lib/util/make-knex');
    var assign = require('lodash/object/assign');
    var uniqueId = require('lodash/utility/uniqueId');
    var debug = require('debug')('knex:tx');
    
    // Acts as a facade for a Promise, keeping the internal state
    // and managing any child transactions.
    function Transaction(client, container, config, outerTx) {
      var _this = this;
    
      var txid = this.txid = uniqueId('trx');
    
      this.client = client;
      this.outerTx = outerTx;
      this.trxClient = undefined;
      this._debug = client.config && client.config.debug;
    
      debug('%s: Starting %s transaction', txid, outerTx ? 'nested' : 'top level');
    
      this._promise = Promise.using(this.acquireConnection(client, config, txid), function (connection) {
    
        var trxClient = _this.trxClient = makeTxClient(_this, client, connection);
        var init = client.transacting ? _this.savepoint(connection) : _this.begin(connection);
    
        init.then(function () {
          return makeTransactor(_this, connection, trxClient);
        }).then(function (transactor) {
    
          var result = container(transactor);
    
          // If we've returned a "thenable" from the transaction container,
          // and it's got the transaction object we're running for this, assume
          // the rollback and commit are chained to this object's success / failure.
          if (result && result.then && typeof result.then === 'function') {
            result.then(function (val) {
              transactor.commit(val);
            })['catch'](function (err) {
              transactor.rollback(err);
            });
          }
        })['catch'](function (e) {
          return _this._rejecter(e);
        });
    
        return new Promise(function (resolver, rejecter) {
          _this._resolver = resolver;
          _this._rejecter = rejecter;
        });
      });
    
      this._completed = false;
    
      // If there is more than one child transaction,
      // we queue them, executing each when the previous completes.
      this._childQueue = [];
    
      // The queue is a noop unless we have child promises.
      this._queue = this._queue || Promise.resolve(true);
    
      // If there's a wrapping transaction, we need to see if there are
      // any current children in the pending queue.
      if (outerTx) {
    
        // If there are other promises pending, we just wait until that one
        // settles (commit or rollback) and then we can continue.
        if (outerTx._childQueue.length > 0) {
    
          this._queue = this._queue.then(function () {
            return Promise.settle(outerTx._childQueue[outerTx._childQueue.length - 1]);
          });
        }
    
        // Push the current promise onto the queue of promises.
        outerTx._childQueue.push(this._promise);
      }
    }
    inherits(Transaction, EventEmitter);
    
    assign(Transaction.prototype, {
    
      isCompleted: function isCompleted() {
        return this._completed || this.outerTx && this.outerTx.isCompleted() || false;
      },
    
      begin: function begin(conn) {
        return this.query(conn, 'BEGIN;');
      },
    
      savepoint: function savepoint(conn) {
        return this.query(conn, 'SAVEPOINT ' + this.txid + ';');
      },
    
      commit: function commit(conn, value) {
        return this.query(conn, 'COMMIT;', 1, value);
      },
    
      release: function release(conn, value) {
        return this.query(conn, 'RELEASE SAVEPOINT ' + this.txid + ';', 1, value);
      },
    
      rollback: function rollback(conn, error) {
        return this.query(conn, 'ROLLBACK;', 2, error);
      },
    
      rollbackTo: function rollbackTo(conn, error) {
        return this.query(conn, 'ROLLBACK TO SAVEPOINT ' + this.txid, 2, error);
      },
    
      query: function query(conn, sql, status, value) {
        var _this2 = this;
    
        var q = this.trxClient.query(conn, sql)['catch'](function (err) {
          status = 2;
          value = err;
          _this2._completed = true;
          debug('%s error running transaction query', _this2.txid);
        }).tap(function () {
          if (status === 1) _this2._resolver(value);
          if (status === 2) _this2._rejecter(value);
        });
        if (status === 1 || status === 2) {
          this._completed = true;
        }
        return q;
      },
    
      debug: function debug(enabled) {
        this._debug = arguments.length ? enabled : true;
        return this;
      },
    
      _skipping: function _skipping(sql) {
        return Promise.reject(new Error('Transaction ' + this.txid + ' has already been released skipping: ' + sql));
      },
    
      // Acquire a connection and create a disposer - either using the one passed
      // via config or getting one off the client. The disposer will be called once
      // the original promise is marked completed.
      acquireConnection: function acquireConnection(client, config, txid) {
        var configConnection = config && config.connection;
        return Promise['try'](function () {
          return configConnection || client.acquireConnection();
        }).disposer(function (connection) {
          if (!configConnection) {
            debug('%s: releasing connection', txid);
            client.releaseConnection(connection);
          } else {
            debug('%s: not releasing external connection', txid);
          }
        });
      }
    
    });
    
    // The transactor is a full featured knex object, with a "commit",
    // a "rollback" and a "savepoint" function. The "savepoint" is just
    // sugar for creating a new transaction. If the rollback is run
    // inside a savepoint, it rolls back to the last savepoint - otherwise
    // it rolls back the transaction.
    function makeTransactor(trx, connection, trxClient) {
    
      var transactor = makeKnex(trxClient);
    
      transactor.transaction = function (container, options) {
        return new trxClient.Transaction(trxClient, container, options, trx);
      };
      transactor.savepoint = function (container, options) {
        return transactor.transaction(container, options);
      };
    
      if (trx.client.transacting) {
        transactor.commit = function (value) {
          return trx.release(connection, value);
        };
        transactor.rollback = function (error) {
          return trx.rollbackTo(connection, error);
        };
      } else {
        transactor.commit = function (value) {
          return trx.commit(connection, value);
        };
        transactor.rollback = function (error) {
          return trx.rollback(connection, error);
        };
      }
    
      return transactor;
    }
    
    // We need to make a client object which always acquires the same
    // connection and does not release back into the pool.
    function makeTxClient(trx, client, connection) {
    
      var trxClient = Object.create(client.constructor.prototype);
      trxClient.config = client.config;
      trxClient.driver = client.driver;
      trxClient.connectionSettings = client.connectionSettings;
      trxClient.transacting = true;
    
      trxClient.on('query', function (arg) {
        trx.emit('query', arg);
      });
    
      var _query = trxClient.query;
      trxClient.query = function (conn, obj) {
        var completed = trx.isCompleted();
        return Promise['try'](function () {
          if (conn !== connection) throw new Error('Invalid connection for transaction query.');
          if (completed) completedError(trx, obj);
          return _query.call(trxClient, conn, obj);
        });
      };
      var _stream = trxClient.stream;
      trxClient.stream = function (conn, obj, stream, options) {
        var completed = trx.isCompleted();
        return Promise['try'](function () {
          if (conn !== connection) throw new Error('Invalid connection for transaction query.');
          if (completed) completedError(trx, obj);
          return _stream.call(trxClient, conn, obj, stream, options);
        });
      };
      trxClient.acquireConnection = function () {
        return trx._queue.then(function () {
          return connection;
        });
      };
      trxClient.releaseConnection = function () {
        return Promise.resolve();
      };
    
      return trxClient;
    }
    
    function completedError(trx, obj) {
      var sql = typeof obj === 'string' ? obj : obj && obj.sql;
      debug('%s: Transaction completed: %s', trx.id, sql);
      throw new Error('Transaction query already complete, run with DEBUG=knex:tx for more info');
    }
    
    var promiseInterface = ['then', 'bind', 'catch', 'finally', 'asCallback', 'spread', 'map', 'reduce', 'tap', 'thenReturn', 'return', 'yield', 'ensure', 'nodeify', 'exec'];
    
    // Creates a method which "coerces" to a promise, by calling a
    // "then" method on the current `Target`
    promiseInterface.forEach(function (method) {
      Transaction.prototype[method] = function () {
        return this._promise = this._promise[method].apply(this._promise, arguments);
      };
    });
    
    module.exports = Transaction;
  provide("knex/lib/transaction", module.exports);
}(global));

// pakmanager:knex/lib/query/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Query Compiler
    // -------
    'use strict';
    
    var _ = require('lodash');
    var helpers =  require('knex/lib/helpers');
    var Raw =  require('knex/lib/raw');
    var assign = require('lodash/object/assign');
    var reduce = require('lodash/collection/reduce');
    
    // The "QueryCompiler" takes all of the query statements which
    // have been gathered in the "QueryBuilder" and turns them into a
    // properly formatted / bound query string.
    function QueryCompiler(client, builder) {
      this.client = client;
      this.method = builder._method || 'select';
      this.options = builder._options;
      this.single = builder._single;
      this.grouped = _.groupBy(builder._statements, 'grouping');
      this.formatter = client.formatter();
    }
    
    var components = ['columns', 'join', 'where', 'union', 'group', 'having', 'order', 'limit', 'offset', 'lock'];
    
    assign(QueryCompiler.prototype, {
    
      // Used when the insert call is empty.
      _emptyInsertValue: 'default values',
    
      // Collapse the builder into a single object
      toSQL: function toSQL(method) {
        method = method || this.method;
        var val = this[method]();
        var defaults = {
          method: method,
          options: reduce(this.options, assign, {}),
          bindings: this.formatter.bindings
        };
        if (_.isString(val)) {
          val = { sql: val };
        }
        if (method === 'select' && this.single.as) {
          defaults.as = this.single.as;
        }
        return assign(defaults, val);
      },
    
      // Compiles the `select` statement, or nested sub-selects
      // by calling each of the component compilers, trimming out
      // the empties, and returning a generated query string.
      select: function select() {
        var i = -1,
            statements = [];
        while (++i < components.length) {
          statements.push(this[components[i]](this));
        }
        return _.compact(statements).join(' ');
      },
    
      pluck: function pluck() {
        return {
          sql: this.select(),
          pluck: this.single.pluck
        };
      },
    
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert: function insert() {
        var insertValues = this.single.insert || [];
        var sql = 'insert into ' + this.tableName + ' ';
    
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return '';
          }
        } else if (typeof insertValues === 'object' && _.isEmpty(insertValues)) {
          return sql + this._emptyInsertValue;
        }
    
        var insertData = this._prepInsert(insertValues);
        if (typeof insertData === 'string') {
          sql += insertData;
        } else {
          if (insertData.columns.length) {
            sql += '(' + this.formatter.columnize(insertData.columns);
            sql += ') values (';
            var i = -1;
            while (++i < insertData.values.length) {
              if (i !== 0) sql += '), (';
              sql += this.formatter.parameterize(insertData.values[i]);
            }
            sql += ')';
          } else if (insertValues.length === 1 && insertValues[0]) {
            sql += this._emptyInsertValue;
          } else {
            sql = '';
          }
        }
        return sql;
      },
    
      // Compiles the "update" query.
      update: function update() {
        // Make sure tableName is processed by the formatter first.
        var tableName = this.tableName;
        var updateData = this._prepUpdate(this.single.update);
        var wheres = this.where();
        return 'update ' + tableName + ' set ' + updateData.join(', ') + (wheres ? ' ' + wheres : '');
      },
    
      // Compiles the columns in the query, specifying if an item was distinct.
      columns: function columns() {
        var distinct = false;
        if (this.onlyUnions()) return '';
        var columns = this.grouped.columns || [];
        var i = -1,
            sql = [];
        if (columns) {
          while (++i < columns.length) {
            var stmt = columns[i];
            if (stmt.distinct) distinct = true;
            if (stmt.type === 'aggregate') {
              sql.push(this.aggregate(stmt));
            } else if (stmt.value && stmt.value.length > 0) {
              sql.push(this.formatter.columnize(stmt.value));
            }
          }
        }
        if (sql.length === 0) sql = ['*'];
        return 'select ' + (distinct ? 'distinct ' : '') + sql.join(', ') + (this.tableName ? ' from ' + this.tableName : '');
      },
    
      aggregate: function aggregate(stmt) {
        var val = stmt.value;
        var splitOn = val.toLowerCase().indexOf(' as ');
        // Allows us to speciy an alias for the aggregate types.
        if (splitOn !== -1) {
          var col = val.slice(0, splitOn);
          var alias = val.slice(splitOn + 4);
          return stmt.method + '(' + this.formatter.wrap(col) + ') as ' + this.formatter.wrap(alias);
        }
        return stmt.method + '(' + this.formatter.wrap(val) + ')';
      },
    
      // Compiles all each of the `join` clauses on the query,
      // including any nested join queries.
      join: function join() {
        var sql = '',
            i = -1,
            joins = this.grouped.join;
        if (!joins) return '';
        while (++i < joins.length) {
          var join = joins[i];
          if (i > 0) sql += ' ';
          if (join.joinType === 'raw') {
            sql += this.formatter.unwrapRaw(join.table);
          } else {
            sql += join.joinType + ' join ' + this.formatter.wrap(join.table);
            var ii = -1;
            while (++ii < join.clauses.length) {
              var clause = join.clauses[ii];
              sql += ' ' + (ii > 0 ? clause[0] : clause[1]) + ' ';
              sql += this.formatter.wrap(clause[2]);
              if (clause[3]) sql += ' ' + this.formatter.operator(clause[3]);
              if (clause[4]) sql += ' ' + this.formatter.wrap(clause[4]);
            }
          }
        }
        return sql;
      },
    
      // Compiles all `where` statements on the query.
      where: function where() {
        var wheres = this.grouped.where;
        if (!wheres) return;
        var i = -1,
            sql = [];
        while (++i < wheres.length) {
          var stmt = wheres[i];
          var val = this[stmt.type](stmt);
          if (val) {
            if (sql.length === 0) {
              sql[0] = 'where';
            } else {
              sql.push(stmt.bool);
            }
            sql.push(val);
          }
        }
        return sql.length > 1 ? sql.join(' ') : '';
      },
    
      group: function group() {
        return this._groupsOrders('group');
      },
    
      order: function order() {
        return this._groupsOrders('order');
      },
    
      // Compiles the `having` statements.
      having: function having() {
        var havings = this.grouped.having;
        if (!havings) return '';
        var sql = ['having'];
        for (var i = 0, l = havings.length; i < l; i++) {
          var str = '',
              s = havings[i];
          if (i !== 0) str = s.bool + ' ';
          if (s.type === 'havingBasic') {
            sql.push(str + this.formatter.columnize(s.column) + ' ' + this.formatter.operator(s.operator) + ' ' + this.formatter.parameter(s.value));
          } else {
            if (s.type === 'whereWrapped') {
              var val = this.whereWrapped(s);
              if (val) sql.push(val);
            } else {
              sql.push(str + this.formatter.unwrapRaw(s.value));
            }
          }
        }
        return sql.length > 1 ? sql.join(' ') : '';
      },
    
      // Compile the "union" queries attached to the main query.
      union: function union() {
        var onlyUnions = this.onlyUnions();
        var unions = this.grouped.union;
        if (!unions) return '';
        var sql = '';
        for (var i = 0, l = unions.length; i < l; i++) {
          var union = unions[i];
          if (i > 0) sql += ' ';
          if (i > 0 || !onlyUnions) sql += union.clause + ' ';
          var statement = this.formatter.rawOrFn(union.value);
          if (statement) {
            if (union.wrap) sql += '(';
            sql += statement;
            if (union.wrap) sql += ')';
          }
        }
        return sql;
      },
    
      // If we haven't specified any columns or a `tableName`, we're assuming this
      // is only being used for unions.
      onlyUnions: function onlyUnions() {
        return !this.grouped.columns && this.grouped.union && !this.tableName;
      },
    
      limit: function limit() {
        var noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit) return '';
        return 'limit ' + this.formatter.parameter(this.single.limit);
      },
    
      offset: function offset() {
        if (!this.single.offset) return '';
        return 'offset ' + this.formatter.parameter(this.single.offset);
      },
    
      // Compiles a `delete` query.
      del: function del() {
        // Make sure tableName is processed by the formatter first.
        var tableName = this.tableName;
        var wheres = this.where();
        return 'delete from ' + tableName + (wheres ? ' ' + wheres : '');
      },
    
      // Compiles a `truncate` query.
      truncate: function truncate() {
        return 'truncate ' + this.tableName;
      },
    
      // Compiles the "locks".
      lock: function lock() {
        if (this.single.lock) {
          if (!this.client.transacting) {
            helpers.warn('You are attempting to perform a "lock" command outside of a transaction.');
          } else {
            return this[this.single.lock]();
          }
        }
      },
    
      // Compile the "counter".
      counter: function counter() {
        var counter = this.single.counter;
        var toUpdate = {};
        toUpdate[counter.column] = this.client.raw(this.formatter.wrap(counter.column) + ' ' + (counter.symbol || '+') + ' ' + counter.amount);
        this.single.update = toUpdate;
        return this.update();
      },
    
      // Where Clause
      // ------
    
      whereIn: function whereIn(statement) {
        if (Array.isArray(statement.column)) return this.multiWhereIn(statement);
        return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'in ') + this.wrap(this.formatter.parameterize(statement.value));
      },
    
      multiWhereIn: function multiWhereIn(statement) {
        var i = -1,
            sql = '(' + this.formatter.columnize(statement.column) + ') ';
        sql += this._not(statement, 'in ') + '((';
        while (++i < statement.value.length) {
          if (i !== 0) sql += '),(';
          sql += this.formatter.parameterize(statement.value[i]);
        }
        return sql + '))';
      },
    
      whereNull: function whereNull(statement) {
        return this.formatter.wrap(statement.column) + ' is ' + this._not(statement, 'null');
      },
    
      // Compiles a basic "where" clause.
      whereBasic: function whereBasic(statement) {
        return this._not(statement, '') + this.formatter.wrap(statement.column) + ' ' + this.formatter.operator(statement.operator) + ' ' + this.formatter.parameter(statement.value);
      },
    
      whereExists: function whereExists(statement) {
        return this._not(statement, 'exists') + ' (' + this.formatter.rawOrFn(statement.value) + ')';
      },
    
      whereWrapped: function whereWrapped(statement) {
        var val = this.formatter.rawOrFn(statement.value, 'where');
        return val && this._not(statement, '') + '(' + val.slice(6) + ')' || '';
      },
    
      whereBetween: function whereBetween(statement) {
        return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'between') + ' ' + _.map(statement.value, this.formatter.parameter, this.formatter).join(' and ');
      },
    
      // Compiles a "whereRaw" query.
      whereRaw: function whereRaw(statement) {
        return this.formatter.unwrapRaw(statement.value);
      },
    
      wrap: function wrap(str) {
        if (str.charAt(0) !== '(') return '(' + str + ')';
        return str;
      },
    
      // Determines whether to add a "not" prefix to the where clause.
      _not: function _not(statement, str) {
        if (statement.not) return 'not ' + str;
        return str;
      },
    
      _prepInsert: function _prepInsert(data) {
        var isRaw = this.formatter.rawOrFn(data);
        if (isRaw) return isRaw;
        var columns = [];
        var values = [];
        if (!Array.isArray(data)) data = data ? [data] : [];
        var i = -1;
        while (++i < data.length) {
          if (data[i] == null) break;
          if (i === 0) columns = Object.keys(data[i]).sort();
          var row = new Array(columns.length);
          var keys = Object.keys(data[i]);
          var j = -1;
          while (++j < keys.length) {
            var key = keys[j];
            var idx = columns.indexOf(key);
            if (idx === -1) {
              columns = columns.concat(key).sort();
              idx = columns.indexOf(key);
              var k = -1;
              while (++k < values.length) {
                values[k].splice(idx, 0, undefined);
              }
              row.splice(idx, 0, undefined);
            }
            row[idx] = data[i][key];
          }
          values.push(row);
        }
        return {
          columns: columns,
          values: values
        };
      },
    
      // "Preps" the update.
      _prepUpdate: function _prepUpdate(data) {
        var vals = [];
        var sorted = Object.keys(data).sort();
        var i = -1;
        while (++i < sorted.length) {
          vals.push(this.formatter.wrap(sorted[i]) + ' = ' + this.formatter.parameter(data[sorted[i]]));
        }
        return vals;
      },
    
      // Compiles the `order by` statements.
      _groupsOrders: function _groupsOrders(type) {
        var items = this.grouped[type];
        if (!items) return '';
        var formatter = this.formatter;
        var sql = items.map(function (item) {
          return (item.value instanceof Raw ? formatter.unwrapRaw(item.value) : formatter.columnize(item.value)) + (type === 'order' && item.type !== 'orderByRaw' ? ' ' + formatter.direction(item.direction) : '');
        });
        return sql.length ? type + ' by ' + sql.join(', ') : '';
      }
    
    });
    
    QueryCompiler.prototype.first = QueryCompiler.prototype.select;
    
    // Get the table name, wrapping it if necessary.
    // Implemented as a property to prevent ordering issues as described in #704.
    Object.defineProperty(QueryCompiler.prototype, 'tableName', {
      get: function get() {
        if (!this._tableName) {
          // Only call this.formatter.wrap() the first time this property is accessed.
          this._tableName = this.single.table ? this.formatter.wrap(this.single.table) : '';
        }
        return this._tableName;
      }
    });
    
    module.exports = QueryCompiler;
  provide("knex/lib/query/compiler", module.exports);
}(global));

// pakmanager:knex/lib/schema/builder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _ = require('lodash');
    var inherits = require('inherits');
    var EventEmitter = require('events').EventEmitter;
    
    // Constructor for the builder instance, typically called from
    // `knex.builder`, accepting the current `knex` instance,
    // and pulling out the `client` and `grammar` from the current
    // knex instance.
    function SchemaBuilder(client) {
      this.client = client;
      this._sequence = [];
      this._debug = client.config && client.config.debug;
    }
    inherits(SchemaBuilder, EventEmitter);
    
    // Each of the schema builder methods just add to the
    // "_sequence" array for consistency.
    _.each(['createTable', 'createTableIfNotExists', 'createSchema', 'createSchemaIfNotExists', 'dropSchema', 'dropSchemaIfExists', 'createExtension', 'createExtensionIfNotExists', 'dropExtension', 'dropExtensionIfExists', 'table', 'alterTable', 'hasTable', 'hasColumn', 'dropTable', 'renameTable', 'dropTableIfExists', 'raw'], function (method) {
      SchemaBuilder.prototype[method] = function () {
        if (method === 'table') method = 'alterTable';
        this._sequence.push({
          method: method,
          args: _.toArray(arguments)
        });
        return this;
      };
    });
    
     require('knex/lib/interface')(SchemaBuilder);
    
    SchemaBuilder.prototype.toString = function () {
      return this.toQuery();
    };
    
    SchemaBuilder.prototype.toSQL = function () {
      return this.client.schemaCompiler(this).toSQL();
    };
    
    module.exports = SchemaBuilder;
  provide("knex/lib/schema/builder", module.exports);
}(global));

// pakmanager:knex/lib/schema/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var helpers =  require('knex/lib/helpers');
    var assign = require('lodash/object/assign');
    
    // The "SchemaCompiler" takes all of the query statements which have been
    // gathered in the "SchemaBuilder" and turns them into an array of
    // properly formatted / bound query strings.
    function SchemaCompiler(client, builder) {
      this.builder = builder;
      this.client = client;
      this.formatter = client.formatter();
      this.sequence = [];
    }
    
    assign(SchemaCompiler.prototype, {
    
      pushQuery: helpers.pushQuery,
    
      pushAdditional: helpers.pushAdditional,
    
      createTable: buildTable('create'),
    
      createTableIfNotExists: buildTable('createIfNot'),
    
      alterTable: buildTable('alter'),
    
      dropTable: function dropTable(tableName) {
        this.pushQuery('drop table ' + this.formatter.wrap(tableName));
      },
    
      dropTableIfExists: function dropTableIfExists(tableName) {
        this.pushQuery('drop table if exists ' + this.formatter.wrap(tableName));
      },
    
      raw: function raw(sql, bindings) {
        this.sequence.push(this.client.raw(sql, bindings).toSQL());
      },
    
      toSQL: function toSQL() {
        var sequence = this.builder._sequence;
        for (var i = 0, l = sequence.length; i < l; i++) {
          var query = sequence[i];
          this[query.method].apply(this, query.args);
        }
        return this.sequence;
      }
    
    });
    
    function buildTable(type) {
      return function (tableName, fn) {
        var sql = this.client.tableBuilder(type, tableName, fn).toSQL();
        for (var i = 0, l = sql.length; i < l; i++) {
          this.sequence.push(sql[i]);
        }
      };
    }
    
    module.exports = SchemaCompiler;
  provide("knex/lib/schema/compiler", module.exports);
}(global));

// pakmanager:knex/lib/schema/tablebuilder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // TableBuilder
    
    // Takes the function passed to the "createTable" or "table/editTable"
    // functions and calls it with the "TableBuilder" as both the context and
    // the first argument. Inside this function we can specify what happens to the
    // method, pushing everything we want to do onto the "allStatements" array,
    // which is then compiled into sql.
    // ------
    'use strict';
    
    var _ = require('lodash');
    var helpers =  require('knex/lib/helpers');
    
    function TableBuilder(client, method, tableName, fn) {
      this.client = client;
      this._fn = fn;
      this._method = method;
      this._tableName = tableName;
      this._statements = [];
      this._single = {};
    }
    
    // Convert the current tableBuilder object "toSQL"
    // giving us additional methods if we're altering
    // rather than creating the table.
    TableBuilder.prototype.toSQL = function () {
      if (this._method === 'alter') {
        _.extend(this, AlterMethods);
      }
      this._fn.call(this, this);
      return this.client.tableCompiler(this).toSQL();
    };
    
    _.each([
    
    // Each of the index methods can be called individually, with the
    // column name to be used, e.g. table.unique('column').
    'index', 'primary', 'unique',
    
    // Key specific
    'dropPrimary', 'dropUnique', 'dropIndex', 'dropForeign'], function (method) {
      TableBuilder.prototype[method] = function () {
        this._statements.push({
          grouping: 'alterTable',
          method: method,
          args: _.toArray(arguments)
        });
        return this;
      };
    });
    
    // Warn if we're not in MySQL, since that's the only time these
    // three are supported.
    var specialMethods = ['engine', 'charset', 'collate'];
    _.each(specialMethods, function (method) {
      TableBuilder.prototype[method] = function (value) {
        if (false) {
          helpers.warn('Knex only supports ' + method + ' statement with mysql.');
        }if (this._method === 'alter') {
          helpers.warn('Knex does not support altering the ' + method + ' outside of the create table, please use knex.raw statement.');
        }
        this._single[method] = value;
      };
    });
    
    // Each of the column types that we can add, we create a new ColumnBuilder
    // instance and push it onto the statements array.
    var columnTypes = [
    
    // Numeric
    'tinyint', 'smallint', 'mediumint', 'int', 'bigint', 'decimal', 'float', 'double', 'real', 'bit', 'boolean', 'serial',
    
    // Date / Time
    'date', 'datetime', 'timestamp', 'time', 'year',
    
    // String
    'char', 'varchar', 'tinytext', 'tinyText', 'text', 'mediumtext', 'mediumText', 'longtext', 'longText', 'binary', 'varbinary', 'tinyblob', 'tinyBlob', 'mediumblob', 'mediumBlob', 'blob', 'longblob', 'longBlob', 'enum', 'set',
    
    // Increments, Aliases, and Additional
    'bool', 'dateTime', 'increments', 'bigincrements', 'bigIncrements', 'integer', 'biginteger', 'bigInteger', 'string', 'timestamps', 'json', 'uuid', 'enu', 'specificType'];
    
    // For each of the column methods, create a new "ColumnBuilder" interface,
    // push it onto the "allStatements" stack, and then return the interface,
    // with which we can add indexes, etc.
    _.each(columnTypes, function (type) {
      TableBuilder.prototype[type] = function () {
        var args = _.toArray(arguments);
    
        // The "timestamps" call is really a compound call to set the
        // `created_at` and `updated_at` columns.
        if (type === 'timestamps') {
          if (args[0] === true) {
            this.timestamp('created_at');
            this.timestamp('updated_at');
          } else {
            this.datetime('created_at');
            this.datetime('updated_at');
          }
          return;
        }
        var builder = this.client.columnBuilder(this, type, args);
    
        this._statements.push({
          grouping: 'columns',
          builder: builder
        });
        return builder;
      };
    });
    
    // Set the comment value for a table, they're only allowed to be called
    // once per table.
    TableBuilder.prototype.comment = function (value) {
      this._single.comment = value;
    };
    
    // Set a foreign key on the table, calling
    // `table.foreign('column_name').references('column').on('table').onDelete()...
    // Also called from the ColumnBuilder context when chaining.
    TableBuilder.prototype.foreign = function (column) {
      var foreignData = { column: column };
      this._statements.push({
        grouping: 'alterTable',
        method: 'foreign',
        args: [foreignData]
      });
      var returnObj = {
        references: function references(tableColumn) {
          var pieces;
          if (_.isString(tableColumn)) {
            pieces = tableColumn.split('.');
          }
          if (!pieces || pieces.length === 1) {
            foreignData.references = pieces ? pieces[0] : tableColumn;
            return {
              on: function on(tableName) {
                foreignData.inTable = tableName;
                return returnObj;
              },
              inTable: function inTable() {
                return this.on.apply(this, arguments);
              }
            };
          }
          foreignData.inTable = pieces[0];
          foreignData.references = pieces[1];
          return returnObj;
        },
        onUpdate: function onUpdate(statement) {
          foreignData.onUpdate = statement;
          return returnObj;
        },
        onDelete: function onDelete(statement) {
          foreignData.onDelete = statement;
          return returnObj;
        },
        _columnBuilder: function _columnBuilder(builder) {
          _.extend(builder, returnObj);
          returnObj = builder;
          return builder;
        }
      };
      return returnObj;
    };
    
    var AlterMethods = {
    
      // Renames the current column `from` the current
      // TODO: this.column(from).rename(to)
      renameColumn: function renameColumn(from, to) {
        this._statements.push({
          grouping: 'alterTable',
          method: 'renameColumn',
          args: [from, to]
        });
        return this;
      },
    
      dropTimestamps: function dropTimestamps() {
        return this.dropColumns(['created_at', 'updated_at']);
      }
    
      // TODO: changeType
    };
    
    // Drop a column from the current table.
    // TODO: Enable this.column(columnName).drop();
    AlterMethods.dropColumn = AlterMethods.dropColumns = function () {
      this._statements.push({
        grouping: 'alterTable',
        method: 'dropColumn',
        args: _.toArray(arguments)
      });
      return this;
    };
    
    module.exports = TableBuilder;
  provide("knex/lib/schema/tablebuilder", module.exports);
}(global));

// pakmanager:knex/lib/schema/tablecompiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Table Compiler
    // -------
    'use strict';
    
    var _ = require('lodash');
    var helpers =  require('knex/lib/helpers');
    var normalizeArr =  require('knex/lib/helpers').normalizeArr;
    
    function TableCompiler(client, tableBuilder) {
      this.client = client;
      this.method = tableBuilder._method;
      this.tableNameRaw = tableBuilder._tableName;
      this.single = tableBuilder._single;
      this.grouped = _.groupBy(tableBuilder._statements, 'grouping');
      this.formatter = client.formatter();
      this.sequence = [];
    }
    
    TableCompiler.prototype.pushQuery = helpers.pushQuery;
    
    TableCompiler.prototype.pushAdditional = helpers.pushAdditional;
    
    // Convert the tableCompiler toSQL
    TableCompiler.prototype.toSQL = function () {
      this[this.method]();
      return this.sequence;
    };
    
    // Column Compilation
    // -------
    
    // If this is a table "creation", we need to first run through all
    // of the columns to build them into a single string,
    // and then run through anything else and push it to the query sequence.
    TableCompiler.prototype.create = function (ifNot) {
      var columns = this.getColumns();
      var columnTypes = this.getColumnTypes(columns);
      this.createQuery(columnTypes, ifNot);
      this.columnQueries(columns);
      delete this.single.comment;
      this.alterTable();
    };
    
    // Only create the table if it doesn't exist.
    TableCompiler.prototype.createIfNot = function () {
      this.create(true);
    };
    
    // If we're altering the table, we need to one-by-one
    // go through and handle each of the queries associated
    // with altering the table's schema.
    TableCompiler.prototype.alter = function () {
      var columns = this.getColumns();
      var columnTypes = this.getColumnTypes(columns);
      this.addColumns(columnTypes);
      this.columnQueries(columns);
      this.alterTable();
    };
    
    TableCompiler.prototype.foreign = function (foreignData) {
      if (foreignData.inTable && foreignData.references) {
        var keyName = this._indexCommand('foreign', this.tableNameRaw, foreignData.column);
        var column = this.formatter.columnize(foreignData.column);
        var references = this.formatter.columnize(foreignData.references);
        var inTable = this.formatter.wrap(foreignData.inTable);
        var onUpdate = foreignData.onUpdate ? ' on update ' + foreignData.onUpdate : '';
        var onDelete = foreignData.onDelete ? ' on delete ' + foreignData.onDelete : '';
        this.pushQuery('alter table ' + this.tableName() + ' add constraint ' + keyName + ' ' + 'foreign key (' + column + ') references ' + inTable + ' (' + references + ')' + onUpdate + onDelete);
      }
    };
    
    // Get all of the column sql & bindings individually for building the table queries.
    TableCompiler.prototype.getColumnTypes = function (columns) {
      return _.reduce(_.map(columns, _.first), function (memo, column) {
        memo.sql.push(column.sql);
        memo.bindings.concat(column.bindings);
        return memo;
      }, { sql: [], bindings: [] });
    };
    
    // Adds all of the additional queries from the "column"
    TableCompiler.prototype.columnQueries = function (columns) {
      var queries = _.reduce(_.map(columns, _.rest), function (memo, column) {
        if (!_.isEmpty(column)) return memo.concat(column);
        return memo;
      }, []);
      for (var i = 0, l = queries.length; i < l; i++) {
        this.pushQuery(queries[i]);
      }
    };
    
    // Add a new column.
    TableCompiler.prototype.addColumnsPrefix = 'add column ';
    
    // All of the columns to "add" for the query
    TableCompiler.prototype.addColumns = function (columns) {
      if (columns.sql.length > 0) {
        var columnSql = _.map(columns.sql, function (column) {
          return this.addColumnsPrefix + column;
        }, this);
        this.pushQuery({
          sql: 'alter table ' + this.tableName() + ' ' + columnSql.join(', '),
          bindings: columns.bindings
        });
      }
    };
    
    // Compile the columns as needed for the current create or alter table
    TableCompiler.prototype.getColumns = function () {
      var i = -1,
          compiledColumns = [],
          columns = this.grouped.columns || [];
      while (++i < columns.length) {
        compiledColumns.push(this.client.columnCompiler(this, columns[i].builder).toSQL());
      }
      return compiledColumns;
    };
    
    TableCompiler.prototype.tableName = function () {
      return this.formatter.wrap(this.tableNameRaw);
    };
    
    // Generate all of the alter column statements necessary for the query.
    TableCompiler.prototype.alterTable = function () {
      var alterTable = this.grouped.alterTable || [];
      for (var i = 0, l = alterTable.length; i < l; i++) {
        var statement = alterTable[i];
        if (this[statement.method]) {
          this[statement.method].apply(this, statement.args);
        } else {
          console.error('Debug: ' + statement.method + ' does not exist');
        }
      }
      for (var item in this.single) {
        if (typeof this[item] === 'function') this[item](this.single[item]);
      }
    };
    
    // Drop the index on the current table.
    TableCompiler.prototype.dropIndex = function (value) {
      this.pushQuery('drop index' + value);
    };
    
    // Drop the unique
    TableCompiler.prototype.dropUnique = TableCompiler.prototype.dropForeign = function () {
      throw new Error('Method implemented in the dialect driver');
    };
    
    TableCompiler.prototype.dropColumnPrefix = 'drop column ';
    TableCompiler.prototype.dropColumn = function () {
      var columns = normalizeArr.apply(null, arguments);
      var drops = _.map(_.isArray(columns) ? columns : [columns], function (column) {
        return this.dropColumnPrefix + this.formatter.wrap(column);
      }, this);
      this.pushQuery('alter table ' + this.tableName() + ' ' + drops.join(', '));
    };
    
    // If no name was specified for this index, we will create one using a basic
    // convention of the table name, followed by the columns, followed by an
    // index type, such as primary or index, which makes the index unique.
    TableCompiler.prototype._indexCommand = function (type, tableName, columns) {
      if (!_.isArray(columns)) columns = columns ? [columns] : [];
      var table = tableName.replace(/\.|-/g, '_');
      return (table + '_' + columns.join('_') + '_' + type).toLowerCase();
    };
    
    module.exports = TableCompiler;
  provide("knex/lib/schema/tablecompiler", module.exports);
}(global));

// pakmanager:knex/lib/schema/columnbuilder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _ = require('lodash');
    
    // The chainable interface off the original "column" method.
    function ColumnBuilder(client, tableBuilder, type, args) {
      this.client = client;
      this._single = {};
      this._modifiers = {};
      this._statements = [];
      this._type = columnAlias[type] || type;
      this._args = args;
      this._tableBuilder = tableBuilder;
    
      // If we're altering the table, extend the object
      // with the available "alter" methods.
      if (tableBuilder._method === 'alter') {
        _.extend(this, AlterMethods);
      }
    }
    
    // All of the modifier methods that can be used to modify the current query.
    var modifiers = ['default', 'defaultsTo', 'defaultTo', 'unsigned', 'nullable', 'notNull', 'notNullable', 'first', 'after', 'comment'];
    
    // If we call any of the modifiers (index or otherwise) on the chainable, we pretend
    // as though we're calling `table.method(column)` directly.
    _.each(modifiers, function (method) {
      ColumnBuilder.prototype[method] = function () {
        if (aliasMethod[method]) {
          method = aliasMethod[method];
        }
        if (method === 'notNullable') return this.nullable(false);
        this._modifiers[method] = _.toArray(arguments);
        return this;
      };
    });
    
    _.each(['index', 'primary', 'unique'], function (method) {
      ColumnBuilder.prototype[method] = function () {
        if (this._type.toLowerCase().indexOf('increments') === -1) {
          this._tableBuilder[method].apply(this._tableBuilder, [this._args[0]].concat(_.toArray(arguments)));
        }
        return this;
      };
    });
    
    // Specify that the current column "references" a column,
    // which may be tableName.column or just "column"
    ColumnBuilder.prototype.references = function (value) {
      return this._tableBuilder.foreign.call(this._tableBuilder, this._args[0], this)._columnBuilder(this).references(value);
    };
    
    var AlterMethods = {};
    
    // Specify that the column is to be dropped. This takes precedence
    // over all other rules for the column.
    AlterMethods.drop = function () {
      this._single.drop = true;
      return this;
    };
    
    // Specify the "type" that we're looking to set the
    // Knex takes no responsibility for any data-loss that may
    // occur when changing data types.
    AlterMethods.alterType = function (type) {
      this._statements.push({
        grouping: 'alterType',
        value: type
      });
      return this;
    };
    
    // Aliases for convenience.
    var aliasMethod = {
      'default': 'defaultTo',
      defaultsTo: 'defaultTo',
      notNull: 'notNullable'
    };
    
    // Alias a few methods for clarity when processing.
    var columnAlias = {
      'float': 'floating',
      'enum': 'enu',
      'boolean': 'bool',
      'string': 'varchar',
      'bigint': 'bigInteger'
    };
    
    module.exports = ColumnBuilder;
  provide("knex/lib/schema/columnbuilder", module.exports);
}(global));

// pakmanager:knex/lib/schema/columncompiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // Column Compiler
    // Used for designating column definitions
    // during the table "create" / "alter" statements.
    // -------
    'use strict';
    
    var _ = require('lodash');
    var Raw =  require('knex/lib/raw');
    var helpers =  require('knex/lib/helpers');
    
    function ColumnCompiler(client, tableCompiler, columnBuilder) {
      this.client = client;
      this.tableCompiler = tableCompiler;
      this.columnBuilder = columnBuilder;
      this.args = columnBuilder._args;
      this.type = columnBuilder._type.toLowerCase();
      this.grouped = _.groupBy(columnBuilder._statements, 'grouping');
      this.modified = columnBuilder._modifiers;
      this.isIncrements = this.type.indexOf('increments') !== -1;
      this.formatter = client.formatter();
      this.sequence = [];
    }
    
    ColumnCompiler.prototype.pushQuery = helpers.pushQuery;
    
    ColumnCompiler.prototype.pushAdditional = helpers.pushAdditional;
    
    // To convert to sql, we first go through and build the
    // column as it would be in the insert statement
    ColumnCompiler.prototype.toSQL = function () {
      this.pushQuery(this.compileColumn());
      if (this.sequence.additional) {
        this.sequence = this.sequence.concat(this.sequence.additional);
      }
      return this.sequence;
    };
    
    // Compiles a column.
    ColumnCompiler.prototype.compileColumn = function () {
      return this.formatter.wrap(this.getColumnName()) + ' ' + this.getColumnType() + this.getModifiers();
    };
    
    // Assumes the autoincrementing key is named `id` if not otherwise specified.
    ColumnCompiler.prototype.getColumnName = function () {
      var value = _.first(this.args);
      if (value) return value;
      if (this.isIncrements) {
        return 'id';
      } else {
        throw new Error('You did not specify a column name for the ' + this.type + 'column.');
      }
    };
    
    ColumnCompiler.prototype.getColumnType = function () {
      var type = this[this.type];
      return typeof type === 'function' ? type.apply(this, _.rest(this.args)) : type;
    };
    
    ColumnCompiler.prototype.getModifiers = function () {
      var modifiers = [];
      if (this.type.indexOf('increments') === -1) {
        for (var i = 0, l = this.modifiers.length; i < l; i++) {
          var modifier = this.modifiers[i];
          if (_.has(this.modified, modifier)) {
            var val = this[modifier].apply(this, this.modified[modifier]);
            if (val) modifiers.push(val);
          }
        }
      }
      return modifiers.length > 0 ? ' ' + modifiers.join(' ') : '';
    };
    
    // Types
    // ------
    
    ColumnCompiler.prototype.increments = 'integer not null primary key autoincrement';
    ColumnCompiler.prototype.bigincrements = 'integer not null primary key autoincrement';
    ColumnCompiler.prototype.integer = ColumnCompiler.prototype.smallint = ColumnCompiler.prototype.mediumint = 'integer';
    ColumnCompiler.prototype.biginteger = 'bigint';
    ColumnCompiler.prototype.varchar = function (length) {
      return 'varchar(' + this._num(length, 255) + ')';
    };
    ColumnCompiler.prototype.text = 'text';
    ColumnCompiler.prototype.tinyint = 'tinyint';
    ColumnCompiler.prototype.floating = function (precision, scale) {
      return 'float(' + this._num(precision, 8) + ', ' + this._num(scale, 2) + ')';
    };
    ColumnCompiler.prototype.decimal = function (precision, scale) {
      return 'decimal(' + this._num(precision, 8) + ', ' + this._num(scale, 2) + ')';
    };
    ColumnCompiler.prototype.binary = 'blob';
    ColumnCompiler.prototype.bool = 'boolean';
    ColumnCompiler.prototype.date = 'date';
    ColumnCompiler.prototype.datetime = 'datetime';
    ColumnCompiler.prototype.time = 'time';
    ColumnCompiler.prototype.timestamp = 'timestamp';
    ColumnCompiler.prototype.enu = 'varchar';
    
    ColumnCompiler.prototype.bit = ColumnCompiler.prototype.json = 'text';
    
    ColumnCompiler.prototype.uuid = 'char(36)';
    ColumnCompiler.prototype.specifictype = function (type) {
      return type;
    };
    
    // Modifiers
    // -------
    
    ColumnCompiler.prototype.nullable = function (nullable) {
      return nullable === false ? 'not null' : 'null';
    };
    ColumnCompiler.prototype.notNullable = function () {
      return this.nullable(false);
    };
    ColumnCompiler.prototype.defaultTo = function (value) {
      if (value === void 0) {
        return '';
      } else if (value === null) {
        value = 'null';
      } else if (value instanceof Raw) {
        value = value.toQuery();
      } else if (this.type === 'bool') {
        if (value === 'false') value = 0;
        value = '\'' + (value ? 1 : 0) + '\'';
      } else if (this.type === 'json' && _.isObject(value)) {
        return JSON.stringify(value);
      } else {
        value = '\'' + value + '\'';
      }
      return 'default ' + value;
    };
    ColumnCompiler.prototype._num = function (val, fallback) {
      if (val === undefined || val === null) return fallback;
      var number = parseInt(val, 10);
      return isNaN(number) ? fallback : number;
    };
    
    module.exports = ColumnCompiler;
  provide("knex/lib/schema/columncompiler", module.exports);
}(global));

// pakmanager:knex/lib/client
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Promise =  require('knex/lib/promise');
    var helpers =  require('knex/lib/helpers');
    
    var Raw =  require('knex/lib/raw');
    var Runner =  require('knex/lib/runner');
    var Formatter =  require('knex/lib/formatter');
    var Transaction =  require('knex/lib/transaction');
    
    var QueryBuilder =  require('knex/lib/query/builder');
    var QueryCompiler =  require('knex/lib/query/compiler');
    
    var SchemaBuilder =  require('knex/lib/schema/builder');
    var SchemaCompiler =  require('knex/lib/schema/compiler');
    var TableBuilder =  require('knex/lib/schema/tablebuilder');
    var TableCompiler =  require('knex/lib/schema/tablecompiler');
    var ColumnBuilder =  require('knex/lib/schema/columnbuilder');
    var ColumnCompiler =  require('knex/lib/schema/columncompiler');
    
    var Pool2 = require('pool2');
    var inherits = require('inherits');
    var EventEmitter = require('events').EventEmitter;
    var SqlString =  require('knex/lib/query/string');
    
    var assign = require('lodash/object/assign');
    var uniqueId = require('lodash/utility/uniqueId');
    var cloneDeep = require('lodash/lang/cloneDeep');
    var debug = require('debug')('knex:client');
    var debugQuery = require('debug')('knex:query');
    
    // The base client provides the general structure
    // for a dialect specific client object.
    function Client() {
      var config = arguments[0] === undefined ? {} : arguments[0];
    
      this.config = config;
      this.connectionSettings = cloneDeep(config.connection || {});
      if (this.driverName && config.connection) {
        this.initializeDriver();
        if (!config.pool || config.pool && config.pool.max !== 0) {
          this.initializePool(config);
        }
      }
    }
    inherits(Client, EventEmitter);
    
    assign(Client.prototype, {
    
      Formatter: Formatter,
    
      formatter: function formatter() {
        return new this.Formatter(this);
      },
    
      QueryBuilder: QueryBuilder,
    
      queryBuilder: function queryBuilder() {
        return new this.QueryBuilder(this);
      },
    
      QueryCompiler: QueryCompiler,
    
      queryCompiler: function queryCompiler(builder) {
        return new this.QueryCompiler(this, builder);
      },
    
      SchemaBuilder: SchemaBuilder,
    
      schemaBuilder: function schemaBuilder() {
        return new this.SchemaBuilder(this);
      },
    
      SchemaCompiler: SchemaCompiler,
    
      schemaCompiler: function schemaCompiler(builder) {
        return new this.SchemaCompiler(this, builder);
      },
    
      TableBuilder: TableBuilder,
    
      tableBuilder: function tableBuilder(type, tableName, fn) {
        return new this.TableBuilder(this, type, tableName, fn);
      },
    
      TableCompiler: TableCompiler,
    
      tableCompiler: function tableCompiler(tableBuilder) {
        return new this.TableCompiler(this, tableBuilder);
      },
    
      ColumnBuilder: ColumnBuilder,
    
      columnBuilder: function columnBuilder(tableBuilder, type, args) {
        return new this.ColumnBuilder(this, tableBuilder, type, args);
      },
    
      ColumnCompiler: ColumnCompiler,
    
      columnCompiler: function columnCompiler(tableBuilder, columnBuilder) {
        return new this.ColumnCompiler(this, tableBuilder, columnBuilder);
      },
    
      Runner: Runner,
    
      runner: function runner(connection) {
        return new this.Runner(this, connection);
      },
    
      Transaction: Transaction,
    
      transaction: function transaction(container, config, outerTx) {
        return new this.Transaction(this, container, config, outerTx);
      },
    
      Raw: Raw,
    
      raw: function raw() {
        var raw = new this.Raw(this);
        return raw.set.apply(raw, arguments);
      },
    
      query: function query(connection, obj) {
        if (typeof obj === 'string') obj = { sql: obj };
        this.emit('query', assign({ __knexUid: connection.__knexUid }, obj));
        debugQuery(obj.sql);
        return this._query.call(this, connection, obj)['catch'](function (err) {
          err.message = SqlString.format(obj.sql, obj.bindings) + ' - ' + err.message;
          throw err;
        });
      },
    
      stream: function stream(connection, obj, _stream, options) {
        if (typeof obj === 'string') obj = { sql: obj };
        this.emit('query', assign({ __knexUid: connection.__knexUid }, obj));
        debugQuery(obj.sql);
        return this._stream.call(this, connection, obj, _stream, options);
      },
    
      wrapIdentifier: function wrapIdentifier(value) {
        return value !== '*' ? '"' + value.replace(/"/g, '""') + '"' : '*';
      },
    
      initializeDriver: function initializeDriver() {
        try {
          this.driver = this._driver();
        } catch (e) {
          helpers.exit('Knex: run\n$ npm install ' + this.driverName + ' --save' + '\n' + e.stack);
        }
      },
    
      Pool: Pool2,
    
      initializePool: function initializePool(config) {
        if (this.pool) this.destroy();
        this.pool = new this.Pool(assign(this.poolDefaults(config.pool || {}), config.pool));
        this.pool.on('error', function (err) {
          helpers.error('Pool2 - ' + err);
        });
        this.pool.on('warn', function (msg) {
          helpers.warn('Pool2 - ' + msg);
        });
      },
    
      poolDefaults: function poolDefaults(poolConfig) {
        var dispose,
            client = this;
        if (poolConfig.destroy) {
          helpers.deprecate('config.pool.destroy', 'config.pool.dispose');
          dispose = poolConfig.destroy;
        }
        return {
          min: 2,
          max: 10,
          acquire: function acquire(callback) {
            client.acquireRawConnection().tap(function (connection) {
              connection.__knexUid = uniqueId('__knexUid');
              if (poolConfig.afterCreate) {
                return Promise.promisify(poolConfig.afterCreate)(connection);
              }
            }).nodeify(callback);
          },
          dispose: function dispose(connection, callback) {
            if (poolConfig.beforeDestroy) {
              poolConfig.beforeDestroy(connection, function () {
                if (connection !== undefined) {
                  client.destroyRawConnection(connection, callback);
                }
              });
            } else if (connection !== void 0) {
              client.destroyRawConnection(connection, callback);
            }
          }
        };
      },
    
      // Acquire a connection from the pool.
      acquireConnection: function acquireConnection() {
        var client = this;
        return new Promise(function (resolver, rejecter) {
          if (!client.pool) {
            return rejecter(new Error('There is no pool defined on the current client'));
          }
          client.pool.acquire(function (err, connection) {
            if (err) return rejecter(err);
            debug('acquiring connection from pool: %s', connection.__knexUid);
            resolver(connection);
          });
        });
      },
    
      // Releases a connection back to the connection pool,
      // returning a promise resolved when the connection is released.
      releaseConnection: function releaseConnection(connection) {
        var pool = this.pool;
        return new Promise(function (resolver) {
          debug('releasing connection to pool: %s', connection.__knexUid);
          pool.release(connection);
          resolver();
        });
      },
    
      // Destroy the current connection pool for the client.
      destroy: function destroy(callback) {
        var client = this;
        var promise = new Promise(function (resolver) {
          if (!client.pool) return resolver();
          client.pool.end(function () {
            client.pool = undefined;
            resolver();
          });
        });
        // Allow either a callback or promise interface for destruction.
        if (typeof callback === 'function') {
          promise.nodeify(callback);
        } else {
          return promise;
        }
      },
    
      // Return the database being used by this client.
      database: function database() {
        return this.connectionSettings.database;
      },
    
      toString: function toString() {
        return '[object KnexClient]';
      }
    
    });
    
    module.exports = Client;
  provide("knex/lib/client", module.exports);
}(global));

// pakmanager:knex/lib/dialects/sqlite3/query/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // SQLite3 Query Builder & Compiler
    
    'use strict';
    
    var _ = require('lodash');
    var inherits = require('inherits');
    var QueryCompiler =  require('knex/lib/query/compiler');
    var assign = require('lodash/object/assign');
    
    function QueryCompiler_SQLite3(client, builder) {
      QueryCompiler.call(this, client, builder);
    }
    inherits(QueryCompiler_SQLite3, QueryCompiler);
    
    assign(QueryCompiler_SQLite3.prototype, {
    
      // The locks are not applicable in SQLite3
      forShare: emptyStr,
    
      forUpdate: emptyStr,
    
      // SQLite requires us to build the multi-row insert as a listing of select with
      // unions joining them together. So we'll build out this list of columns and
      // then join them all together with select unions to complete the queries.
      insert: function insert() {
        var insertValues = this.single.insert || [];
        var sql = 'insert into ' + this.tableName + ' ';
    
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return '';
          } else if (insertValues.length === 1 && insertValues[0] && _.isEmpty(insertValues[0])) {
            return sql + this._emptyInsertValue;
          }
        } else if (typeof insertValues === 'object' && _.isEmpty(insertValues)) {
          return sql + this._emptyInsertValue;
        }
    
        var insertData = this._prepInsert(insertValues);
    
        if (_.isString(insertData)) {
          return sql + insertData;
        }
    
        if (insertData.columns.length === 0) {
          return '';
        }
    
        sql += '(' + this.formatter.columnize(insertData.columns) + ')';
    
        if (insertData.values.length === 1) {
          return sql + ' values (' + this.formatter.parameterize(insertData.values[0]) + ')';
        }
    
        var blocks = [];
        var i = -1;
        while (++i < insertData.values.length) {
          var i2 = -1,
              block = blocks[i] = [];
          var current = insertData.values[i];
          while (++i2 < insertData.columns.length) {
            block.push(this.formatter.alias(this.formatter.parameter(current[i2]), this.formatter.wrap(insertData.columns[i2])));
          }
          blocks[i] = block.join(', ');
        }
        return sql + ' select ' + blocks.join(' union all select ');
      },
    
      // Compile a truncate table statement into SQL.
      truncate: function truncate() {
        var table = this.tableName;
        return {
          sql: 'delete from ' + table,
          output: function output() {
            return this.query({ sql: 'delete from sqlite_sequence where name = ' + table })['catch'](function () {});
          }
        };
      },
    
      // Compiles a `columnInfo` query
      columnInfo: function columnInfo() {
        var column = this.single.columnInfo;
        return {
          sql: 'PRAGMA table_info(' + this.single.table + ')',
          output: function output(resp) {
            var maxLengthRegex = /.*\((\d+)\)/;
            var out = _.reduce(resp, function (columns, val) {
              var type = val.type;
              var maxLength = (maxLength = type.match(maxLengthRegex)) && maxLength[1];
              type = maxLength ? type.split('(')[0] : type;
              columns[val.name] = {
                type: type.toLowerCase(),
                maxLength: maxLength,
                nullable: !val.notnull,
                defaultValue: val.dflt_value
              };
              return columns;
            }, {});
            return column && out[column] || out;
          }
        };
      },
    
      limit: function limit() {
        var noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit && !this.single.offset) return '';
    
        // Workaround for offset only,
        // see http://stackoverflow.com/questions/10491492/sqllite-with-skip-offset-only-not-limit
        return 'limit ' + this.formatter.parameter(noLimit ? -1 : this.single.limit);
      }
    
    });
    
    function emptyStr() {
      return '';
    }
    
    module.exports = QueryCompiler_SQLite3;
  provide("knex/lib/dialects/sqlite3/query/compiler", module.exports);
}(global));

// pakmanager:knex/lib/dialects/sqlite3/schema/compiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // SQLite3: Column Builder & Compiler
    // -------
    'use strict';
    
    var _ = require('lodash');
    var inherits = require('inherits');
    var SchemaCompiler =  require('knex/lib/schema/compiler');
    
    // Schema Compiler
    // -------
    
    function SchemaCompiler_SQLite3() {
      SchemaCompiler.apply(this, arguments);
    }
    inherits(SchemaCompiler_SQLite3, SchemaCompiler);
    
    // Compile the query to determine if a table exists.
    SchemaCompiler_SQLite3.prototype.hasTable = function (tableName) {
      this.pushQuery({
        sql: 'select * from sqlite_master where type = \'table\' and name = ' + this.formatter.parameter(tableName),
        output: function output(resp) {
          return resp.length > 0;
        }
      });
    };
    
    // Compile the query to determine if a column exists.
    SchemaCompiler_SQLite3.prototype.hasColumn = function (tableName, column) {
      this.pushQuery({
        sql: 'PRAGMA table_info(' + this.formatter.wrap(tableName) + ')',
        output: function output(resp) {
          return _.some(resp, { name: column });
        }
      });
    };
    
    // Compile a rename table command.
    SchemaCompiler_SQLite3.prototype.renameTable = function (from, to) {
      this.pushQuery('alter table ' + this.formatter.wrap(from) + ' rename to ' + this.formatter.wrap(to));
    };
    
    module.exports = SchemaCompiler_SQLite3;
  provide("knex/lib/dialects/sqlite3/schema/compiler", module.exports);
}(global));

// pakmanager:knex/lib/dialects/sqlite3/schema/columncompiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var inherits = require('inherits');
    var ColumnCompiler =  require('knex/lib/schema/columncompiler');
    
    // Column Compiler
    // -------
    
    function ColumnCompiler_SQLite3() {
      this.modifiers = ['nullable', 'defaultTo'];
      ColumnCompiler.apply(this, arguments);
    }
    inherits(ColumnCompiler_SQLite3, ColumnCompiler);
    
    // Types
    // -------
    
    ColumnCompiler_SQLite3.prototype.double = ColumnCompiler_SQLite3.prototype.decimal = ColumnCompiler_SQLite3.prototype.floating = 'float';
    ColumnCompiler_SQLite3.prototype.timestamp = 'datetime';
    
    module.exports = ColumnCompiler_SQLite3;
  provide("knex/lib/dialects/sqlite3/schema/columncompiler", module.exports);
}(global));

// pakmanager:knex/lib/dialects/sqlite3/schema/tablecompiler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var _ = require('lodash');
    var inherits = require('inherits');
    var TableCompiler =  require('knex/lib/schema/tablecompiler');
    
    // Table Compiler
    // -------
    
    function TableCompiler_SQLite3() {
      TableCompiler.apply(this, arguments);
      this.primaryKey = void 0;
    }
    inherits(TableCompiler_SQLite3, TableCompiler);
    
    // Create a new table.
    TableCompiler_SQLite3.prototype.createQuery = function (columns, ifNot) {
      var createStatement = ifNot ? 'create table if not exists ' : 'create table ';
      var sql = createStatement + this.tableName() + ' (' + columns.sql.join(', ');
    
      // SQLite forces primary keys to be added when the table is initially created
      // so we will need to check for a primary key commands and add the columns
      // to the table's declaration here so they can be created on the tables.
      sql += this.foreignKeys() || '';
      sql += this.primaryKeys() || '';
      sql += ')';
    
      this.pushQuery(sql);
    };
    
    TableCompiler_SQLite3.prototype.addColumns = function (columns) {
      for (var i = 0, l = columns.sql.length; i < l; i++) {
        this.pushQuery({
          sql: 'alter table ' + this.tableName() + ' add column ' + columns.sql[i],
          bindings: columns.bindings[i]
        });
      }
    };
    
    // Compile a drop unique key command.
    TableCompiler_SQLite3.prototype.dropUnique = function (columns, indexName) {
      indexName = indexName || this._indexCommand('unique', this.tableNameRaw, columns);
      this.pushQuery('drop index ' + indexName);
    };
    
    TableCompiler_SQLite3.prototype.dropIndex = function (columns, indexName) {
      indexName = indexName || this._indexCommand('index', this.tableNameRaw, columns);
      this.pushQuery('drop index ' + indexName);
    };
    
    // Compile a unique key command.
    TableCompiler_SQLite3.prototype.unique = function (columns, indexName) {
      indexName = indexName || this._indexCommand('unique', this.tableNameRaw, columns);
      columns = this.formatter.columnize(columns);
      this.pushQuery('create unique index ' + indexName + ' on ' + this.tableName() + ' (' + columns + ')');
    };
    
    // Compile a plain index key command.
    TableCompiler_SQLite3.prototype.index = function (columns, indexName) {
      indexName = indexName || this._indexCommand('index', this.tableNameRaw, columns);
      columns = this.formatter.columnize(columns);
      this.pushQuery('create index ' + indexName + ' on ' + this.tableName() + ' (' + columns + ')');
    };
    
    TableCompiler_SQLite3.prototype.primary = TableCompiler_SQLite3.prototype.foreign = function () {
      if (this.method !== 'create' && this.method !== 'createIfNot') {
        console.warn('SQLite3 Foreign & Primary keys may only be added on create');
      }
    };
    
    TableCompiler_SQLite3.prototype.primaryKeys = function () {
      var pks = _.where(this.grouped.alterTable || [], { method: 'primary' });
      if (pks.length > 0 && pks[0].args.length > 0) {
        var args = Array.isArray(pks[0].args[0]) ? pks[0].args[0] : pks[0].args;
        return ', primary key (' + this.formatter.columnize(args) + ')';
      }
    };
    
    TableCompiler_SQLite3.prototype.foreignKeys = function () {
      var sql = '';
      var foreignKeys = _.where(this.grouped.alterTable || [], { method: 'foreign' });
      for (var i = 0, l = foreignKeys.length; i < l; i++) {
        var foreign = foreignKeys[i].args[0];
        var column = this.formatter.columnize(foreign.column);
        var references = this.formatter.columnize(foreign.references);
        var foreignTable = this.formatter.wrap(foreign.inTable);
        sql += ', foreign key(' + column + ') references ' + foreignTable + '(' + references + ')';
        if (foreign.onDelete) sql += ' on delete ' + foreign.onDelete;
        if (foreign.onUpdate) sql += ' on update ' + foreign.onUpdate;
      }
      return sql;
    };
    
    TableCompiler_SQLite3.prototype.createTableBlock = function () {
      return this.getColumns().concat().join(',');
    };
    
    // Compile a rename column command... very complex in sqlite
    TableCompiler_SQLite3.prototype.renameColumn = function (from, to) {
      var compiler = this;
      this.pushQuery({
        sql: 'PRAGMA table_info(' + this.tableName() + ')',
        output: function output(pragma) {
          return compiler.client.ddl(compiler, pragma, this.connection).renameColumn(from, to);
        }
      });
    };
    
    TableCompiler_SQLite3.prototype.dropColumn = function (column) {
      var compiler = this;
      this.pushQuery({
        sql: 'PRAGMA table_info(' + this.tableName() + ')',
        output: function output(pragma) {
          return compiler.client.ddl(compiler, pragma, this.connection).dropColumn(column);
        }
      });
    };
    
    module.exports = TableCompiler_SQLite3;
  provide("knex/lib/dialects/sqlite3/schema/tablecompiler", module.exports);
}(global));

// pakmanager:knex/lib/dialects/sqlite3/schema/ddl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // SQLite3_DDL
    //
    // All of the SQLite3 specific DDL helpers for renaming/dropping
    // columns and changing datatypes.
    // -------
    
    'use strict';
    
    var _ = require('lodash');
    var Promise = require('../../../promise');
    var assign = require('lodash/object/assign');
    
    // So altering the schema in SQLite3 is a major pain.
    // We have our own object to deal with the renaming and altering the types
    // for sqlite3 things.
    function SQLite3_DDL(client, tableCompiler, pragma, connection) {
      this.client = client;
      this.tableCompiler = tableCompiler;
      this.pragma = pragma;
      this.tableName = this.tableCompiler.tableNameRaw;
      this.alteredName = _.uniqueId('_knex_temp_alter');
      this.connection = connection;
    }
    
    assign(SQLite3_DDL.prototype, {
    
      getColumn: Promise.method(function (column) {
        var currentCol = _.findWhere(this.pragma, { name: column });
        if (!currentCol) throw new Error('The column ' + column + ' is not in the ' + this.tableName + ' table');
        return currentCol;
      }),
    
      getTableSql: function getTableSql() {
        return this.trx.raw('SELECT name, sql FROM sqlite_master WHERE type="table" AND name="' + this.tableName + '"');
      },
    
      renameTable: Promise.method(function () {
        return this.trx.raw('ALTER TABLE "' + this.tableName + '" RENAME TO "' + this.alteredName + '"');
      }),
    
      dropOriginal: function dropOriginal() {
        return this.trx.raw('DROP TABLE "' + this.tableName + '"');
      },
    
      dropTempTable: function dropTempTable() {
        return this.trx.raw('DROP TABLE "' + this.alteredName + '"');
      },
    
      copyData: function copyData() {
        return this.trx.raw('SELECT * FROM "' + this.tableName + '"').bind(this).then(this.insertChunked(20, this.alteredName));
      },
    
      reinsertData: function reinsertData(iterator) {
        return function () {
          return this.trx.raw('SELECT * FROM "' + this.alteredName + '"').bind(this).then(this.insertChunked(20, this.tableName, iterator));
        };
      },
    
      insertChunked: function insertChunked(amount, target, iterator) {
        iterator = iterator || function (noop) {
          return noop;
        };
        return function (result) {
          var batch = [];
          var ddl = this;
          return Promise.reduce(result, function (memo, row) {
            memo++;
            batch.push(row);
            if (memo % 20 === 0 || memo === result.length) {
              return ddl.trx.queryBuilder().table(target).insert(_.map(batch, iterator)).then(function () {
                batch = [];
              }).thenReturn(memo);
            }
            return memo;
          }, 0);
        };
      },
    
      createTempTable: function createTempTable(createTable) {
        return function () {
          return this.trx.raw(createTable.sql.replace(this.tableName, this.alteredName));
        };
      },
    
      _doReplace: function _doReplace(sql, from, to) {
        var matched = sql.match(/^CREATE TABLE (\S+) \((.*)\)/);
    
        var tableName = matched[1],
            defs = matched[2];
    
        if (!defs) {
          throw new Error('No column definitions in this statement!');
        }
    
        var parens = 0,
            args = [],
            ptr = 0;
        for (var i = 0, x = defs.length; i < x; i++) {
          switch (defs[i]) {
            case '(':
              parens++;
              break;
            case ')':
              parens--;
              break;
            case ',':
              if (parens === 0) {
                args.push(defs.slice(ptr, i));
                ptr = i + 1;
              }
              break;
            case ' ':
              if (ptr === i) {
                ptr = i + 1;
              }
              break;
          }
        }
        args.push(defs.slice(ptr, i));
    
        args = args.map(function (item) {
          var split = item.split(' ');
    
          if (split[0] === from) {
            // column definition
            if (to) {
              split[0] = to;
              return split.join(' ');
            }
            return ''; // for deletions
          }
    
          // skip constraint name
          var idx = /constraint/i.test(split[0]) ? 2 : 0;
    
          // primary key and unique constraints have one or more
          // columns from this table listed between (); replace
          // one if it matches
          if (/primary|unique/i.test(split[idx])) {
            return item.replace(/\(.*\)/, function (columns) {
              return columns.replace(from, to);
            });
          }
    
          // foreign keys have one or more columns from this table
          // listed between (); replace one if it matches
          // foreign keys also have a 'references' clause
          // which may reference THIS table; if it does, replace
          // column references in that too!
          if (/foreign/.test(split[idx])) {
            split = item.split(/ references /i);
            // the quoted column names save us from having to do anything
            // other than a straight replace here
            split[0] = split[0].replace(from, to);
    
            if (split[1].slice(0, tableName.length) === tableName) {
              split[1] = split[1].replace(/\(.*\)/, function (columns) {
                return columns.replace(from, to);
              });
            }
            return split.join(' references ');
          }
    
          return item;
        });
        return sql.replace(/\(.*\)/, function () {
          return '(' + args.join(', ') + ')';
        }).replace(/,\s*([,)])/, '$1');
      },
    
      // Boy, this is quite a method.
      renameColumn: Promise.method(function (from, to) {
        var currentCol;
    
        return this.client.transaction((function (trx) {
          this.trx = trx;
          return this.getColumn(from).bind(this).tap(function (col) {
            currentCol = col;
          }).then(this.getTableSql).then(function (sql) {
            var a = this.client.wrapIdentifier(from);
            var b = this.client.wrapIdentifier(to);
            var createTable = sql[0];
            var newSql = this._doReplace(createTable.sql, a, b);
            if (sql === newSql) {
              throw new Error('Unable to find the column to change');
            }
            return Promise.bind(this).then(this.createTempTable(createTable)).then(this.copyData).then(this.dropOriginal).then(function () {
              return this.trx.raw(newSql);
            }).then(this.reinsertData(function (row) {
              row[to] = row[from];
              return _.omit(row, from);
            })).then(this.dropTempTable);
          });
        }).bind(this), { connection: this.connection });
      }),
    
      dropColumn: Promise.method(function (column) {
        var currentCol;
    
        return this.client.transaction((function (trx) {
          this.trx = trx;
          return this.getColumn(column).tap(function (col) {
            currentCol = col;
          }).bind(this).then(this.getTableSql).then(function (sql) {
            var createTable = sql[0];
            var a = this.client.wrapIdentifier(column);
            var newSql = this._doReplace(createTable.sql, a, '');
            if (sql === newSql) {
              throw new Error('Unable to find the column to change');
            }
            return Promise.bind(this).then(this.createTempTable(createTable)).then(this.copyData).then(this.dropOriginal).then(function () {
              return this.trx.raw(newSql);
            }).then(this.reinsertData(function (row) {
              return _.omit(row, column);
            })).then(this.dropTempTable);
          });
        }).bind(this), { connection: this.connection });
      })
    
    });
    
    module.exports = SQLite3_DDL;
  provide("knex/lib/dialects/sqlite3/schema/ddl", module.exports);
}(global));

// pakmanager:knex/lib/dialects/websql/transaction
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var makeKnex =  require('knex/lib/util/make-knex');
    var Promise =  require('knex/lib/promise');
    var helpers =  require('knex/lib/helpers');
    var inherits = require('inherits');
    var EventEmitter = require('events').EventEmitter;
    
    function Transaction_WebSQL(client, container) {
      helpers.warn('WebSQL transactions will run queries, but do not commit or rollback');
      var trx = this;
      this._promise = Promise['try'](function () {
        container(makeKnex(makeClient(trx, client)));
      });
    }
    inherits(Transaction_WebSQL, EventEmitter);
    
    function makeClient(trx, client) {
    
      var trxClient = Object.create(client.constructor.prototype);
      trxClient.config = client.config;
      trxClient.connectionSettings = client.connectionSettings;
      trxClient.transacting = true;
    
      trxClient.on('query', function (arg) {
        trx.emit('query', arg);
      });
      trxClient.commit = function () {};
      trxClient.rollback = function () {};
    
      return trxClient;
    }
    
    var promiseInterface = ['then', 'bind', 'catch', 'finally', 'asCallback', 'spread', 'map', 'reduce', 'tap', 'thenReturn', 'return', 'yield', 'ensure', 'nodeify', 'exec'];
    
    // Creates a method which "coerces" to a promise, by calling a
    // "then" method on the current `Target`
    promiseInterface.forEach(function (method) {
      Transaction_WebSQL.prototype[method] = function () {
        return this._promise = this._promise[method].apply(this._promise, arguments);
      };
    });
    
    module.exports = Transaction_WebSQL;
  provide("knex/lib/dialects/websql/transaction", module.exports);
}(global));

// pakmanager:knex/lib/dialects/sqlite3
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // SQLite3
    // -------
    'use strict';
    
    var Promise =  require('knex/lib/promise');
    
    var inherits = require('inherits');
    var assign = require('lodash/object/assign');
    var pluck = require('lodash/collection/pluck');
    
    var Client =  require('knex/lib/client');
    var helpers =  require('knex/lib/helpers');
    
    var QueryCompiler =  require('knex/lib/query/compiler');
    var SchemaCompiler =  require('knex/lib/schema/compiler');
    var ColumnCompiler =  require('knex/lib/schema/columncompiler');
    var TableCompiler =  require('knex/lib/schema/tablecompiler');
    var SQLite3_DDL =  require('knex/lib/dialects/sqlite3/schema/ddl');
    
    function Client_SQLite3(config) {
      Client.call(this, config);
    }
    inherits(Client_SQLite3, Client);
    
    assign(Client_SQLite3.prototype, {
    
      dialect: 'sqlite3',
    
      driverName: 'sqlite3',
    
      _driver: function _driver() {
        return require('sqlite3');
      },
    
      SchemaCompiler: SchemaCompiler,
    
      QueryCompiler: QueryCompiler,
    
      ColumnCompiler: ColumnCompiler,
    
      TableCompiler: TableCompiler,
    
      ddl: function ddl(compiler, pragma, connection) {
        return new SQLite3_DDL(this, compiler, pragma, connection);
      },
    
      // Get a raw connection from the database, returning a promise with the connection object.
      acquireRawConnection: function acquireRawConnection() {
        var client = this;
        return new Promise(function (resolve, reject) {
          var db = new client.driver.Database(client.connectionSettings.filename, function (err) {
            if (err) return reject(err);
            resolve(db);
          });
        });
      },
    
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      destroyRawConnection: function destroyRawConnection(connection, cb) {
        connection.close();
        cb();
      },
    
      // Runs the query on the specified connection, providing the bindings and any other necessary prep work.
      _query: function _query(connection, obj) {
        var method = obj.method;
        var callMethod;
        switch (method) {
          case 'insert':
          case 'update':
          case 'counter':
          case 'del':
            callMethod = 'run';
            break;
          default:
            callMethod = 'all';
        }
        return new Promise(function (resolver, rejecter) {
          if (!connection || !connection[callMethod]) {
            return rejecter(new Error('Error calling ' + callMethod + ' on connection.'));
          }
          connection[callMethod](obj.sql, obj.bindings, function (err, response) {
            if (err) return rejecter(err);
            obj.response = response;
    
            // We need the context here, as it contains
            // the "this.lastID" or "this.changes"
            obj.context = this;
            return resolver(obj);
          });
        });
      },
    
      _stream: function _stream(connection, sql, stream) {
        var client = this;
        return new Promise(function (resolver, rejecter) {
          stream.on('error', rejecter);
          stream.on('end', resolver);
          return client._query(connection, sql).then(function (obj) {
            return obj.response;
          }).map(function (row) {
            stream.write(row);
          })['catch'](function (err) {
            stream.emit('error', err);
          }).then(function () {
            stream.end();
          });
        });
      },
    
      // Ensures the response is returned in the same format as other clients.
      processResponse: function processResponse(obj, runner) {
        var ctx = obj.context;
        var response = obj.response;
        if (obj.output) return obj.output.call(runner, response);
        switch (obj.method) {
          case 'select':
          case 'pluck':
          case 'first':
            response = helpers.skim(response);
            if (obj.method === 'pluck') response = pluck(response, obj.pluck);
            return obj.method === 'first' ? response[0] : response;
          case 'insert':
            return [ctx.lastID];
          case 'del':
          case 'update':
          case 'counter':
            return ctx.changes;
          default:
            return response;
        }
      },
    
      poolDefaults: function poolDefaults(config) {
        return assign(Client.prototype.poolDefaults.call(this, config), {
          min: 1,
          max: 1
        });
      }
    
    });
    
    module.exports = Client_SQLite3;
  provide("knex/lib/dialects/sqlite3", module.exports);
}(global));

// pakmanager:knex/lib/util/make-client
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var assign = require('lodash/object/assign');
    var inherits = require('inherits');
    
    // Ensure the client has fresh objects so we can tack onto
    // the prototypes without mutating them globally.
    module.exports = function makeClient(ParentClient) {
    
      if (typeof ParentClient.prototype === 'undefined') {
        throw new Error('A valid parent client must be passed to makeClient');
      }
    
      function Client(config) {
        ParentClient.call(this, config);
      }
      inherits(Client, ParentClient);
    
      function Formatter(client) {
        Formatter.super_.call(this, client);
      }
      inherits(Formatter, ParentClient.prototype.Formatter);
    
      function QueryBuilder(client) {
        QueryBuilder.super_.call(this, client);
      }
      inherits(QueryBuilder, ParentClient.prototype.QueryBuilder);
    
      function SchemaBuilder(client) {
        SchemaBuilder.super_.call(this, client);
      }
      inherits(SchemaBuilder, ParentClient.prototype.SchemaBuilder);
    
      function SchemaCompiler(client, builder) {
        SchemaCompiler.super_.call(this, client, builder);
      }
      inherits(SchemaCompiler, ParentClient.prototype.SchemaCompiler);
    
      function TableBuilder(client, method, tableName, fn) {
        TableBuilder.super_.call(this, client, method, tableName, fn);
      }
      inherits(TableBuilder, ParentClient.prototype.TableBuilder);
    
      function TableCompiler(client, tableBuilder) {
        TableCompiler.super_.call(this, client, tableBuilder);
      }
      inherits(TableCompiler, ParentClient.prototype.TableCompiler);
    
      function ColumnBuilder(client, tableBuilder, type, args) {
        ColumnBuilder.super_.call(this, client, tableBuilder, type, args);
      }
      inherits(ColumnBuilder, ParentClient.prototype.ColumnBuilder);
    
      function ColumnCompiler(client, tableCompiler, columnBuilder) {
        ColumnCompiler.super_.call(this, client, tableCompiler, columnBuilder);
      }
      inherits(ColumnCompiler, ParentClient.prototype.ColumnCompiler);
    
      assign(Client.prototype, {
        Formatter: Formatter,
        QueryBuilder: QueryBuilder,
        SchemaBuilder: SchemaBuilder,
        SchemaCompiler: SchemaCompiler,
        TableBuilder: TableBuilder,
        TableCompiler: TableCompiler,
        ColumnBuilder: ColumnBuilder,
        ColumnCompiler: ColumnCompiler
      });
    
      return Client;
    };
  provide("knex/lib/util/make-client", module.exports);
}(global));

// pakmanager:knex/lib/util/parse-connection
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var url = require('url');
    
    module.exports = parseConnectionString;
    
    function parseConnectionString(str) {
      var parsed = url.parse(str);
      var protocol = parsed.protocol;
      if (protocol && protocol.indexOf('maria') === 0) {
        protocol = 'maria';
      }
      if (protocol === null) {
        return {
          client: 'sqlite3',
          connection: {
            filename: str
          }
        };
      }
      if (protocol.slice(-1) === ':') {
        protocol = protocol.slice(0, -1);
      }
      return {
        client: protocol,
        connection: connectionObject(parsed)
      };
    }
    
    function connectionObject(parsed) {
      var connection = {};
      var db = parsed.pathname;
      if (db[0] === '/') {
        db = db.slice(1);
      }
      if (parsed.protocol.indexOf('maria') === 0) {
        connection.db = db;
      } else {
        connection.database = db;
      }
      if (parsed.hostname) {
        connection.host = parsed.hostname;
      }
      if (parsed.port) {
        connection.port = parsed.port;
      }
      if (parsed.auth) {
        var idx = parsed.auth.indexOf(':');
        if (idx !== -1) {
          connection.user = parsed.auth.slice(0, idx);
          if (idx < parsed.auth.length - 1) {
            connection.password = parsed.auth.slice(idx + 1);
          }
        }
      }
      return connection;
    }
  provide("knex/lib/util/parse-connection", module.exports);
}(global));

// pakmanager:knex/lib/dialects/websql/index.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    // WebSQL
    // -------
    'use strict';
    
    var inherits = require('inherits');
    var _ = require('lodash');
    
    var Transaction =  require('knex/lib/transaction');
    var Client_SQLite3 =  require('knex/lib/dialects/sqlite3');
    var Promise =  require('knex/lib/promise');
    var assign = require('lodash/object/assign');
    
    function Client_WebSQL(config) {
      Client_SQLite3.call(this, config);
      this.name = config.name || 'knex_database';
      this.version = config.version || '1.0';
      this.displayName = config.displayName || this.name;
      this.estimatedSize = config.estimatedSize || 5 * 1024 * 1024;
    }
    inherits(Client_WebSQL, Client_SQLite3);
    
    assign(Client_WebSQL.prototype, {
    
      Transaction: Transaction,
    
      dialect: 'websql',
    
      // Get a raw connection from the database, returning a promise with the connection object.
      acquireConnection: function acquireConnection() {
        var client = this;
        return new Promise(function (resolve, reject) {
          try {
            /*jslint browser: true*/
            var db = openDatabase(client.name, client.version, client.displayName, client.estimatedSize);
            db.transaction(function (t) {
              t.__knexUid = _.uniqueId('__knexUid');
              resolve(t);
            });
          } catch (e) {
            reject(e);
          }
        });
      },
    
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      releaseConnection: function releaseConnection() {
        return Promise.resolve();
      },
    
      // Runs the query on the specified connection,
      // providing the bindings and any other necessary prep work.
      _query: function _query(connection, obj) {
        return new Promise(function (resolver, rejecter) {
          if (!connection) return rejecter(new Error('No connection provided.'));
          connection.executeSql(obj.sql, obj.bindings, function (trx, response) {
            obj.response = response;
            return resolver(obj);
          }, function (trx, err) {
            rejecter(err);
          });
        });
      },
    
      _stream: function _stream(connection, sql, stream) {
        var client = this;
        return new Promise(function (resolver, rejecter) {
          stream.on('error', rejecter);
          stream.on('end', resolver);
          return client._query(connection, sql).then(function (obj) {
            return client.processResponse(obj);
          }).map(function (row) {
            stream.write(row);
          })['catch'](function (err) {
            stream.emit('error', err);
          }).then(function () {
            stream.end();
          });
        });
      },
    
      processResponse: function processResponse(obj, runner) {
        var resp = obj.response;
        if (obj.output) return obj.output.call(runner, resp);
        switch (obj.method) {
          case 'pluck':
          case 'first':
          case 'select':
            var results = [];
            for (var i = 0, l = resp.rows.length; i < l; i++) {
              results[i] = _.clone(resp.rows.item(i));
            }
            if (obj.method === 'pluck') results = _.pluck(results, obj.pluck);
            return obj.method === 'first' ? results[0] : results;
          case 'insert':
            return [resp.insertId];
          case 'delete':
          case 'update':
          case 'counter':
            return resp.rowsAffected;
          default:
            return resp;
        }
      }
    
    });
    
    module.exports = Client_WebSQL;
  provide("knex/lib/dialects/websql/index.js", module.exports);
}(global));

// pakmanager:knex/lib/index
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var Raw =  require('knex/lib/raw');
    var warn =  require('knex/lib/helpers').warn;
    var Client =  require('knex/lib/client');
    
    var makeClient =  require('knex/lib/util/make-client');
    var makeKnex =  require('knex/lib/util/make-knex');
    var parseConnection =  require('knex/lib/util/parse-connection');
    var assign = require('lodash/object/assign');
    
    function Knex(config) {
      if (typeof config === 'string') {
        return new Knex(assign(parseConnection(config), arguments[2]));
      }
      var Dialect;
      if (arguments.length === 0 || !config.client && !config.dialect) {
        Dialect = makeClient(Client);
      } else {
        var clientName = config.client || config.dialect;
        Dialect = makeClient(require('./dialects/' + (aliases[clientName] || clientName) + '/index.js'));
      }
      if (typeof config.connection === 'string') {
        config = assign({}, config, { connection: parseConnection(config.connection).connection });
      }
      return makeKnex(new Dialect(config));
    }
    
    // Expose Client on the main Knex namespace.
    Knex.Client = Client;
    
    // Run a "raw" query, though we can't do anything with it other than put
    // it in a query statement.
    Knex.raw = function (sql, bindings) {
      return new Raw({}).set(sql, bindings);
    };
    
    // Create a new "knex" instance with the appropriate configured client.
    Knex.initialize = function (config) {
      warn('knex.initialize is deprecated, pass your config object directly to the knex module');
      return new Knex(config);
    };
    
    // Bluebird
    Knex.Promise =  require('knex/lib/promise');
    
    // The client names we'll allow in the `{name: lib}` pairing.
    var aliases = {
      'mariadb': 'maria',
      'mariasql': 'maria',
      'pg': 'postgres',
      'postgresql': 'postgres',
      'sqlite': 'sqlite3'
    };
    
    // Doing this ensures Browserify works. Still need to figure out
    // the best way to do some of this.
    if (process.browser) {
       require('knex/lib/dialects/websql/index.js');
    }
    
    module.exports = Knex;
  provide("knex/lib/index", module.exports);
}(global));

// pakmanager:knex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Knex.js
    // --------------
    //     (c) 2014 Tim Griesser
    //     Knex may be freely distributed under the MIT license.
    //     For details and documentation:
    //     http://knexjs.org
    
    module.exports =  require('knex/lib/index')
  provide("knex", module.exports);
}(global));

// pakmanager:bookshelf-pagemaker
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Paginate Bookshelf Models with common formats
    
    module.exports = function(bookshelf) {
    	
    	
    	
    	
    	
    	// pagemaker format
    	function getPagemaker(params, Model) {
    		console.log('pagemaker');
    		return {};
    	}
    	
    
    	
    	
    	// Datatables format
    	function getDatatables(params, Model) {
    		
    		// set defaults if none provided
    		var draw             = parseInt(params.draw, 10) || 0;
    		var start            = parseInt(params.start, 10) || 0;
    		var length           = parseInt(params.length, 10) || 25;
    		var page             = { draw: draw };
    		
    		// create a model instance and get the tableName
    		// for use in the knex query
    		var m                = new Model();
    		var tableName        = m.tableName;
    		
    		
    		// construct a base knex object for the query
    		var query            = bookshelf.knex.select()
                                   .table(tableName);
    
    		// generate SQL for single or multi-column order		
    		for (var i = 0; i < params.order.length; i++) {
    			var order        = params.order[i];
    			var sortCol      = params.columns[parseInt(order.column, 10)].data;
    			query            = query.orderBy(sortCol, order.dir);
    		}
    
    		// return the filtered query results
    		return query.offset(start).limit(length).then(function(data) {
    			
    			page.data = data;
    		})
    		.then(function() {
    			
    			return query.count('id as CNT').then(function(count) {
    				
    				page.recordsTotal = count[0].CNT;
    				page.recordsFiltered = page.recordsTotal;
    				
    				return count;
    			});
    		})
    		.then(function() {
    			
    			return page;
    		});
    	}
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	// define the supported pagination types and their associated functions
    	var types = {
    		"pagemaker": {
    			"description": "Default Pagination type",
    			"paginate": function(params, Model) {
    				return getPagemaker(params, Model);
    			}
    		},
    		"datatables": {
    			"description": "jQuery Datatables format",
    			"paginate": function(params, Model) {
    				return getDatatables(params, Model);
    			}
    		}
    	};
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	
    	// return public objects
    	return {
    		types: types
    	};
    };
    
  provide("bookshelf-pagemaker", module.exports);
}(global));